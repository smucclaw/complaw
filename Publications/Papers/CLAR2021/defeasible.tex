\section{Defeasible Reasoning}\label{sec:defeasible}

% ----------------------------------------------------------------------
\subsection{Facets of Defeasible Reasoning}\label{sec:facets}

\begin{tcolorbox}[title=To be done]
Discussion on existing notions of defeasibility in particular in a legal context
\begin{itemize}
\item \cite{hart_concept_of_law_1997}
\item \cite{alchourron_makinson_hierarchies_of_regulations_1981}
\item \cite{hage_law_and_defeasibility_2003}
\item More recent: \cite{governatori21:_unrav_legal_refer_defeas_deont_logic}
\item Using SMT solvers for CASP:
  \cite{shen_lierler_smt_answer_set_kr_2018}. Some of the techniques are
  similar (use of Clark completion), but our purpose is not to simulate answer
  set programming in SMT solvers, but to represent legal reasoning. In this
  context, maybe also look at \cite{fages_consistency_clark_completion_1994}.
\end{itemize}
\end{tcolorbox}

Given a plethora of different notions of ``defeasibility'', we had to make a
choice as to which notions to support, and which semantics to give to them. We
will here concentrate on two concepts, which we call \emph{rule modifiers},
that limit the applicability of rules and make them ``defeasible''. They will
we be presented in \secref{sec:intro_rule_modifiers}, and we will see how to give
them a semantics in a classical first-order logic, but also in a non-monotonic
logic in a system based on Answer Set Programming
(\secref{sec:answer_set_programming}). An orthogonal question is that of
arriving at conclusion in absence of complete information, which, via the
mechanism of negation as \remms{as/by??} failure, often prones the use of
non-monotonic logics. In \secref{sec:rule_inversion}, we will see how similar
effects can be achieved by means of \emph{rule inversion}. An Answer Set
Programming approach to defeasible reasoning, with an emphasis on rule
modifiers, will be presented in \secref{sec:answer_set_programming}. We finish
with a comparison of the two strands of reasoning in \secref{sec:comparison}.


% ----------------------------------------------------------------------
\subsection{Introducing Rule Modifiers}\label{sec:intro_rule_modifiers}

We will concentrate on two rule modifiers that restrict the applicability of
rules and that frequently occur in law texts: \emph{subject to} and
\emph{despite}. To illustrate their use, we consider an excerpt of Singapore's
Professional Conduct Rules \S~34 \cite{professional_conduct_rules} (also see
\cite{morris21:_const_answer_set_progr_tool} for a more detailed treatment of
this case study):

\begin{description}
\item[(1)] A legal practitioner must not accept any executive appointment
  associated with any of the following businesses: 
  \begin{description}
  \item[(a)] any business which detracts from, is incompatible with, or
    derogates from the dignity of, the legal profession;
  \item[(b)] any business which materially interferes with the legal
    practitioner’s primary occupation of practising as a lawyer; (\dots)
  \end{description}
\item[(5)] Despite paragraph (1)(b), but subject to paragraph (1)(a) and (c)
  to (f), a locum solicitor may accept an executive appointment in a business
  entity which does not provide any legal services or law-related services, if
  all of the conditions set out in the Second Schedule are satisfied.
\end{description}

The two main notions developed in the Conduct Rules are which executive appointments a legal
practictioner \emph{may} or \emph{must not} accept under which
circumstances. As there is currently no direct support for deontic logics in
L4, these notions are defined as two predicates \texttt{MayAccept} and
\texttt{MustNotAccept}, with the intended meaning that these two notions are
contradictory, and this is indeed what will be provable after a complete
formalization.

Let us here concentrate on the modifiers \emph{despite} and \emph{subject
  to}. A synonym of ``despite'' that is often used in legal texts is
``notwithstanding'',  and a synonym of
``subject to'' is ``except as provided in'', see \cite{adams_contract_drafting_2004}.

The reading of rule (5) is the following:
\begin{itemize}
\item ``subject to paragraph (1)(a) and (c) to (f)'' means: rule (5) applies
  as far as (1)(a) and (c) to (f) is not established. Differently said, rules
  (1)(a) and (c) to (f) undercut or defeat rule (5).

  One way of explicitating the ``subject to'' clause would be to rewrite (5)
  to: ``Despite paragraph (1)(b), provided the business does not detract from,
  is incompatible with, or derogate from the dignity of, the legal profession;
  and provided that not [clauses (1)(c) to (f)]; then a locum
  sollicitor\footnote{in our class-based terminology, a subclass of legal
    practitioner} may accept an executive appointment.''

\item ``despite paragraph (1)(b)'' expresses that rule (5) overrides rule
  (1)(b). In a similar spirit as the ``subject to'' clause, this can be made
  explicit by introducing a proviso, however not locally in  rule (5), but
  remotely in rule (1)(b).

  One way of explicitating the ``despite'' clause of rule (5) would be to
  rewrite (1)(b) to: ``Provided (5) is not applicable, a legal practitioner
  must not accept any executive appointment associated with any business which
  materially interferes with the legal practitioner’s primary occupation of
  practising as a lawyer.''
\end{itemize}

The astute reader will have remarked that the treatment in both cases is
slightly different, and this is not related to the particular semantics of
\emph{subject to} and \emph{despite}: we can state defeasibility
\begin{itemize}
\item either in the form of (negated) preconditions of rules: ``rule $r_1$ is
  applicable if the preconditions of $r_2$ do not hold'';
\item or in the form of (negated) derivability of the postcondition of rules: ``rule $r_1$ is
  applicable if the postcondition of $r_2$ does not hold''.
\end{itemize}
We will subsequently come back to this difference\remms{where?}.

Before looking at a formalization, let us summarize this informal exposition
of defeasibility rule modifiers as follows:
\remms{Make the writing of the modifiers more homogenous: in italics or in quotes}
\begin{itemize}
\item ``$r_1$ subject to $r_2$'' and ``$r_1$ despite $r_2$'' are complementary
  ways of expressing that one rule may override the other rule. They have in
  common that $r_1$ and $r_2$ have contradicting conclusions. The conjunction
  of the conclusions can either be directly unsatisfiable (may accept vs.{}
  must not accept) or unsatisfiable \wrt{} an intended background theory
  (obtaining different maximal speeds is inconsistent when expecting
  \texttt{maxSp} to be functional in its fourth argument).
\item Both modifiers differ in that ``subject to'' modifies the rule to which
  it is attached, whereas ``despite'' has a remote effect.
\item They permit to structure a legal text, favoring conciseness and
  modularity: In the case of \emph{despite}, the overridden, typically more
  general rule need not be aware of the overriding, typically subordinate rules.
\item Even though these modifiers appear to be mechanisms on the meta-level in
  that they reasoning about rules, they can directly be reflected on the
  object-level.
\end{itemize}
Making the meaning of the modifiers explicit can therefore be understood as a
\emph{compilation} problem, which will be described in the following.

In L4, rule modifiers are introduced with the aid of \emph{rule annotations}, with a
list of rule names following the keywords \texttt{subjectTo} and
\texttt{despite}. We return to our running example and modify rule
\texttt{maxSpCarHighway} of \figref{fig:rules} with

\begin{lstlisting}
rule <maxSpCarHighway>
  {restrict: {despite: maxSpCarWorkday}}
# rest of rule unchanged
\end{lstlisting}

For the delight of the public of the country with the highest density of
sports cars, we also introduce a new rule:\remms{Problem with spaces in lstlisting}

\begin{lstlisting}
rule <maxSpSportsCar>
  {restrict: {subjectTo: maxSpCarWorkday, 
              despite: maxSpCarHighway}}
   for v: Vehicle, d: Day, r: Road
   if isSportsCar v && isHighway r
   then maxSp v d r 320
 \end{lstlisting}

In the following, we will examine the interaction of these rules.

% ----------------------------------------------------------------------
\subsection{Rule Modifiers in Classical Logic}\label{sec:rule_modifiers_in_classical_logic}

In this section, we will describe how to rewrite rules, progressively
eliminating the instructions appearing in the rule annotations so that in the
end, only purely logical rules remain. Whereas the first preprocessing steps
(\secref{sec:preprocessing}) are generic, we will discuss two variants of
conversion into logical format (\secrefs{sec:restr_precond} and
\ref{sec:restr_deriv}).



% ......................................................................
\subsubsection{Preprocessing}\label{sec:preprocessing}

Preprocessing consists of several elimination steps that are carried out in a
fixed order.

\paragraph{\textbf{``Despite''  elimination}}

As can be concluded from the discussion in \secref{sec:facets}, a
$\mathtt{despite}\; r_2$ clause appearing in rule $r_1$ is equivalent to a
$\mathtt{subjectTo}\; r_1$ clause in rule $r_2$. The first rule transformation
consists in applying exhaustively the following \emph{despite elimination}
rule transformer:
\remms[inline]{In the whole discussion (and the implementation), make a
  clearer distinction between rule set transformer \texttt{restrict} and rule
  generator / transformer \texttt{derived}.}

\noindent
\emph{despiteElim:}\\
$
\{r_1 \{\mathtt{restrict}: \{\mathtt{despite}\; r_2\} \uplus a_1\},\;\;
r_2\{\mathtt{restrict}: a_2\}, \dots\} \longrightarrow$\\
$\{r_1 \{\mathtt{restrict}: a_1\},\;\;
r_2\{\mathtt{restrict}:  \{\mathtt{subjectTo}\; r_1\} \uplus a_2\}, \dots\}
$

\begin{example}\label{ex:rewrite_despite}\mbox{}\\
Application of this rewrite rule to the three example rules \texttt{maxSpCarWorkday},
\texttt{maxSpCarHighway} and  \texttt{maxSpSportsCar} changes them to:

\begin{lstlisting}
rule <maxSpCarWorkday>
  {restrict: {subjectTo: maxSpCarHighway}}
rule <maxSpCarHighway>
  {restrict: {subjectTo: maxSpSportsCar}}
rule <maxSpSportsCar>
  {restrict: {subjectTo: maxSpCarWorkday}}
\end{lstlisting}
Here, only the headings are shown, the bodies of the rules are
unchanged. 
\end{example}

One defect of the rule set already becomes apparent to the human reader at
this point: the circular dependency of the rules. We will however continue
with our algorithm, applying the next step which will be to rewrite the
\texttt{\{restrict: \{subjectTo: \dots\}\}} clauses.  Please note that each
rule can be \texttt{subjectTo} several other rules, each of which may have a
complex structure as a result of transformations that are applied to it.


\paragraph{\textbf{``Subject'' To elimination}}

The rule transformer \emph{subjectToElim} does the following: it splits up the
rule into two rules, (1) its source (the rule body as originally given), and
(2) its definition as the result of applying a rule transformation function to
several rules.

\begin{example}\label{ex:rewrite_subject_to}\
Before stating the rule transformer, we show its effect on rule
\texttt{maxSpCarWorkday} of \exampleref{ex:rewrite_despite}. On rewriting
with \emph{subjectToElim}, the rule is transformed into two rules:

\begin{lstlisting}
# new rule name, body of rule unchanged
rule <maxSpCarWorkday'Orig>
   {source}
   for v: Vehicle, d: Day, r: Road
   if isCar v && isWorkday d
   then maxSp v d r 90

# rule with header and without body
rule <maxSpCarWorkday>
 {derived: {apply: 
 {restrictSubjectTo maxSpCarWorkday'Orig  maxSpSportsCar}}}
\end{lstlisting}
\remms[inline]{check syntax of apply}
\end{example}

We can now state the transformation (after grouping the
\texttt{subjectTo $r_2$}, \dots, \texttt{subjectTo $r_n$} into
\texttt{subjectTo $[r_2 \dots r_n]$}):


\noindent
\emph{subjectToElim:}\\
$
\{r_1 \{\mathtt{restrict}: \{\mathtt{subjectTo}\; [r_2, \dots, r_n]\}\}, \dots \} \longrightarrow$\\
$\{r_1^o \{\mathtt{source}\}, r_1 \{\mathtt{derived:}\; \{\mathtt{apply:}\; \{
\mathtt{restrictSubjectTo}\;\; r_1^o\; [r_2 \dots r_n] \}\}\}, \dots \}
$



\paragraph{\textbf{Computation of derived rule}}
The last step consists in generating the derived rules, by evaluating the
value of the rule transformer expression marked by \texttt{apply}. The rules
appearing in these expressions may themselves be defined by complex
expressions. However, direct or indirect recursion is not allowed. For
simplifying the expressions in a rule set, we compute a rule dependency order
$\preceq_R$ defined by: $r \preceq_R r'$ iff $r$ appears in the defining
expression of $r'$. If $\preceq_R$ is not a partial order (in particular, if
it is not cycle-free), then evaluation fails. Otherwise, we order the rules
topologically by $\preceq_R$ and evaluate the expressions starting from the
minimal elements.

\begin{example}
It is at this point that the cyclic dependence already remarked after
\exampleref{ex:rewrite_despite} will be discovered. We have:

\noindent
\texttt{maxSpCarWorkday'Orig}, \texttt{maxSpCarHighway} $\preceq_R$ \texttt{maxSpCarWorkday}\\
\texttt{maxSpCarHighway'Orig}, \texttt{maxSpSportsCar} $\preceq_R$ \texttt{maxSpCarHighway}\\
\texttt{maxSpSportsCar'Orig}, \texttt{maxSpCarWorkday} $\preceq_R$  \texttt{maxSpSportsCar}\\
\noindent
which cannot be totally ordered.

Let us fix the problem by changing the heading of rule
\texttt{maxSpCarHighway} from \texttt{despite} to \texttt{subjectTo}:
\begin{lstlisting}
rule <maxSpCarHighway>
  {restrict: {subjectTo: maxSpCarWorkday}}
\end{lstlisting}

After rerunning \emph{despiteElim} and \emph{subjectToElim}, we can now order
the rules:

% \begin{lstlisting}
% rule <maxSpCarWorkday>
% rule <maxSpCarHighway>
%   {restrict: {subjectTo: maxSpCarWorkday, maxSpSportsCar}}
% rule <maxSpSportsCar>
%   {restrict: {subjectTo: maxSpCarWorkday}}
% \end{lstlisting}

\noindent
\{ \texttt{maxSpSportsCar'Orig}
\texttt{maxSpCarHighway'Orig},
\texttt{maxSpCarWorkday} \} $\preceq_R$
\texttt{maxSpSportsCar} $\preceq_R$
\texttt{maxSpCarHighway}\\
and will use this order for rule elaboration.
\end{example}


% ......................................................................
\subsubsection{Restriction via Preconditions}\label{sec:restr_precond}

Here, we propose one possible implementation of the rule transformer
\texttt{restrictSubjectTo} introduced in \secref{sec:preprocessing} that takes
a rule $r_1$ and a list of rules $[r_2 \dots r_n]$ and produces a new rule, by
adding the negation of the preconditions of $[r_2 \dots r_n]$ to $r_1$. More
formally:

\begin{itemize}
\item $\mathtt{restrictSubjectTo}\; r_1\; [] = r_1$
\item $\mathtt{restrictSubjectTo}\; r_1\; (r' \uplus rs) =$\\
  $\mathtt{restrictSubjectTo}\; (r_1(precond := precond(r_1) \AND \NOT precond(r')))\; rs$
\end{itemize}
where $precond(r)$ selects the precondition of rule $r$ and $r(precond:=p)$
updates the precondition of rule $r$ with $p$.

There is one proviso to the application of \texttt{restrictSubjectTo}: the
rules have to have the same \emph{parameter interface}: the number and types
of the parameters in the rules' \texttt{for} clause have to be the same.
Rules with different parameter interfaces can be adapted via the
\texttt{remap} rule transformer.\remms{Promise} The rule 

\begin{lstlisting}[frame=none,mathescape=true]
rule <r> for $x_1$:$T_1$ $\dots$ $x_n$:$T_n$ if Pre($x_1, \dots, x_n$) then Post($x_1, \dots, x_n$)
\end{lstlisting}
is remapped with 
\begin{lstlisting}[frame=none,mathescape=true]
remap r [$y_1: S_1, \dots, y_m: S_m$] [$x_1 := e_1, \dots, x_n := e_n$]
\end{lstlisting}
to the rule
\begin{lstlisting}[frame=none,mathescape=true]
rule <r> for $y_1$: $S_1$ $\dots$ $y_m$: $S_m$ if Pre($e_1, \dots, e_n$) then Post($e_1, \dots, e_n$)
\end{lstlisting}
Here, $e_1, \dots, e_n$ are expressions that have to be well-typed with types $E_1, \dots, E_n$ in
context $y_1: S_1, \dots, y_m: S_m$ (which means in particular that they may
contain the variables $y_i$) with $E_i \preceq T_i$ (with the consequence that
the pre- and post-conditions of the new rule remain well-typed). 


\begin{example}\mbox{}\\
We come back to the running example. When processing the rules in the order of
$\preceq_R$, rule \texttt{maxSpSportsCar}, defined by
\texttt{apply: \{restrictSubjectTo maxSpSportsCar'Orig maxSpCarWorkday\}},
becomes:
\begin{lstlisting}
rule <maxSpSportsCar>
   for v: Vehicle, d: Day, r: Road
   if isSportsCar v && isHighway r &&
      not (isCar v && isWorkday d)
   then maxSp v d r 320
 \end{lstlisting}

 We can now state \texttt{maxSpCarHighway}, which has been defined by
 \texttt{apply: \{restrictSubjectTo maxSpCarHighway'Orig maxSpSportsCar\}}, as:

 \begin{lstlisting}
rule <maxSpCarHighway>
   for v: Vehicle, d: Day, r: Road
   if isCar v && isHighway r &&
      not (isSportsCar v && isHighway r &&
           not (isCar v && isWorkday d))
   then maxSp v d r 130
\end{lstlisting}
\end{example}

One downside of the approach of adding negated preconditions is that the
preconditions of rules can become very complex. This effect is mitigated by
the fact that conditions in \texttt{subjectTo} and \texttt{despite} clauses
express specialization or refinement and often permit substantial
simplifications. Thus, the precondition of \texttt{maxSpSportsCar} simplifies
to \texttt{isSportsCar v \&\& isHighway r \&\& isWorkday d} and the
precondition of \texttt{maxSpCarHighway} to
\texttt{isCar v \&\& isHighway r \&\& not (isSportsCar v \&\& isWorkday d)}.


% ......................................................................
\subsubsection{Restriction via Derivability}\label{sec:restr_deriv}

We now give an alternative reading of \texttt{restrictSubjectTo}. To
illustrate the point, let us take a look at a simple propositional example.

\begin{example}\label{ex:small_propositional} Take the definitions:
\begin{lstlisting}
rule <r1> if B1 then C1
rule <r2> {subjectTo: r1} if B2 then C2
\end{lstlisting}
\end{example}

Instead of saying: \texttt{r2} corresponds to
\texttt{\blue{if} B2 \&\& not B1 \blue{then} C2} 
as in \secref{sec:restr_precond}, we would now read it as
``if the conclusion of \texttt{r1} cannot be derived'', 
which could be written as
\texttt{\blue{if} B2 \&\& not C1 \blue{then} C2}.
The two main problems with this naive approach are the following:
\begin{itemize}
\item As mentioned in \secref{sec:intro_rule_modifiers}, a \emph{subject to}
  restriction is often applied to rules with contradicting conclusions, so in
  the case that \texttt{C1} is \texttt{not C2}, the generated rule would be a
  tautology.
\item In case of the presence of a third rule
\begin{lstlisting}[frame=none]
rule <r3> if B3 then C1
\end{lstlisting}
a derivation of \texttt{C1} from \texttt{B3} would also block the application
of \texttt{r2}, and \texttt{subjectTo: r1} and \texttt{subjectTo: r1, r3}
would be indistinguishable.
\end{itemize}

We now sketch a solution for rule sets whose conclusion is always an atom (and
not a more complex formula).

\begin{enumerate}
\item In a preprocessing stage, all rules are transformed as follows:
  \begin{enumerate}
  \item We assume the existence of a class \texttt{Rulename}, which we will
    take to be \texttt{String} in the following.
  \item All the predicates $p$
    occurring in the conclusions of rules (called \emph{transformable
      predicates}) are converted into predicates $p^+$ with one additional
    argument of type \texttt{Rulename}. In the
    example, \texttt{C1$^+$: Rulename -> Boolean} and similarly for \texttt{C2}.
  \item The transformable predicates $p$ in conclusions of rules receive one
    more argument, which is the name \emph{rn} of the rule: $p$ is transformed
    into $p^+\; rn$. The informal reading is ``the predicate is derivable with
    rule \emph{rn}''.
  \item All transformable predicates in the preconditions of the rules receive
    one more argument, which is a universally quantified variable of type
    \texttt{Rulename} bound in the \texttt{for}-list of the rule.
  \end{enumerate}
\item In the main processing stage, \texttt{restrictSubjectTo} in the rule
  annotations generates rules according to:
  \begin{itemize}
\item $\mathtt{restrictSubjectTo}\; r_1\; [] = r_1$
\item $\mathtt{restrictSubjectTo}\; r_1\; (r' \uplus rs) =$\\
  $\mathtt{restrictSubjectTo}\; (r_1(precond := precond(r_1) \AND \NOT postcond(r')))\; rs$
  Thus, the essential difference \wrt{} the definition of
  \secref{sec:restr_precond} is that we add the negated postcondition.
\end{itemize}
\end{enumerate}

\begin{example} The rules of \exampleref{ex:small_propositional} are now
  transformed to:
\begin{lstlisting}[mathescape=true]
rule <r1> for rn: Rulename if B1$^+$ rn then C1$^+$ r1
rule <r2> for rn: Rulename if B2$^+$ rn and not C1$^+$ r1 then C2$^+$ r2
\end{lstlisting}
The derivability of another instance of \texttt{C1}, such as \texttt{C1$^+$ r3},
would not inhibit the application of \texttt{r2} any more.
\end{example}


\begin{example} The two rules of the running example become, after resolution
  of the \texttt{restrictSubjectTo} clauses:
\begin{lstlisting}[mathescape=true]
rule <maxSpSportsCar>
   for v: Vehicle, d: Day, r: Road
   if isSportsCar v && isHighway r &&
      not maxSp$^+$ maxSpCarWorkday v d r 90
   then maxSp v d r 320
rule <maxSpCarHighway>
   for v: Vehicle, d: Day, r: Road
   if isCar v && isHighway r &&
      not maxSp$^+$ maxSpCarWorkday v d r 90 &&
      not maxSp$^+$ maxSpSportsCar v d r 320
   then maxSp v d r 130
\end{lstlisting}
\end{example}

% ----------------------------------------------------------------------
\subsection{Rule Inversion}\label{sec:rule_inversion}

The purpose of this section is to derive formulas that, for a given rule set,
simulate negation as failure, but are coded in a classical first-order logic,
do not require a dedicated proof engine (such as Prolog) and can be checked
with a SAT or SMT solver. The net effect is similar to the completion
introduced by Clark \cite{clark_NegAsFailure_1978}; however, the justification
is not operational as in \cite{clark_NegAsFailure_1978}, but takes 
inductive closure as a point of departure. Apart from that, our technique
applies to a considerably wider class of formulas.

In the following, we assume that our rules have an atomic predicate $P$ as
conclusion, whereas the precondition $Pre$ can be an arbitrarily complex
formula.  We furthermore assume that rules are in \emph{normalized form}: $P$
may only be applied to $n$ distinct variables $x_1, \dots, x_n$, where $n$ is
the arity of $P$, and the rule quantifies over exactly these variables.
For notational simplicity, we write normalized rules in logical format,
ignoring types:
$\forall x_1, \dots, x_n. Pre(x_1, \dots x_n) \IMPL Post(x_1, \dots, x_n)$.

Every rule can be written in normalized form, by applying the following
algorithm:
\begin{itemize}
\item Remove expressions or duplicate variables in the conclusion, by using
  the equivalences $P(\dots e \dots) = (\forall x. x = e \IMPL P(\dots x
  \dots))$ for a fresh variable x, and similarly $P(\dots y \dots y \dots) =
  (\forall x. x = y   \IMPL P(\dots x \dots y \dots))$.
\item Remove variables from the universal quantifier prefix if they do not
  occur in the conclusion, by using the equivalence
  $(\forall x. Pre(\dots x \dots) \IMPL P) = (\exists x. Pre(\dots x \dots))
  \IMPL P$.
\end{itemize}

For any rule set $R$ and any predicate $P$, we can form the set of $P$-rules
$\{\forall x_1, \dots, x_n. Pre_1(x_1, \dots x_n) \IMPL P(x_1, \dots, x_n),
\dots, \forall x_1, \dots, x_n. Pre_k(x_1, \dots x_n)$ $\IMPL P(x_1, \dots,
x_n)\}$ as the subset of $R$ containing all rules having $P$ as
post-condition. 

The inductive closure of a set of $P$-rules is the predicate $P^*$ defined by
the second-order formula
\begin{align*}
  P^*(x_1, \dots, x_n) = \forall P.\;  & (Pre_1(x_1, \dots x_n) \IMPL P(x_1, \dots, x_n)) \IMPL \dots \\
                         & (Pre_k(x_1, \dots x_n) \IMPL P(x_1, \dots, x_n)) \IMPL\\
                         & P(x_1, \dots, x_n)
\end{align*}

$P^*$ can be understood as the least predicate satisfying the set of $P$-rules
and is the predicate that represents ``all that is known about $P$ and
assuming nothing else about $P$ is true'', and corresponds to the notion of
exhaustiveness prevalent in law texts. It can also be understood as the static
equivalent of the operational concept of negation as failure for predicate $P$.

As an illustration, let us note that in case the $P$-rule set is empty, \ie there
are no rules establishing $P$, we have $P^*(x_1, \dots, x_n) = \forall
P.\;  P(x_1, \dots, x_n) = \bot$.

Obviously, a second-order formula such as the definition of $P^*$ is unwieldy
in fully automated theorem proving. We derive one consequence:

\begin{lemma}
$P^*(x_1, \dots, x_n) \IMPL Pre_1(x_1, \dots x_n) \OR \dots \OR Pre_k(x_1, \dots x_n)$
\end{lemma}
\begin{proof}
Expand the definition of $P^*$ and instantiate the universal variable $P$ with
$\lambda x_1 \dots x_n. Pre_1(x_1, \dots x_n) \OR \dots \OR Pre_k(x_1, \dots x_n)$.
\end{proof}
As a consequence of the Löwenheim–Skolem theorem, there is no first-order
equivalent of $P^*$: a formula of the form $P^*$ can characterize the natural
numbers up to isomorphism, but no first-order formula can. In the absence of
such a first-order equivalent, we define the formula
\[
\forall x_1, \dots, x_n.\;  P(x_1, \dots, x_n) \IMPL Pre_1(x_1, \dots x_n) \OR \dots \OR Pre_k(x_1, \dots x_n)
\]
called the \emph{inversion formula of  $P$}, as an approximation of the
effect of $P^*$.

Inversion formulas can be automatically derived and added to the rule set in
L4 proofs; they turn out to be essential for consistency properties. For
example, the functionality of \texttt{maxSp} stated in \figref{fig:assertions}
is not provable without the inversion formula of \texttt{maxSp}.

To avoid misunderstandings, we should emphasize that this approach is entirely
based on a classical monotonic logic, in spite of non-monotonic
effects. Adding a new $P$-rule may invalidate previously provable facts, but
this is only so because the new rule alters the inversion formula of $P$.




% ----------------------------------------------------------------------
\subsection{Answer Set Programming}\label{sec:answer_set_programming}

\remms[inline]{section probably does not have an adequate name}

% ----------------------------------------------------------------------
\subsection{Comparison}\label{sec:comparison}





%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
