\documentclass[runningheads]{llncs}

\input{settings}
\input{defs}

% Possilby remove for final version
%\pagestyle{plain}

\begin{document}
%\title{Computer-Supported Defeasible Reasoning in Law}
%\title{Computer-Supported Defeasible Reasoning in Legal Texts}
\title{Overview of the CCLAW project}

\author{CCLAW team
  }
\institute{Singapore Management University}
\maketitle

% \begin{abstract}
% \input{abstract}
% \end{abstract}

\keywords{
  Knowledge representation and reasoning,
  Argumentation and law,
  Computational Law,
  Defeasible reasoning
}

%----------------------------------------------------------------------

\section{Context}\label{sec:context}

Computerized support for law has a long tradition going back at least to the
1970. While the participants of the present workshop presumably share an
interest in the topic, there are different methods for approaching it. The
purpose of this paper is to expose the main tenets of our work at the Centre
for Computational Law\footnote{\url{https://cclaw.smu.edu.sg/}} at Singapore
Management University. We describe some basic principles and requirements in
this section, and then give an overview of current work
(\secref{sec:current_work}) and work still to be accomplished
(\secref{sec:outlook}).

The first principle is that law is construed as a set of rules (in a large
sense), as opposed to a set of cases, and that what is admissible according to
law can be determined by deductive means, contrary to case-based reasoning
supported by similarity metrics. The second principle is that law is meant to
describe a set of admissible behaviours, and not a single behaviour, so our
framework is primarily declarative and not directly executable, in contrast to
\emph{smart contract} languages many of which are in fact programming
languages. The promise is to have a language that combines formal rigour with
user-friendliness and accessibility to legal practitioners without specific
training in computer science, in particular through natural-language
interaction. This has led us to conceive our own domain-specific language
(DSL) called L4, instead of adopting an existing general-purpose
language. Finally, the language aims at supporting a variety of tasks relevant
in a law context, ranging from legal drafting and reasoning \emph{about} rules
(such as consistency checking of a rule set) through compliance checking of
business processes to reasoning \emph{with} rules in order to derive
consequences of an individual usage scenario.

Altogether, L4 can best be described as a multi-faceted, extensible language
platform rather than as a single language with a fixed semantics.

\section{Current Work}\label{sec:current_work}

\subsection{Language}\label{sec:language}

We will now highlight some aspects and usage patterns of the L4
platform. Conceptually, a central notion is the \emph{rule} which describes
admissible behaviour. We first describe static rules and their possible uses,
then dynamic rules for time-dependent processes.

In their simplest form, \textbf{rules} are \emph{if-then} statements, where both the
pre- and post-conditions are expressions. By means of an example, here is an
excerpt of the Professional Conduct Rules of the Singaporean Legal Profession
Act\footnote{\url{https://sso.agc.gov.sg/SL/LPA1966-S706-2015}} stating under
which conditions a legal practitioner may accept an appointment:

\begin{lstlisting}
rule <r1a>
for lpr: LegalPractitioner, app: Appointment
if (exists bsn : Business. AssociatedWithAppB app bsn && IncompatibleDignity bsn)
then MustNotAcceptApp lpr app
\end{lstlisting}

The \textbf{expression} language is a simply-typed lambda calculus. As seen in
the example, there is no \emph{a priori} restriction to using complex
(quantified, higher-order, \dots) expressions in rules, as long as they are
well typed, but further processing steps may be restricted to fragments of the
rule language or require previous (automated) transformations. With this, the
above rule can be used without further ado in a Prolog-like context (see
below).

In a legal context, the questions of deontics and of default reasoning are
inevitable. L4 supports neither of them in the core language, \ie{} in the logic, but
provides mechanisms for expressing them by other means. The decision against a
full-fledged \emph{deontic logic} is motivated by the fact that in spite of a
decade-long debate, there is no consensus on how to avoid paradoxes of
classical deontic logics; the combination with other modalities is not clear
(in particular: possibility and necessity arising in temporal reasoning, which
we do support); and there is no native support in expressive reasoning
tools. Instead, in static rules as the above, obligations can be expressed
with dedicated predicates, such as \texttt{MustNotAcceptApp} above, and it
becomes possible to reason about consistency and completeness of legal
requirements, which is barely possible if these notions are built into the
logic (also see \secref{sec:services}). In dynamic, state-based system
specifications, individual states can be flagged as breach states, again
allowing for a fine-grained reasoning about traces that avoid, reach or repair
these breaches.

Neither is there native support for \emph{default reasoning}. Rules can be
mapped to reasoning services that are based on non-monotonic logics, see
\secref{sec:services}. As an extra-logical feature, a rule can be marked with
modifiers like \emph{subject to} or \emph{despite} (another rule), which
implicitly prioritizes rules and provides a reasoning pattern that, in absence
of knowledge to the contrary, a given rule is applicable. In a similar spirit,
negation by failure can be simulated by rule inversion. It is worth noting
that these mechanisms do not rely on an extension of the logic, but on
compilation of rules.

\subsection{Services}\label{sec:services}

We provide \textbf{reasoning services} by translating rules to other languages or
solvers. According to the principle of usability for the target audience, we
aim at a push-button technology, which precludes the use of (say) interactive
proof assistants. We provide the following, mostly complementary, services:

\begin{itemize}
\item \textbf{SMT solvers:} Their purpose is to permit reasoning about a rule
  set and thus to explore conditions of consistency, completeness or other
  user-defined criteria. In the above example of professional conduct rules,
  one might be interested in knowing whether
  \texttt{MustNotAcceptApp} and \texttt{MayAcceptApp} are complete and
  mutually exclusive. It has to be noted that the law text explicitly defines
  both predicates, so one cannot simply be assumed to be the negation of the
  other. For verification, users can write down a proof obligation (a formula). The L4
  tool set translates this formula and the rules (eventually transformed, as
  mentioned above) to expressions in the the SMTLIB format, sends them to a
  SMT solver and retrieves the result.  Other consistency checks (such as a search for
  overlapping rules) could be done automatically, but has not yet been
  implemented. SMT solvers are in principle also capable of reasoning about
  specific scenarios, but the following methods are more appropriate.
\item \textbf{Answer Set Programming:}
\item \textbf{``Expert system'':} By this, we understand a rule based
  production system where rules are applied to data stored in a fact base to
  derive new data, and this until a fixed point is reached. We currently
  experiment with the systems Drools\footnote{\url{https://www.drools.org}},
  Clara\footnote{\url{http://www.clara-rules.org/}} and
  O'Doyle\footnote{\url{https://github.com/oakes/odoyle-rules}}. As compared
  to primarily logical emthods, the strength
  of these engines lies in their capability to process larger quantities of
  data.
\end{itemize}
Our current work concentrates on providing readable justifications for traces
of rule applications or models produced by solvers.



\begin{itemize}
\item Natural language processing
\item Visualization
\end{itemize}

\subsection{Tool support}\label{sec:tool_support}


The reader should be aware that most of what has been described is still work
in progress. Work on the above is ongoing, with an open-source development in
Haskell available on CCLAW's
github\footnote{\url{https://github.com/smucclaw}}, with an integration into
Visual Studio Code that features syntax highlighting, on-the fly type checking
and code completion \remms{too much of a promise?}

\remms[inline]{Further remarks}
\begin{itemize}
\item whole language does not have a fixed semantics, but strands of the
  language do have.
\end{itemize}

\section{Outlook on Future Work}\label{sec:outlook}

\remms[inline]{Maybe scrap the whole section}


\paragraph{Acknowledgements.}
This research is supported by the National Research Foundation (NRF),
Singapore, under its Industry Alignment Fund â€“- Pre-Positioning Programme, as
the Research Programme in Computational Law. Any opinions, findings and
conclusions or recommendations expressed in this material are those of the
authors and do not reflect the views of National Research Foundation,
Singapore.

%----------------------------------------------------------------------
% \bibliographystyle{splncs04}
% \bibliography{main}
%% \bibliographystyle{abbrv}


%----------------------------------------------------------------------

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% coding: utf-8
%%% End: 