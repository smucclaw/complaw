\documentclass[sigconf]{acmart}

%----------------------------------------------------------------------
% ACM Sigconf specifics

\AtBeginDocument{%
  \providecommand\BibTeX{{%
      Bib\TeX}}}

\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}

\acmConference[PPDP 2022]{Principles and Practice of Declarative Programming }{June 03--05,
  2018}{Woodstock, NY}
\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}
\citestyle{acmauthoryear}

%----------------------------------------------------------------------
% Input libraries and definitions

\input{settings}
\input{defs}

%----------------------------------------------------------------------
% Preamble

\begin{document}

\title{User Guided Abductive Proof Generation for Answer Set Programming
  Queries}

\author{Avishkar Mahajan}
\orcid{0000-0002-9925-1533}
\author{Meng Weng Wong}
\orcid{0000-0003-0419-9443}
\affiliation{%
  \institution{Singapore Management University}
  \country{Singapore}
}

\author{Martin Strecker}
\orcid{0000-0001-9953-9871}
\affiliation{%
  \institution{University of Toulouse}
  \country{France}
}

\input{abstract}

\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10003752.10003790.10003795</concept_id>
       <concept_desc>Theory of computation~Constraint and logic programming</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003790.10003794</concept_id>
       <concept_desc>Theory of computation~Automated reasoning</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10010405.10010455.10010458</concept_id>
       <concept_desc>Applied computing~Law</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Constraint and logic programming}
\ccsdesc[500]{Theory of computation~Automated reasoning}
\ccsdesc[500]{Applied computing~Law}

\maketitle

%----------------------------------------------------------------------
% Main part

\section{Introduction}
The goal of this paper is to describe a method to automatically genenrate a space of abducibles, that will allow the creation of a fact set that results in the entailment of a given query with respect to a given ASP rule set.

A novel feature of the method is that depth control for proof search is done
in a purely declarative way as part of the proof search encoding
itself. Furthermore, adding facts to the program automatically triggers a kind
of controlled variable substitution where skolem\remms{Capitalize?} terms or
other 'place-holder' terms occurring in abducibles are replaced away so that
the resulting proof is simplified, without any need for an explicit
representation of equality between terms. We present two main sets of
proof-search encodings. One is guaranteed to only produce finite answer sets,
but which does not support complete variable substitution in abducibles. The
other encoding may produce infinite answer sets in the presence of skolem
functions but supports complete variable substitution and still only produces
finite answer sets if there are no skolem terms involved. Next we present an
encoding which generates a set of directed edges representing a justification
graph of any desired depth. \remms{Set off the related work section from
  general intro}The novel encodings for variable substitution and depth
control set this work apart from other attempts like [Schuller ref, Petr
Homola ref] to realize abduction in a Clingo-like bottom-up reasoner. Unlike
sCASP our method keeps the justification production and proof search separate
from each other which allows the user to have greater control on the
justification produced without affecting the proof search
procedure. Furthermore, in general, abduction problems where the input rules
involve function symbols often either lead to infinite grounding or infinite
backward proof search and problems that are intractable with a top-down
reasoning mechanism often yield to a bottom-up reasoner and vice
versa.\remms{Sounds as if reasoning style does not matter} Lastly, as
mentioned in the abstract, there may be use cases where one wants to know all
the resulting consequences of an abductive solution to a query with respect to
a rule-set. Informally one can relate this to the problem of
\emph{bi-abduction} which has been explored in separation logic [Bi-ab
ref]. Hence our work can be regarded as addressing the problem of
\emph{bi-abduction} but in an ASP setting. (However we shall not dwell on this
connection any further, instead focus only on the abductive reasoning
process). Therefore an abductive reasoner based on a solver like Clingo can
complement the abilities of goal directed reasoners like sCASP, CIFF etc.

The rest of the paper is organised as follows. Section~\ref{sec:abductive_proof} provides some further background and motivation for the subject of the paper and also describes the problem being tackled more formally. Section~\ref{sec:derived_asp} presents 3 core sets of meta-rules that facilitate the abductive proof generation process. Section~\ref{sec:sample_problem} describes some formal results about the generated proof trees. Section~\ref{sec:proof_finiteness} discusses applications and comparisons to other work and Section~\ref{sec:conclusion} concludes.

Test citations:\remms{Remove} \cite{lim22:_autom_defeas_reason_law,mahajan22:_overv_cclaw_l4}


\section{Abductive Proof Generation Task}\label{sec:abductive_proof}

\subsection{Formal Setup}
Given a source ASP rule set $R$, let the tuple $\langle R,q,U,C,N \rangle$ denote the tuple consisting of the source ASP rules $R$, a ground positive or negative atom $q$.\remms{say what intuitively $q$, $U$ etc. mean} The set $U$ consists of 2 subsets. First we have a set of user-inputed facts, where each fact $f$ is denoted by the atom $user\_input(pos,f)$.\remms{what is $user\_input$/ $pos$?} Next in $U$ we have a set of integrity constraints that constrain which atoms may be abduced. For example the constraint $:-abducedFact(p(X)).$ means no instantiation of the predicate $p$ may be abduced. The integrity constraints can also prevent only specific instances of predicates from being abduced. For example instead of the constraint above we may have the constraint $:-abducedFact(p(john)).$.  $C$ denotes a set of ASP constraint which constrain which atoms may or may not appear in the complete model that results from the rules and abducibles. Finally we have the non-negative integer $N$. This acts as the depth control parameter for abductive proof search. We shall exemplify all these definitions with some examples later on. Then the key task is to find a set of facts $F$, such that:

\begin{enumerate}
    \item If $q$ is a positive atom, it is in some answer set $\mathcal{A}$ of $F\cup R\cup C$. If $q$ is a NAF atom, then there exists an answer set $\mathcal{A}$ of $F\cup R\cup C$ such that $q$ is $not$ in $\mathcal{A}$.
    \item $F$ contains all the positive facts from $U$ and $F$ does not violate any of the integrity constraints in $U$ Ie. $F$ does not contain abducibles that are specifically disallowed by the constraints on abducibles in $U$.
    \item $F$ does not have any atoms whose depth level is greater than $N$.
\end{enumerate}
We say $F$ is a solution of the abductive proof generation task $\langle R,q,U,C,N \rangle$

\subsection{Source ASP program}

When considering any abductive proof generation task we make the following assumptions on the input ASP rule set $R$. We assume that each source ASP rule has exactly the following form:
\begin{lstlisting}[frame=none]
pre_con_1(V1),pre_con_2(V2),...,pre_con(Vk),
    not pre_con(Vk+1),...,not pre_con_n(Vn) -> post_con(V).
\end{lstlisting}
We further make the folllowing assumptions:

\begin{enumerate}
    \item Each pre-condition $pre\_con_{i}(V_{i})$ is atomic and so is the post-condition $post\_con(V)$.
    \item The $not$ in front of the pre-conditions denotes \textit{negation as failure} interpreted under the \textit{stable model semantics}
    \item $V_{i}$ is the set of variables occuring in the $i^{th}$ pre-condition which is either $pre\_con_{i}(V_{i})$ or $not$ $pre\_con_{i}(V_{i})$ and $V$ is the set of variables occuring in the post condition $post\_con(V)$. We assume that $V\subseteq V_{1}\cup V_{2}\cup ... \cup V_{n}$.
    \item Each variable occurring in the post condition is universally quantified over, and each variable that occurs in some pre-condition but not the post condition is existentially quantified. In particular together with (3), this means that there are no existentially quantified variables in rule post-conditions.
    \item Each variable that occurs in a negation-as-failure pre-condition also occurs in some positive pre-condition.
    \item Each input rule of the form above is assigned some unique rule id.
\end{enumerate}

We further assume that given any integrity constraint $c$ in $C$, every variable in a negation-as-failure atom in $c$ also occurs in some positive atom in $c$. We will now define the depth level of an atom with respect to a given input source ASP rule set $R$ and query $q$.

\subsection{Depth level of an atom}
We define a map $\phi$ that maps an atom to a set of non-negative integers. We
will describe this map rather informally. For the query $q$, $0\in
\phi(q)$. Now the rest of the definition is recursive. Given an atom $a$, the
non-negative integer $n$, $n\in \phi(a)$ if and only if there exists a rule
$r$ in $R$ such that there is a substitution $\theta$ of the variables in $r$
such that there exists some precondition (negated or positive) $p$ of $r$ such
that that $\theta$ applied to $p$ gives $a$ and $\theta$ applied to the post
condition of $r$ gives some atom $a'$ where $n-1$ $\in$ $\phi(a')$.

Given an atom $a$ let $\phi_{min}(a)$ be $-1$ if the set $\phi(a)$ is empty
and let $\phi_{min}(a)$ be the minimum member of the set $\phi(a)$
otherwise. Then $\phi_{min}(a)$ is defined to be the $depth$ $level$ of $a$
with respect to the rule set $R$ and query $q$.

\section{Derived ASP Programs}\label{sec:derived_asp}
Before we give the details of the main sets of rule translations that allow
abductive reasoning and justification generation, here is a simple example to
illustrate some key ideas and what the desired output for an abductive problem
is. Consider the rule set $R$ given by the 3 rules
\begin{lstlisting}[numbers=left,frame=none]
p(X,Y):-q(X,Y),r(X),s(Y).
p(X,Y):-g(X,Y).
d(X,Y):-g(X,Y).
\end{lstlisting}
Now let $q$ be $p(john,james)$, let $U$ consist of the user provided fact
$r(john)$ and let $U$ also include the constraint on abducibles $:-p(X,Y)$
meaning that no instance of the predicate $p$ may be abduced. Next let the set
$C$ contain the single constraint $:-d(X,Y)$ meaning that we require a stable
model of the user given facts, the abducibles, and the rules, which does not
contain any instance of the predicate $d$, finally let $N = 2$. Then for this
problem the minimal abductive solution can be represented by
\textit{abducedFact(q(john,james)), abducedFact(s(james))}, which is what we
want to get out of our encoding. Intuitively, the way we will solve this
abductive reasoning problem is by first encoding the input rules such as the
ones above directly as they are. Then we will have a representation which
corresponds to 'reversing' the rules, \ie we go from post-conditions to
pre-conditions.\remms{Looks like backward reasoning} These 'reveresed' rules
generate a maximal space of abducibles which then feed into the direct rule
translation. Finally we will have integrity constraints that ensure that the
atom which we want to be true (represented by $q$) is indeed entailed by the
abductive solution. An adapted version of this 'reversed rule' representation
also enables us to generate a set of directed edges corresponding to a
justification graph. The technical challenge in this process comes from
finding a way to control the depth of abduction space generation. The other
key challenge is dealing with rules that may have existential variables in
pre-conditions or when rules may not have existential quantifier but the goal
represented by $q$ is un-ground or existential in nature. So for example it
maybe the case that the goal is not $p(john,james)$ but any arbitrary instance
of the predicate $p$.

\subsection{Core rule translations}
\remms[inline]{One should first situate the context (maybe already in the
  intro) and say that there are different approaches, such as rule
  transformations (as in the magic set approach) or embeddings (which are done
  here). }

\subsubsection{Core Forward Reasoning}
Given an input rule 
\begin{lstlisting}[frame=none]
pre_con_1(V1),pre_con_2(V2),...,pre_con(Vk),
   not pre_con(Vk+1),...,not pre_con_n(Vn) -> post_con(V).
\end{lstlisting}
obeying all the properties as above we write the following rule in our ASP program: 
\begin{lstlisting}[frame=none]
holds(post_con(V)):-holds(pre_con(V1)),...,holds(pre_con(Vk)), not holds(pre_con(Vk+1)), ..., not holds(pre_con(Vn)). 
\end{lstlisting}

We repeat this for each source ASP rule. For each constraint in $C$, we simply
enclose each atom in the constraint inside the $holds$ predicate. For example
if $C$ contains the constraint $:-b(X,Y).$, (meaning that we require an
abductive solution such that the there exists a stable model of the abduced
facts, rules and user provided facts, which contains no instantiations of the
predicate $b$), we encode that constraint as: 
\begin{lstlisting}[frame=none]
:-holds(b(X,Y)).
\end{lstlisting}

\subsubsection{Generating Abducibles}

For this next set of meta-rules we will first need a way to assign the
appropriate skolem terms to existential variables in pre-conditions. First
given some rule in our rule set, say rule $r_{j}$. We now fix some order
$O_{r_{j}}$ on the variables occuring in the combined set of variables from
the post and pre-conditions of the rule $r_{j}$. Now we will describe a
skolemization map that assigns an existential variable in a pre-condition of
$r_{j}$ to a skolem term. Firstly, let the rule $r_{j}$ carry unique integer
id $t$. Let $v$ be a variable that occurs in some rule precondition but not
the post condition. Then under this skolemization map, the variable $v$ gets
mapped to
\begin{lstlisting}[frame=none]
skolemFn_t_v_(V)    
\end{lstlisting}
where $V$ denotes the variables in the post-condition occuring in the order inherited from $O_{r_{j}}$. For example consider the rule $r$: 
\begin{lstlisting}[frame=none]
p(Y,X):- q(X),r(X,Y),s(Z).    
\end{lstlisting} 
Assume that this rule carries integer id $1$. Let $O_{r}$ be $[X,Y,Z]$. Then
the variable $Z$ gets mapped to the skolem term $skolemFn\_1\_Z(X,Y)$.

\subsubsection{AG1}
Given an input ASP rule $r$ in $R$
\begin{lstlisting}[frame=none]
pre_con_1(V1),pre_con_2(V2),...,pre_con(Vk),not pre_con(Vk+1),...,not pre_con_n(Vn) -> post_con(V).
\end{lstlisting}
our first set of abducible generation/proof search rules $AG1$ is given by the following. (In the rest of the paper we will use the terms abducible generation rules and proof search rules interchangeably) 
\begin{lstlisting}[frame=none]
create_subs(sub_Inst_t((V_sk),N+1):-query(post_con(V),N),N<M-1.
\end{lstlisting}
Here $V_{sk}$, denotes the ordered list $O_{r}$ but with existential variables replaced by their skolem term counter parts. Here $t$ is the integer id for the rule.
Next we have the following rules:
\begin{lstlisting}[frame=none]
explains(pre_con_1(V1),post_con(V),N):-create_subs(sub_Inst_t((V),N).
explains(pre_con_2(V2),post_con(V),N):-create_subs(sub_Inst_t((V),N).
% etc
explains(pre_con_n(Vn),post_con(V),N):-create_subs(sub_Inst_t((V),N).
\end{lstlisting}
Here $V$ denotes the ordered list $O_{r}$.

\subsubsection{AG2}
\remms{What does AG1, 2 etc refer to?}  Now we shall construct the second set
of proof search rules $AG2$. Given $O_{r}$ construct $F_{r}$ be adjoining
$FreshVar$ \remms{define} to each entry of $O_{r}$. So for our example above $F_{r}$ becomes
$[FreshVar\_X,$ $FreshVar\_Y,FreshVar\_Z]$. Given a pre-condition $p$
occurring in $r$ $M_{r,p}$ is an ordered list constructed as follows. The
$i_{th}$ element of $M_{r,p}$ is the $i_{th}$ element of $O_{r}$ if the
$i_{th}$ element of $O_{r}$ is a variable which occurs in $p$. Otherwise, the
$i_{th}$ element of $M_{r,p}$ is given by the $i_{th}$ element of $F_{r}$. Now
for each negated or positive precondition $p$ we have the following rule:
\begin{lstlisting}[frame=none]
 create_subs(sub_Inst_t(M_(r,p)),M-1):-create_subs(sub_Inst_t(F_r),N),
                       holds(p),max_ab_lvl(M), N<M.   
\end{lstlisting}
Repeat this for each pre-condition. This is the set of rules $AG2$.
\remms{\texttt{max\_ab\_lvl} should be motivated}

\subsubsection{AG3}
Finally $AG3$ consists of just the single rule:
\begin{lstlisting}[frame=none]
query(X,N):-explains(X,Y,N),max_ab_lvl(M),N<M.
\end{lstlisting}

\subsubsection{Skolem Example}
Let us consider another example.

Consider the source ASP rule:
\begin{verbatim}
a(X):- b(X,Y,Z), not c(X), not d(Y) .    
\end{verbatim}
Say this rule $r$ has rule id $5$. 
Let $O_{r}$ be $[X,Y,Z]$. Here the encoding for the rule $AG1$ is:
\begin{lstlisting}[frame=none]
create_subs(subs_Inst_5(X,skolemFn_5_Y(X),skolemFn_5_Z(X),N+1):-
   query(a(X),N),max_ab_lvl(M),N<M-1.

explains(b(X,Y,Z),a(X),N):-create_subs(subs_Inst_5(X,Y,Z),N).

explains(c(X),a(X),N):-create_subs(subs_Inst_5(X,Y,Z),N).

explains(d(Y),a(X),N):-create_subs(subs_Inst_5(X,Y,Z),N).
\end{lstlisting}
AG2 is given by:

\begin{lstlisting}[frame=none]
create_subs(subs_Inst_5(X,Y,Z),M-1):-
     create_subs(subs_Inst_5(FreshVar_X,FreshVar_Y,FreshVar_Z),N), 
     holds(b(X,Y,Z)),max_ab_lvl(M),N<M.

create_subs(subs_Inst_5(X,FreshVar_Y,FreshVar_Z),M-1):-
create_subs(subs_Inst_5(FreshVar_X,FreshVar_Y,FreshVar_Z),N), holds(c(X)),max_ab_lvl(M),N<M.

create_subs(subs_Inst_5(FreshVar_X,Y,FreshVar_Z),M-1):-
create_subs(subs_Inst_5(FreshVar_X,FreshVar_Y,FreshVar_Z),N), holds(d(Y)),max_ab_lvl(M),N<M.
\end{lstlisting}

\subsubsection{Supporting code for Abduction} 
Given the original problem $\langle R,q,U,C,N\rangle$, set $M=N+1$. Then we have the following: 
\begin{verbatim}
max_ab_lvl(M).
query(Q,0):-generate_proof(Q).
{abducedFact(X)}:-query(X,M).
holds(X):-abducedFact(X).

holds(X):-user_input(pos,X).
\end{verbatim}
For any predicate $p$, say of arity $n$ such that no instance of $p$ may be abduced, we add the constraint.
\begin{verbatim} 
:-abducedFact(p(X1,X2,...,Xn)).
\end{verbatim}
If instead only a specific ground instance of $p$ or a partially ground instance of $p$ should be prevented from being abduced then we simply adapt the above constraint accordingly. For instance if $p$ is a binary predicate and we want that no instance of $p$ where the first argument is $alpha$ should be abduced we have the constraint
\begin{verbatim} 
:-abducedFact(p(alpha,X)).
\end{verbatim}
Next we add the following $weak$ constraint so that in the optimal abductive
solution as few abducibles as possible are used.\remms{what does $[1@1,X]$ mean?}
\begin{verbatim} 
:~abducedFact(X).[1@1,X]
\end{verbatim}

\subsubsection{Specifying the goal}
Here is the code to encode the goal of the abductive reasoning process. If our
goal is ground atom say $p(a1,a2..,an)$ for some predicate $p$ then we
have:\remms{\texttt{-: not goal} needs some explanation.}
\begin{verbatim}
generate_proof(p(a1,a2,...,an)).
goal:-holds(p(a1,a2,..,an)).
:- not goal.
\end{verbatim}
If on the other hand our goal is unground or only partially ground then we have the following. Say our goal is of the form $p(a,X,b,Y,Y)$, which means that $X$,$Y$ are existential variables. Then for the example we have the following:
\begin{verbatim}
generate_proof(p(a,v1,b,v2,v2)).
goal:-holds(p(a,X,b,Y,Y)).
:- not goal.
\end{verbatim}
Here $v1$, $v2$ are fresh constants.

\subsection{Extending abduction generation space for rules without existential variables}

\remms[inline]{Why is it necessary to have a special procedure in this case?
  Isn't this translation exactly what one gets if the list of existential
  variables is empty?}

When we have rules without existential variables, we can construct a larger
space of abducibles without worrying about our ASP programs having infinite
answer sets because there are now no skolem expressions. The encoding $AG1$ is
the same as before but now clearly there will be no skolem terms. The new
version of $AG2$ which we shall call $AG2_{exp}$ now becomes for each rule 
\begin{lstlisting}[frame=none]
create_subs(sub_Inst_t(M_(r,p)),N):-
   create_subs(sub_Inst_t(F_r),N),holds(p),max_ab_lvl(M), N<M.   
\end{lstlisting}

Repeat this for each pre-condition $p$. Then for the post-condition of the rule $p'$, we have:
\begin{lstlisting}[frame=none]
create_subs(sub_Inst_t(M_(r,p')),N):-
   create_subs(sub_Inst_t(F_r),N),holds(p'),max_ab_lvl(M), N<M.   
\end{lstlisting}
 
Here $M_{r,p'}$ is defined exactly the same way as $M_{r,p}$ for some pre-condition $p$. Next, for each rule and for each pre-condition $p$ in the rule we have.
\begin{lstlisting}[frame=none]
create_subs(sub_Inst_t(M_(r,p)),N):-
   create_subs(sub_Inst_t(F_r),N),query(p,N),max_ab_lvl(M), N<M.   
\end{lstlisting}

For the post-condition $p'$ we have:
\begin{lstlisting}[frame=none]
create_subs(sub_Inst_t(M_(r,p')),N):-
   create_subs(sub_Inst_t(F_r),N),query(p',N-1),max_ab_lvl(M),0<N,N<M.   
\end{lstlisting}

This completes the encoding $AG2_{exp}$. The adapted version of $AG3$,
$AG3_{exp}$, is given by adding to $AG3$ one extra rule. So $AG3_{exp}$ is: 
\begin{lstlisting}[frame=none]
query(X,N):-explains(X,Y,N),max_ab_lvl(M),N<M.
query(Y,N-1):-explains(X,Y,N),max_ab_lvl(M),1<N,N<M.
\end{lstlisting}


\subsection{Discussion of Abduction space generation}

\subsubsection{Full term substitution}
We first give an example of the expanded abduction space encoding to explain
the intuition behind various parts of the encoding. Consider the rule set
below that has no existential variables but which has negation as failure and
where the goal is un-ground.
\begin{lstlisting}[frame=none]
relA(X,Y):-relB(X,Y), relD(Y), not relE(Y).
relE(Y):-relD(Y), not relF(Y).
\end{lstlisting}
Let the goal $q$ be $relA(P,R)$, where $P$,$R$ are un-ground existential
variables. Next suppose that the only constraint on abducibles is that no
instantiation of $relA$ can be abduced and further suppose that the set of
user provided facts is initially empty. Finally let $N=4$. Here is the
complete encoding for this problem.

\begin{lstlisting}[numbers=left]
max_ab_lvl(5).
% Encoding the goal
generate_proof(relA(v1,v2)).
query(X,0):-generate_proof(X).
goal:-holds(relA(P,R)).
:- not goal.

% Core rule translation
holds(relA(X,Y)) :- holds(relB(X, Y)),holds(relD(Y)), not holds(relE(Y)).
holds(relE(Y)) :- holds(relD(Y)), not holds(relF(Y)).

% AG1_exp
createSub(subInst_r1(X,Y),N+1) :- query(relA(X,Y),N),max_ab_lvl(M),N<M-1. (* \label{abdInstR1} *)
createSub(subInst_r2(Y),N+1) :- query(relE(Y) ,N),max_ab_lvl(M),N<M-1. (* \label{abdInstR2} *)

explains(relB(X, Y), relA(X,Y) ,N) :- createSub(subInst_r1(X,Y),N). (* \label{abdExplR1start} *)
explains(relD(Y), relA(X,Y) ,N) :- createSub(subInst_r1(X,Y),N).
explains(relE(Y), relA(X,Y) ,N) :- createSub(subInst_r1(X,Y),N). (* \label{abdExplR1end} *)


explains(relD(Y), relE(Y) ,N) :- createSub(subInst_r2(Y),N). (* \label{abdExplR2start} *)
explains(relF(Y), relE(Y) ,N) :- createSub(subInst_r2(Y),N). (* \label{abdExplR2end} *)


% AG2_exp for rule 1

createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), holds(relA(X,Y)).
createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), holds(relB(X,Y)).
createSub(subInst_r1(V_X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), holds(relD(Y)).
createSub(subInst_r1(V_X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), holds(relE(Y)).

createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), query(relA(X,Y),N-1),0<N.
createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), query(relB(X,Y),N).
createSub(subInst_r1(V_X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), query(relD(Y),N).
createSub(subInst_r1(V_X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), query(relE(Y),N).

% AG2_exp for rule 2

createSub(subInst_r2(Y),N) :- createSub(subInst_r2(V_Y),N), holds(relE(Y)).
createSub(subInst_r2(Y),N) :- createSub(subInst_r2(V_Y),N), holds(relD(Y)).
createSub(subInst_r2(Y),N) :- createSub(subInst_r2(V_Y),N), holds(relF(Y)).


createSub(subInst_r2(Y),N) :- createSub(subInst_r2(V_Y),N), query(relE(Y),N-1),0<N.
createSub(subInst_r2(Y),N) :- createSub(subInst_r2(V_Y),N), query(relD(Y),N).
createSub(subInst_r2(Y),N) :- createSub(subInst_r2(V_Y),N), query(relF(Y),N).

% AG3_exp
query(X,N):-explains(X,Y,N),max_ab_lvl(M),N<M.(* \label{abdQuery} *)
query(Y,N-1):-explains(X,Y,N),max_ab_lvl(M),N<M,0<N.(* \label{abdAbdHold} *)

% Supporting code
{abducedFact(X)}:-query(X,N).  (* \label{abdChoice} *)
holds(X):-abducedFact(X).      (* \label{abdHoldsAbduced} *)
holds(X):-user_input(pos,X).   (* \label{abdHoldsUI} *)


:~abducedFact(Y).[1@1,Y]    (* \label{abdAbducedFact} *)
:-abducedFact(relA(X,Y)).

\end{lstlisting}


We will now discuss various parts of the encoding.

As mentioned briefly earlier, the general idea is to recursively generate a
maximal space of abducibles by 'reversing' the rules and then checking via the
'Core rule translation' and encoding of the goal, which abducibles are needed
for entailment of the original query or the 'goal'. More specifically any atom
of the form $query(h,i)$ generates an input rule instantiation where $h$ is
the post-condition or head of that particular rule instantiation. Such rule
instantiations are represented by the $createSub$ atom. In the example above,
this is done via lines \ref{abdInstR1}, \ref{abdInstR2} of the encoding. Line \ref{abdInstR1} corresponds to
instantiations of rule 1 and line \ref{abdInstR2} corresponds to instantiations of rule
2. Then any such $createSub$ atom, generates the appropriate set of $explains$
atoms. This is lines \ref{abdExplR1start}-\ref{abdExplR1end} for rule 1 in the example, and lines \ref{abdExplR2start}, \ref{abdExplR2end} for
rule 2. The first argument of an $explains$ atom is a pre-condition of body
atom corresponding to the rule instantiation given by the $createSub$
atom. The second argument is post-condition or head of the rule
instantiation. We have one such $explains$ atom for each rule
pre-condition. Via line \ref{abdQuery}, the first argument of an $explains$ atom becomes
the first argument of a $query$ atom. This new $query$ atom then recursively
generates more $query$ atoms via the process described. Any $query$ atom
corresponds to a candidate for abduction via the choice rule in line \ref{abdChoice}. Any
fact which is abduced must hold due to line \ref{abdAbdHold}. At this point, before moving
ahead let us first briefly comment upon the integer arguments occuring in the
$explains$, $createSub$ and $query$ atoms.

The integer parameter roughly
represents the depth of an abducible in the proof graph of the original
query. When a $query$ atom carrying the post-condition of a rule generates a
rule instantiation like in line \ref{abdInstR1} for example, the integer argument of the
corresponding $createSub$ atom increases by one. Then an explains $atoms$
derived from the application of a rule like line 16 retains the same integer
argument and so does the corresponding fresh $query$ atom generated from the
application of the rule on line \ref{abdQuery}. Note that a fresh $query$ atom can only be
created from an $explains$ atom if the integer parameter of the $explains$
atom is less than $M$. The use of these integer parameters is very important
when we need skolem functions/terms in our abducible generation encoding due
to having rules with existentially quantified variables in pre-conditions. The
use of these integer parameters allows us to control the depth of the
abducible generating space thus preventing infinite answer sets even in the
presence of skolem functions. We will discuss this more later on. For now let
us turn our attention to some of the other parts of the encoding. The
$AG2_{exp}$ encoding is key to enabling a notion of implicit term substitution
in (minimal) abductive solutions. This set of rules creates new instantiations
of the core input rules based on which other atoms are true. Creating new
instantiations of the core input rules via the $createSub$ atoms, then allows
new abducibles to be added to the generated space of abducibles. Let us
illustrate some of these ideas with an example. Upon running the above ASP
program as the optimal solution given by the solver is: (recall that any
instance of $relA$ will satisfy the $goal$ but no instance of $relA$ itself
can be abduced) 

\begin{lstlisting}[frame=none]
abducedFact(relD(v2)) 
abducedFact(relB(v1,v2)) 
abducedFact(relF(v2))    
\end{lstlisting}
Now if $relB(john,james)$ is added to the set of user provided facts then firstly, due to line \ref{abdHoldsUI} $holds(relB(john,james))$ becomes true. Then we have the following instantiation of line 28.
\begin{lstlisting}[frame=none]
createSub(subInst_r1(john,james),1):-
   createSub(subInst_r1(v1,v2),1),holds(relB(john,james)). 
\end{lstlisting}
Hence due to lines 16 and \ref{abdChoice}, the atom
$query(relA(john,james),0)$ becomes true. This leads to the atoms
$query(relD(james),1)$ and $query(relF(james),2)$ becoming true. Hence the atoms $relD(james)$ and $relF(james)$ become part of the space of abducibles and the solver gives us the new optimal solution:
\begin{verbatim}
abducedFact(relD(james)) 
abducedFact(relF(james)) 
\end{verbatim}
On the other hand if we instead add the fact $relF(mary)$ to the initially empty set of user provided facts then we get the follwing instantiation of line 41:
\begin{verbatim}
createSub(subInst_r2(v2),2):-createSub(subInst_r2(v2),2),holds(relF(mary)).    
\end{verbatim}
Hence the atom $createSub(subInst\_r2(v2),2)$. Via line 22, and line 50 the atom $query(relE(mary),1)$ becomes true. We thus get the following instantiation of line 35:
\begin{verbatim}
createSub(subInst_r1(v1,mary),1):- createSub(subInst_r1(v1,v2),1), query(relE(mary),1).   
\end{verbatim}
Thus the atom $createSub(subInst\_r1(v1,mary),1)$ becomes true, which then via say line 16 and line 50 causes the atom $query(relA(v1,mary),0)$ to become true. Now, because of $query(relA(v1,mary),0)$, $relD(mary)$, $relB(v1,mary)$ become part of the space of abducibles and the solver gives us the optimal abductive solution: 
\begin{verbatim}
abducedFact(relD(mary)) 
abducedFact(relB(v1,mary))
\end{verbatim}
and a similar result is obtained if we add an instance of the predicate $relD$
to the initially empty set of user provided facts. Thus with this encoding we
have full implicit term substitution. The place holder or 'dummy' variables
$v1$, $v2$, always get replaced away in the optimal abductive solution based
on the user provided facts.\remms{But one can still get an abduced fact
  containing a Skolem function?} A subtle point here is that there is no notion of
equality between terms. We are not setting $v2 = mary$. We are instead
enlarging the space of abducibles in a systematic way based on user provided
facts so that a more optimal solution which involves replacing the term $v2$
for the term $mary$ can be realized. Note that adding an 'unrelated' fact such
as say $relG(mary)$ will not enlarge the space of abducibles in any way. So in
some sense what we have is a method to enlarge the space of abducibles in an
'economical' way while still supporting a notion of term substitution. We will
formulate and prove a formal result regarding this notion of term substitution
later on.

\subsubsection{Partial term substitution}

When skolem terms/function are used to handle existential variables, we have
to use the non- expanded abducible generation encoding which forces us to give
up on complete term substituion.  This is because having the complete term
substitution mechanism can result in programs that have infinitely large
abducible spaces. To recover finiteness of the space of the abducibles we have
to forgo full term substitution. What we get instead is a kind of partial term
substitution mechanism where skolem terms may only sometimes be substituted
for user provided terms.  First let us examine why in the presence of skolem
functions, even a subset of the expanded abduction generation encoding can
lead to infinite answer sets.

Consider the rule set consisting of just the single rule 
\begin{verbatim}
relA(X):-relB(X,Y),relA(Y).
\end{verbatim}

Suppose the goal is $a(john)$
Consider the encoding below, which is a subset of the expanded abducible generation encoding.
\begin{lstlisting}[numbers=left]
max_ab_lvl(5).
query(relA(bob),0).
:-not holds(relA(bob)).

holds(relA(X)) :- holds(relB(X, Y)),holds(relA(Y)).

explains(relB(X, Y), relA(X) ,N) :- createSub(subInst_r1(X,Y),N).
explains(relA(Y), relA(X) ,N) :- createSub(subInst_r1(X,Y),N).


createSub(subInst_r1(X,skolemFn_r1_Y(X)),N+1) :- query(relA(X) ,N),max_ab_lvl(M),N<M-1.

createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), holds(relB(X, Y)).
createSub(subInst_r1(V_X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N),holds(relA(Y)).


query(X,N):-explains(X,Y,N),max_ab_lvl(M),N<M.
{abducedFact(X)}:-query(X,N).
holds(X):-abducedFact(X).
holds(X):-user_input(pos,X).

:~abducedFact(Y).[1@1,Y]
:-abducedFact(relA(bob)).
\end{lstlisting}

Due to line 11 in the encoding we get the atom $createSub(subInst\_r1(bob,skolemFn\_r1\_Y(bob)),1)$.\\
Then due to lines 7 and 8 of the encoding we get the atoms $query(relA(skolemFn\_r1\_Y(bob)),1)$ and $query(relB(bob,skolemFn\_r1\_Y(bob)),1)$.\\

Then via lines 11 and 7 and due to the atom $query(relA(skolemFn\_r1\_Y(bob)),1)$, we get the atom $query(b(skolemFn\_r1\_Y(bob), skolemFn\_r1\_Y(skolemFn\_r1\_Y(bob))),2)$. \\

Then due to lines 18, 19, we get the atom $holds(relB(skolemFn\_r1\_Y(bob), skolemFn\_r1\_Y(skolemFn\_r1\_Y(bob))$.\\

Then due to line 13 of the encoding and the atom $createSub(subInst\_r1(bob,skolemFn\_r1\_Y(bob)),1)$ we get the atom $createSub(subInst\_r1(skolemFn\_r1\_Y(bob), skolemFn\_r1\_Y(skolemFn\_r1\_Y(bob))),1)$. \\

Then due line 8 and line 17, we get the atom $query(relA(skolemFn\_r1\_Y(skolemFn\_r1\_Y(bob)),1)$.\\

In this way we can see that with the encoding above we would have answer sets
that contain atoms of the form $query(relA(skolemFn\_r1\_Y(...),1)$ for
aribtrarily large skolem function nesting depth. Hence the encoding above
leads to infinitely large answer sets.

Intuitively, the core problem is lines like 13, 14 where the skolem depth of
terms in the $createSub$ predicate has no relation with the integer argument
of the $createSub$ predicate, thus allowing for abducibles, where the skolem
depth of the arguments inside predicates can be arbitrarily large despite
having a finite maximum abduction depth level. The solution to this problem
then is to replace the $N$ occuring as the integer argument of the $createSub$
predicate in the head of the rule on lines 13, 14 with $M-1$, where the $M$
corresponds to the argument of $max\_ab\_lvl$. This means that $query$ atoms
which occur due to the use of rules like line 13, 14 cannot further cause
fresh $query$ atoms to be added to the abducibles space via rules like the one
on line 11.

As a result of this however we lose complete term substitution. Consider the following abduction problem. $R$ is given by the following ASP rules:
\begin{verbatim}
relA(P):-relB(P,R),relD(R).
relB(P,R):-relA(R),relC(P).
\end{verbatim}

Let $q$ be the atom $relA(john)$, let $U$ consist of the constraints $:-abducedFact(relA(john)).$, $:-abducedFact(relB(X,Y)).$ meaning that $q$ cannot itself be abduced and no instantiation of the predicate $relB$ can be abduced. Let the set of user provided facts be empty for now. Let the set $C$ also be empty and let $N = 4$. This is the non expanded abduction encoding for this problem. 
\begin{lstlisting}[numbers=left]
max_ab_lvl(5).

% Encoding the goal
generate_proof(relA(john)).
goal:-holds(relA(john)).
:-not goal.
query(X,0):-generate_proof(X).

% Core rule translation
holds(relA(P)) :- holds(relB(P, R)),holds(relD(R)).
holds(relB(P, R)) :- holds(relA(R)), holds(relC(P)).

% AG1
createSub(subInst_r1(P,skolemFn_r1_R(P)),N+1) :- query(relA(P) ,N),max_ab_lvl(M),N<M-1.
createSub(subInst_r2(P,Q),N+1) :- query(relB(P, Q) ,N),max_ab_lvl(M),N<M-1.



explains(relB(P, R), relA(P) ,N) :- createSub(subInst_r1(P,R),N).
explains(relD(R), relA(P) ,N) :- createSub(subInst_r1(P,R),N).


explains(relA(R), relB(P,R) ,N) :- createSub(subInst_r2(P,R),N).
explains(relC(P), relB(P,R) ,N) :- createSub(subInst_r2(P,R),N).


% AG2 for rule 1
createSub(subInst_r1(P,R),M-1) :- createSub(subInst_r1(V_P,V_R),N), holds(relB(P, R)),max_ab_lvl(M).
createSub(subInst_r1(V_P,R),M-1) :- createSub(subInst_r1(V_P,V_R),N), holds(relD(R)),max_ab_lvl(M).

% AG2 for rule 2
createSub(subInst_r2(V_P,R),M-1) :- createSub(subInst_r2(V_P,V_R),N), holds(relA(R)),max_ab_lvl(M).
createSub(subInst_r2(P,V_R),M-1) :- createSub(subInst_r2(V_P,V_R),N), holds(relC(P)),max_ab_lvl(M).

% AG3
query(X,N):-explains(X,Y,N),max_ab_lvl(M),N<M.

% Supporting code
{abducedFact(X)}:-query(X,N).
holds(X):-abducedFact(X).
holds(X):-user_input(pos,X).


:~abducedFact(Y).[1@1,Y]
:-abducedFact(relA(john)).
:-abducedFact(relB(X,Y)).


\end{lstlisting}
Running this program in Clingo, we get the output 
\begin{verbatim}
abducedFact(relC(john))
abducedFact(relD(skolemFn_r1_R(skolemFn_r1_R(john))))
abducedFact(relA(skolemFn_r1_R(skolemFn_r1_R(john))))    
\end{verbatim}
as the solution with the least number of abducibles.
Now adding $relC(john)$ as a user provided fact gives the following smaller abductive solution
\begin{verbatim}
abducedFact(relD(skolemFn_r1_R(skolemFn_r1_R(john))))
abducedFact(relA(skolemFn_r1_R(skolemFn_r1_R(john))))    
\end{verbatim}
Now if we further add $relA(mary)$ to the set of user provided facts then we
get as a minimal abductive solution the answer $relD(mary)$. This is because
by after adding these facts, $holds(relB(john,mary))$ becomes true. Then by
line 28 of the encoding   $createSub(subInst\_r1(john,mary),4)$ becomes
true. Then by line 20, and line 36 $query(relD(mary),4)$ becomes true which
then gives us the miinimal abductive solution. However if instead of adding
the fact $relA(mary)$ we instead add the fact $relD(mary)$, then we do not get
a  substitution of terms does not take place and the minimal abductive
solution is still
\begin{verbatim}
abducedFact(relD(skolemFn_r1_R(skolemFn_r1_R(john))))
abducedFact(relA(skolemFn_r1_R(skolemFn_r1_R(john))))    
\end{verbatim} 
This is because by line 29, the atom $createSub(subInst\_r1(john,mary),4)$,
which due to line 19 and line 36 makes $query(relB(john,mary),4)$
true. However now this cannot cause the atom $query(relA(mary),5)$ to become
true because line 15 cannot apply due to the constraint on the integer
argument of the $query$ atom. So what we have can be regarded as a partial
term substitution mechanism.


\subsubsection{Replacing skolem functions by a single constant}

Let us see how having term substitution as a derived effect via enlargement of
the space of abducibles rather than doing term substitution through an
explicit equality predicate allows us to better handle problems where the core
rules have existential variables but we do not wish to use skolem functions in
the abductive reasoning process. Recall that not having skolem functions
allows us to get full term substitution without the possiblity of infinitely
large answer sets. Consider the problem $,\langle R,q,U,C,N \rangle$ where $R$ is the
following input rule set: 

\begin{verbatim}
relA(X):-relB(X,Y),relC(X,Y).
relB(X,Y):-relD(X,Y,Z),relE(X,Y,Z).
\end{verbatim}

let our $q$ be $relA(john)$. Let the initial set of user provided facts be empty, furthermore, suppose that no instance of $relA$ or $relB$ may be abduced. Finally let the set $C$ be emppty and let $N=4$.  
Consider the following encoding
\begin{lstlisting}[numbers=left]
max_ab_lvl(5).
% Encoding the goal
generate_proof(relA(john)).
query(X,0):-generate_proof(X).
goal:-holds(relA(john)).
:- not goal.



% Core rule translation
holds(relA(X)) :- holds(relB(X, Y)),holds(relC(X,Y)).
holds(relB(X,Y)) :- holds(relD(X,Y,Z)), holds(relE(X,Y,Z)).

% AG1_exp
createSub(subInst_r1(X,extVar),N+1) :- query(relA(X) ,N),max_ab_lvl(M),N<M-1.
createSub(subInst_r2(X,Y,extVar),N+1) :- query(relB(X,Y) ,N),max_ab_lvl(M),N<M-1.

explains(relB(X, Y), relA(X) ,N) :- createSub(subInst_r1(X,Y),N).
explains(relC(X, Y), relA(X) ,N) :- createSub(subInst_r1(X,Y),N).

explains(relD(X,Y,Z), relB(X,Y) ,N) :- createSub(subInst_r2(X,Y,Z),N).
explains(relE(X,Y,Z), relB(X,Y) ,N) :- createSub(subInst_r2(X,Y,Z),N).


% AG2_exp for rule 1

createSub(subInst_r1(X,V_Y),N) :- createSub(subInst_r1(V_X,V_Y),N), holds(relA(X)).
createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), holds(relB(X,Y)).
createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), holds(relC(X,Y)).

createSub(subInst_r1(X,V_Y),N) :- createSub(subInst_r1(V_X,V_Y),N), query(relA(X),N-1),0<N.
createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), query(relB(X,Y),N).
createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), query(relC(X,Y),N).


% AG2_exp for rule 2

createSub(subInst_r2(X,Y,V_Z),N) :- createSub(subInst_r2(V_X,V_Y,V_Z),N), holds(relB(X,Y)).
createSub(subInst_r2(X,Y,Z),N) :- createSub(subInst_r2(V_X,V_Y,V_Z),N), holds(relD(X,Y,Z)).
createSub(subInst_r2(X,Y,Z),N) :- createSub(subInst_r2(V_X,V_Y,V_Z),N), holds(relE(X,Y,Z)).


createSub(subInst_r2(X,Y,V_Z),N) :- createSub(subInst_r2(V_X,V_Y,V_Z),N), query(relB(X,Y),N-1),0<N.
createSub(subInst_r2(X,Y,Z),N) :- createSub(subInst_r2(V_X,V_Y,V_Z),N), query(relD(X,Y,Z),N).
createSub(subInst_r2(X,Y,Z),N) :- createSub(subInst_r2(V_X,V_Y,V_Z),N), query(relE(X,Y,Z),N).

% AG3_exp
query(X,N):-explains(X,Y,N),max_ab_lvl(M),N<M.
query(Y,N-1):-explains(X,Y,N),max_ab_lvl(M),N<M,0<N.

% Supporting code
{abducedFact(X)}:-query(X,N).
holds(X):-abducedFact(X).
holds(X):-user_input(pos,X).


:~abducedFact(Y).[1@1,Y]
:-abducedFact(relA(X)).
:-abducedFact(relB(X,Y)).

\end{lstlisting}

Note that in lines 15, 16 instead of using skolem functions we use a single
fresh constant $extVar$ to represent the existential variable in both
rules. Now, when we run the program we get the following optimal solution

\begin{verbatim}
abducedFact(relC(john,extVar))
abducedFact(relE(john,extVar,extVar))
abducedFact(relD(john,extVar,extVar))    
\end{verbatim}

Now because, term substitution is only a derived effect and there is no
equality relation, it is possible for different instances of $extVar$ to get
replaced (or not) by different constants upon the addition of some user
provided facts. For instance upon adding the fact $relC(john,james)$, we get
the optimal solution:

\begin{verbatim}
abducedFact(relE(john,james,extVar))
abducedFact(relD(john,james,extVar))    
\end{verbatim}

So some instances of $extVar$ from the original solution have been replaced, others haven't. What this means is that each occurence of $extVar$ in the original solution can be thought of as simply a place-holder for a term where each instance maybe a placeholder for a different term. When we use skolem functions instead this is simply more explicit because we have different skolem terms representing different existential variables. More formally in the first solution the variables $[X,Y,Z]$ get mapped to $[john, extVar,extVar]$ respectively. Upon the addition of the extra fact the we get the mapping $[X,Y,Z]\rightarrow[john,james,extVar]$. Using an equality relation to get from the first solution to the second via the equlity $james = extVar$ would force the second solution to be 

\begin{verbatim}
abducedFact(relE(john,james,james))
abducedFact(relD(john,james,james))    
\end{verbatim}
which in some sense is a less general solution than 
\begin{verbatim}
abducedFact(relE(john,james,extVar))
abducedFact(relD(john,james,extVar))    
\end{verbatim} 
where $extVar$ is a place holder for any term (including $james$).


\subsection{Generating Justification Trees}

Given a source rule 
\begin{verbatim}
pre_con_1(V1),pre_con_2(V2),...,pre_con_k(Vk),not pre_con_k+1(Vk+1),...,not pre_con_n(Vn) -> 
post_con(V).
\end{verbatim}

For each positive pre-condition $pre\_con\_u(V_{u})$, we add the following ASP rule:

\begin{verbatim}
causedBy(pos,pre_con_u(Vu), post_con(V),N+1):-holds(post_con(V)), holds(pre_con_1(V1)),
holds(pre_con_2(V2)),...,holds(pre_con_k(Vk)),not holds(pre_con_k+1(Vk+1)),...,
not holds(pre_con_n(Vn)),justify(post_con(V),N).   
\end{verbatim}
For each negative precondition $pre\_con\_f(V_{f})$ we add the following ASP
rule: 
\begin{verbatim}
causedBy(neg,pre_con_f(Vf), post_con(V),N+1):-holds(post_con(V)), holds(pre_con_1(V1)),
holds(pre_con_2(V2)),...,holds(pre_con_k(Vk)),not holds(pre_con_k+1(Vk+1)),...,
not holds(pre_con_n(Vn)),justify(post_con(V),N).   
\end{verbatim}


\subsubsection{Supporting code for justification tree}

\begin{verbatim}
justify(X,N):-causedBy(pos,X,Y,N), not user_input(pos,X),N<M, max_graph_lvl(M).
directedEdge(Sgn,X,Y):-causedBy(Sgn,X,Y,M).

justify(X,0):-gen_graph(X),not user_input(pos,X).

directedEdge(pos,userFact,X):-directedEdge(pos,X,Y), user_input(pos,X).

directedEdge(pos,userFact,X):-gen_graph(X), user_input(pos,X).

\end{verbatim}

\subsection{Discussion of Justification generation}

The intuition for the justification graph encoding is that given some user
provided facts $F$ and an input rule set $R$, an atom $a$ is only contained in
a stable model $M$ of $F$, $R$ if either $a$ is in $F$ or there exists some
rule $r$ in $R$ such that for some ground instantiation $r_{g}$ of $r$, all
the pre-conditions of $r_{g}$, (ie. the body atoms) are true in $M$ and the
post-condition (ie. head) of $r_{g}$ is $a$. Here the truth value of $NAF$
atoms is interpreted in the usual way.The edges for the justification graph
are calculated recursively. An atom $justify(h,k)$ represents the fact that
$holds(h)$ needs to be justified. If $r_{g}$ is a ground instantiantion of an
input rule where the post condition of $r_{g}$ is $h$ and all the
pre-conditions of $r_{g}$ are true then for every positive precondition
$b_{i}$ of $r_{g}$ we have the atom $causedBy(pos,b_{i},h,N)$ and for every
$NAF$ pre-condition $b_{j}$ we have the atom $causedBy(neg,b_{j},h,k)$. Then
if $k<max\_graph\_lvl$, we have the atoms $justify(b_{i},k+1)$, for every
positive pre-condition $b_{i}$. Finally each $causedBy$ atom generates a
$directedEdge$ atom, and these atoms are the set of directed edges
representing the justification graph.


\subsection{Some example executions}
Given the following program
\begin{lstlisting}[numbers=left]
gen_graph(relA(john)).
max_graph_lvl(5).

user_input(pos,relE(john,james,mary)).
user_input(pos,relD(john,james,mary)). 

holds(X):-user_input(pos,X).

holds(relA(X)) :- holds(relB(X, Y)),not holds(relC(X,Y)).
holds(relB(X,Y)) :- holds(relD(X,Y,Z)), holds(relE(X,Y,Z)).

causedBy(pos,relB(X,Y),relA(X),N+1):-holds(relA(X)),holds(relB(X, Y)),not holds(relC(X,Y)),justify(relA(X),N).
causedBy(neg,relC(X,Y),relA(X),N+1):-holds(relA(X)),holds(relB(X, Y)),not holds(relC(X,Y)),justify(relA(X),N).

causedBy(pos,relD(X,Y,Z),relB(X,Y),N+1):-holds(relB(X,Y)),holds(relD(X,Y,Z)),holds(relE(X,Y,Z)),justify(relB(X,Y),N).
causedBy(pos,relE(X,Y,Z),relB(X,Y),N+1):-holds(relB(X,Y)),holds(relD(X,Y,Z)),holds(relE(X,Y,Z)),justify(relB(X,Y),N).

justify(X,N):-causedBy(pos,X,Y,N), not user_input(pos,X),N<M, max_graph_lvl(M).
directedEdge(Sgn,X,Y):-causedBy(Sgn,X,Y,M).

justify(X,0):-gen_graph(X),not user_input(pos,X).

directedEdge(pos,userFact,X):-directedEdge(pos,X,Y), user_input(pos,X).

directedEdge(pos,userFact,X):-gen_graph(X), user_input(pos,X).
\end{lstlisting}
We get the following set of directed edges representing the justification graph. 
\begin{verbatim}
directedEdge(pos,relB(john,james),relA(john))
directedEdge(pos,relE(john,james,mary),relB(john,james))
directedEdge(pos,relD(john,james,mary),relB(john,james))
directedEdge(neg,relC(john,james),relA(john))
directedEdge(pos,userFact,relD(john,james,mary))
directedEdge(pos,userFact,relE(john,james,mary))
\end{verbatim}
\section{Sample problem and corresponding ASP program}\label{sec:sample_problem}
We give a sample problem here and its corresponding ASP program. We will refer to certain lines of the ASP program given here, in the finiteness proof for the general case. 
\begin{lstlisting}[numbers=left]
max_ab_lvl(5).
query(relA(bob),0).
goal:-holds(relA(bob)).
:-not goal.


holds(relA(P)) :- holds(relB(P, R)),holds(relD(R)).
holds(relB(P, R)) :- holds(relA(R)), holds(relC(P)).

explains(relB(P, R), relA(P) ,N) :- createSub(subInst_r1(P,R),N).
explains(relD(R), relA(P) ,N) :- createSub(subInst_r1(P,R),N).


createSub(subInst_r1(P,skolemFn_r1_R(P)),N+1) :- query(relA(P) ,N),max_ab_lvl(M),N<M-1.
createSub(subInst_r2(P,Q),N+1) :- query(relB(P, Q) ,N),max_ab_lvl(M),N<M-1.


explains(relA(R), relB(P,R) ,N) :- createSub(subInst_r2(P,R),N).
explains(relC(P), relB(P,R) ,N) :- createSub(subInst_r2(P,R),N).



createSub(subInst_r1(P,R),M-1) :- createSub(subInst_r1(V_P,V_R),N), holds(relB(P, R)),max_ab_lvl(M).
createSub(subInst_r1(V_P,R),M-1) :- createSub(subInst_r1(V_P,V_R),N), holds(relD(R)),max_ab_lvl(M).

createSub(subInst_r2(V_P,R),M-1) :- createSub(subInst_r2(V_P,V_R),N), holds(relA(R)),max_ab_lvl(M).

createSub(subInst_r2(P,V_R),M-1) :- createSub(subInst_r2(V_P,V_R),N), holds(relC(P)),max_ab_lvl(M).


query(X,N):-explains(X,Y,N),max_ab_lvl(M),N<M.
{abducedFact(X)}:-query(X,N).
holds(X):-abducedFact(X).
holds(X):-user_input(pos,X).

:~abducedFact(Y).[1@1,Y]
:-abducedFact(relA(bob)).
:-abducedFact(relB(X,Y)).

\end{lstlisting}

\section{Proof sketch of Finiteness}\label{sec:proof_finiteness}

\begin{theorem}[Finiteness]\label{thm:finiteness}
Assume that $\langle R,q,U,C,N \rangle$ is such that $R$ is function free and
also contains no arithmetic operations. $N$ is finite. $q$ is a ground
positive atom containing no function symbols. $U$ contains some integrity
constraints and ground positive atoms containing no function symbols. Then
$GenPf_{\langle R,q,U,C,N \rangle}$ cannot have infinte answer sets. 
\end{theorem}

\begin{lemma}
Let $S$ be the set of uninterpreted skolem functions appearing in the proof
search encoding. Let $C$ be the set of constants occuring in either a user
inputed fact in $U$ or the query $q$. Let $T_{k}$ denote the set of unique
terms that can be constructed from $S$ and $C$ with skolem depth atmost
$k$. Let $T$ be the possibly infinite set consisting of terms of unbounded
depth. Then for any positive integer $k$, $T_{k}$ is finite. 
\end{lemma}

$Proof:$ This is a standard result which follows easily by induction. Clearly $|T_{0}|$ = $|C|$, which is finite. Let $|T_{k}|$ = $B$ be finite. Let $S$ be a set of $l$ functions having arity at most $d$. Then $|T_{k+1}|\leq B + lB^{d}$. Hence $T_{k+1}$ is finite.  

\begin{lemma}
 For any predicate $p$ inside an $abducedFact$ atom the arguments of $p$ are elements of the set $T_{N}$. Similarly for any predicate $p$ inside an $holds$ atom the arguments of $p$ are elements of the set $T_{N}$. Similarly for the other atoms in any answer set of $Ab_{\langle R,q,U,C,N \rangle}$. Terms that correspond to arguments of rule predicates are always elements of $T_{N}$.
\end{lemma}

$Proof$ $Sketch$: Firstly note that for any predicate $p$ inside a
$abducedFact$ or $holds$ atom, where $p$ comes from the original rule set, the
arguments of $p$ belong to the set $T$. We can see this by observing that
since no rule in $R$ contains a function symbol, the encoding of the rules
themselves such as in line 2 of the ASP program above, cannot introduce new
terms in the arguments of predicates inside $holds$ atoms. Similarly lines
like 24, 25 also cannot introduce new terms inside $holds$, $create\_sub$
atoms in the final answer set, which means also that no new terms appear as
predicate arguments inside $abducedFact$ atoms. 

Only lines like 18,19 are able to create fresh terms that become arguments of
various atoms in the answer set. But then it follows that any $holds$ atom,
$create\_sub$, $abducedFact$ can only have predicate arguments from the set $T$.

Next we show that the skolem depth of these terms is at most $N$. Any fresh
term $t$ from $T$ appearing in the final answer set must have been constructed
from rules like in lines 18,19. But these encode a 'static' space of
abducibles, which unlike lines 24,25 is independent of the forward reasoning
component or any user provided additional facts. It is not hard to see that
terms created via these ASP rules must have skolem depth at most $N$. 

\begin{lemma}
Since the set $T_{N}$ is finite it follows that any answer set of $Ab_{\langle
  R,q,U,C,N \rangle}$ is finite.
\end{lemma}

$Proof:$ Since $T_{N}$ is finite and the integer argument of any $create\_sub$ atom is bounded by $N$, any atom in the final answer set has only finitely many instantiations. This proves finiteness of the resulting answer set. 
\begin{lemma}
If $Ab_{\langle R,q,U,C,N\rangle}$ only has finite answer sets then so does $GenPf_{\langle R,q,U,C,N\rangle}$
\end{lemma}

\section{Completeness for restricted class of problems}\label{sec:completeness}
For the completeness proof we make the following assumptions leaving an
investigation of the general case for future work. Given $\langle
R,q,U,C,N\rangle$ we make the following assumptions. 

\begin{enumerate}
\item $R$ contains no negation as failure.
\item $C$ is empty.
\item The set of predicates which occur in user supplied facts in $U$ is
  disjoint from the set of predicates which are prevented from being used as
  abducibles
\item No post condition of any rule in $R$ contains repeated variables. For example the rule:\\
$p(X,X):-r(X,X,Y)$ is not allowed but the rule: $p(X,Y):-r(X,X,Y)$ is allowed.
\end{enumerate}

Note that that these conditions mean that without loss of generality, for the sake of proving completeness, we may assume that the set of user supplied facts is empty.

\begin{lemma}
Assume $\langle R,q,U,C,N\rangle$, $\langle R,q',U,C,N\rangle$ are two
problems satisfying the conditions above but $q'$ is obtained from $q$ by
possibly changing some or all of the arguments of $q$. Then $\langle
R,q,U,C,N\rangle$ has a solution if and only if $\langle R,q',U,C,N\rangle$
does.
\end{lemma}

$Proof$ We prove the lemma by induction on $N$.
The case $N = 0$ is trivial. If there exists a solution for $\langle
R,q,U,\emptyset,0\rangle$ then any instance of the predicate in $q$ can be
abduced therefore $\langle R,q',U,\emptyset,0\rangle$ has a solution. Assume
the result for some $N = k$ such that $k>0$. A non trivial solution to
$\langle R,q,U,\emptyset,k+1\rangle$ implies the existence of a solution to
the following set of problems $\langle R,q_{pre_{i}},U,\emptyset,k\rangle$
where the set of $q_{pre_{i}}$ where the $q_{pre_{i}}$ are the set of
pre-conditions of a rule $r$ in $R$, under some substitution $\theta$ where
$\theta$ applied to the post-condition of $r$ gives $q$. But then since $r$
contains no repeated variables, if $q$ unifies with the post condition of $r$
under some substituion $\theta$, then there exists some other substitution
$\theta'$ for the variables in $r$ such that $\theta'$ applied to the
postcondition of $r$ gives $q'$. Therefore a solution to the set of problems
$\langle R,q'_{pre_{i}},U,\emptyset,k\rangle$ is also a solution to $\langle
R,q',U,\emptyset,k+1\rangle$ where each $q'_{pre_{i}}$ is obtained from
$q'_{pre_{i}}$ by possibly changing the arguments in the predicate. By the
induction hypothesis such a solution to the set of problems $\langle
R,q'_{pre_{i}},U,\emptyset,k\rangle$. Hence a solution to  $\langle
R,q,U,\emptyset,k+1\rangle$ exists. This proves the lemma.

\subsection{Proof of main theorem}
We now prove the main theorem by induction on $N$. That is we prove the following:

\begin{theorem}[Completeness]\label{thm:completeness}
  If there exists a general solution $S$ to $\langle R,q,U,\emptyset,N\rangle$ then there
  exists a ASP solution $S_{ASP}$ to $\langle R,q,U,\emptyset,N\rangle$.
\end{theorem}

$Proof$ We prove this by induction on $N$. The case $N=0$ is trivial. Assume
the result for some $N=k>0$. The existence of a non-trivial general solution
to $\langle R,q,U,\emptyset,k+1\rangle$ implies the existence of a solution to
the following set of problems, $\langle R,q_{pre_{i}},U,\emptyset,k\rangle$
where the set of $q_{pre_{i}}$ where the $q_{pre_{i}}$ are the set of
pre-conditions of a rule $r$ in $R$, under some substitution $\theta$ where
$\theta$ applied to the post-condition of $r$ gives $q$. But then by the
inductive hypothesis there is an ASP solution to the same set of problems. By
the lemma proved above there exists an ASP solution to following set of
problems $\langle R,q'_{pre_{i}},U,\emptyset,k\rangle$, where each
$q'_{pre_{i}}$ is obtained from the corresponding $q_{pre_{i}}$, by possibly
replacing some predicate arguments with the appropriate skolem terms for
predicate arguments that correspond to existential variables in the
preconditions of $r$. Hence there exists an ASP solution to
$\langle R,q,U,\emptyset,N\rangle$.

\section{Proof simplification using user inputed facts for Comp encoding}\label{sec:proof_simplification}
\subsection{Definition 1 - Abstract Proof graph}
Given a rule set $R$ satisfying condition 4 from above but possibly having
NAF, and a predicate $p$ and integer $n$ define the abstract proof graph
$G_{R,p,n}$ as follows. The nodes of $G_{R,p,n}$ is the set of $query$
predicates generated by the rules $AG1$ and $AG3$. when in
$\langle R,q,U,C,N\rangle$, $q$ is $p(v1,v2..,vk)$ where $p$ has arity $k$,
$U$, $C$ are empty and $N = n+1$. The edge relation is defined as follows. Two
nodes $d1$, $d2$ are connected by a directed edge represented as $E(d1,d2)$ if
and only if, $d1$ represents a pre-condition of an input rule where $d2$ is
the post condition.

So if $R'$ consisted to the single rule:
\begin{verbatim}
a(X):-b(X,Y),a(Y)
\end{verbatim}
Then $G_{R',a,2}$ is:
\begin{verbatim}
E(query(b(v1,sk(v1)),1),query(a(v1),0)),
E(query(a(sk(v1)),1),query(a(v1),0)))
E(query(b(sk(v1),sk(sk(v1))),2),query(a(sk(v1)),1)),
E(query(a(sk(sk(v1))),2),query(a(sk(v1)),1)) \end{verbatim}
Here $sk$ is just an abbreviation of the full skolem function name. 
Given an abstract proof graph $G_{R',p,N}$, construct the minimal proof graph $G_{R',p,N}^{min}$ as follows. Firstly for given an integer $k$, going from left to right, delete all duplicate nodes $query(a',k)$ such that $query(a,k)$ is already in the proof graph and $a'=a$. Next for going down the proof graph, for each $k\in {0,1...,N}$, delete the node $query(a,k)$, if there exists $l<k$, such that $query(a',l)$ is in the proof graph $a=a'$. This forms $G_{R',p,N}^{min}$. The edge relation is inherited from $G_{R,p,N}$ in the obvious way. Note firstly that if for some $b,j$, $query(b,j)$ is in $G_{R',p,N}$, then there exists some $h\leq j$ such that $query(b,h)$ is in $G_{R',p,N}^{min}$. Secondly we have the following property:
\begin{lemma}
Given $query(a,k)$ in $G_{R',p,N}^{min}$, unless $k=0$, there exists $query(a',j)$ in $G_{R',p,N}^{min}$ such that we have $E(query(a,k),query(a',j))$.  
\end{lemma}
$\textit{Proof sketch}$ Let $query(a'',j')$ be such that $E(query(a,k),query(a'',j'))$ in $G_{R',p,N}$. Now if $query(a'',j')$ is not in $G_{R',p,N}^{min}$, then there exists $s<j'$ such that $query(a'',s)$ is in $G_{R',p,N}^{min}$, but then there exists $t<k$ such that $query(a,t)$ is in $G_{R',p,N}^{min}$. However this is a contradiction. Hence it must be the case that $query(a'',j')$ is in $G_{R',p,N}^{min}$. 



\subsection{Definition 2 - Concrete Proof graph}

Given an abstract proof graph $G_{R,p,n}$, and a substitution $\theta$ for
terms in the abstract proof graph, define the concrete proof graph
$C_{R,p,n,\theta}$ to be the set of $query$ atoms obtained after doing the
substitution $\theta$ on the set of $query$ atoms in $G_{R,p,n}$.

For example given the substitution $\phi$ $[v1\rightarrow john, sk(v1)
\rightarrow james, sk(sk(v1))\rightarrow mary]$, $C_{R',a,2,\phi}$ is :

\begin{verbatim}
query(a(john),0), query(b(john,james),1), query(a(james),1)
query(b(james,mary),2), query(a(mary),2) \end{verbatim}
Note that such a substitution $\phi$ need not be injective.


\subsection{Definition 3 - Derived substitution}
Given some $G_{R,p,n}$, and an associated $C_{R,p,n,\theta}$, let $q_{c}$ be a $query$ atom from $C_{R,p,n,\theta}$. Let $S_{q_{c}}$ be the set of $query$ atoms in $G_{R,p,n}$, which upon application of the substitution $\theta$ give $q_{c}$. Now pick an atom $q_{o}$ from $S_{q_{c}}$. Now suppose $q_{c}$ is given by $query((t_{1},t_{2},...,t_{j}),k)$, $q_{o}$ is given by $query((e_{1},e_{2},...,e_{j}),k)$. Now consider an arbitrary query atom $q_{f}$ given by $query((a_{1},a_{2},...,a_{j}),k)$, which is such that the map $\psi$ mapping each $e_{i}$ to the corresponding $a_{i}$ is well defined. (ie. $\psi$ is not one-to-many). Then define the substituion $\phi = T(\theta, q_{c},q_{o},q_{f})$ on terms in $G_{R,p,n}$ by the following:\\ For a term $u$ in $G_{R,p,n}$, if $u$ is in the set $\{e_{1},e_{2},...,e_{j}\}$ then $\phi(u) = \psi(u)$, otherwise $\phi(u) = \theta(u)$.

\begin{theorem}[Term substitution]\label{thm:termsub}
Given a rule set $R$ satisfying condition 4 from above consider $\langle R,q,U,C,N\rangle$,
let $p$ be the predicate corresponding to $q$. Suppose $A$ is an answer set of
$P^{semi-complete}_{<R,q,U,C,N>}$ and let $A$ contain $C_{R,p,N,\theta}$. Now
say the atom $q_{c}$ $query(p_{i}(t_{1},t_{2},..,t_{j}),k)$ is in
$C_{R,p,N,\theta}$. Let $q_{o}$ be some query atom from the set $S_{q_{c}}$
given by $query((e_{1},e_{2},...,e_{j}),k)$. Now suppose, $q_{f}=
query((a_{1},a_{2},...,a_{j}),k)$ is an arbitrary $query$ atom such that the
map $\psi$ from the $e_{i}s$ to the $a_{i}s$ as described in the definition
above is well defined. Then upon adding the fact
$query(p_{i}(a_{1},a_{2},..,a_{j}),k)$ to $P^{semi-complete}_{<R,q,U,C,N>}$,
the resulting program has an answer set $A'$ such that $A'$ contains
$C_{R,p,N,\phi}$, where $\phi = T(\theta, q_{c}, q_{o}, q_{f})$.
\end{theorem}

$\textit{Proof sketch}$. In the following proof when we refer to the $level$ of a $query$ atom we mean the integer argument of the $query$ atom. When we refer to the $predicate$ $argument$ of a $query$ atom we will mean the first argument of a $query$ atom. Given a $query$ atom $q$ in $G_{R,p,N}$, the transformed atom $tr(q)$ denoted the corresponding atom in $C_{R,p,N,\phi}$. We will prove the result by induction on $k$, the level of the atoms $q_{c}$, $q_{o}$ and $q_{f}$. 

Fix $q_{c}$, $q_{o}$ and $q_{f}$ and suppose that the level of these atoms $k$ is $0$. Since there is only one level $0$ query atom say $q'$ in $G_{R,p,N}$, we must have $q_{o}=q'$, and $q_{f} = tr(q')$. Now we have to show that for all $query$ atoms $q$ in $G_{R,p,N}$ such that the level of $q$ is greater than $0$, we have $tr(q)$. Now suppose that $p$ is a 3 place predicate and there is an input rule $r_{c}$ where ${c}$ refers to the rule id. Suppose that the predicate $p_{d}$ appears as a pre-condition in $r_{c}$. Let the variables in $r_{c}$ be $X1$, $X2$, $X3$, $X4$, in the order given by $O_{c}$, (recall from Section 3.1 that for each input rule we had some order on the variables). Suppose $r_{c}$ has the following form:
\begin{verbatim}
p(X2,X1,X4):-p_d(X4,X2,X3),...    
\end{verbatim}

Then in $C_{R,p,N,\theta}$, we have the following $query$ and $createSub$ atoms:

$query(p(\theta(v1),\theta(v2),\theta(v3),0)$, $query(p_{d}(\theta(v3),\theta(v1),\theta(sk(v2,v1,v3)),1))$. 

Here $sk$ stands for the skolem function $skolemFn\_c\_x3$. 

We also have $createSub(subInst\_r_{c}(\theta(v2),\theta(v1),\theta(sk(v2,v1,v3)), \theta(v3)),1)$. Note that $\theta(v1)=t_{1},\theta(v2)=t_{2},\theta(v3)=t_{3}$, furthermore $q_{o}= query(p(v1,v2,v3),0)$. Now given $q_{f} = query(p(a_{1},a_{2},a_{3}),0)$ as above we have consider the following $AG2$ clause:
\begin{verbatim}
createSub(subInst_r_c(X1,X2,V_X3,X4),N):-createSub(subInst(V_X1,V_X2,V_X3,V_X4),N),
query(p(X2,X1,X4),N-1),0<N,N<M,max_ab_lvl(M).    
\end{verbatim}
We have the following instantiation of the clause above

$createSub(subInst\_r\_c(a_{2},a_{1},\theta(sk(v2,v1,v3)),a_{3}),1):-createSub(subInst\_r\_c(t_{2},t_{1},\theta(sk(v2,v1,v3)),t_{3}),1),q_{f}.$\\
Then via an instantiation of the following $AG1$ clause:
\begin{verbatim}
explains(p_d(X4,X2,X3),p(X1,X2,X4),N):-createSub(subInst_r_c(X1,X2,X3,X4),N).    
\end{verbatim}
and an instantiation of the following $AG1$ clause:
\begin{verbatim}
query(X,N):-explains(X,Y,N).    
\end{verbatim}
We get the following atom $query(p_{d}(a_{3},a_{1},\theta(sk(v2,v1,v3)),1)$ which is $tr(query(p_{d}(t_{3},t_{1},\theta(sk(v2,v1,v3))),1))$. Similarly for any other child node $q$ of $query(p(v1,v2,v3),0)$ in $G{R,p,N}$, we get $tr(q)$. Now it follows by a similar argument to before that for any child node $q'$ of these transformed level one nodes $q$, we also get $tr(q')$. One can see this by considering the following: Given a level one node $q$ from $G_{R,p,N}$, let $q_{c}^{1}$ be the image of $q$ under $\theta$, let $q_{o}^{1}$ be $q$ and let $q_{f}^{1}$ be $tr(q)$, then consider $\phi'$ = $T(\theta, q_{c}^{1},q_{o}^{1},q_{f}^{1})$. Then on any term $b$ in $q$, such that $b$ is in the set $\{v1,v2,v3\}$, $\phi'(b)$ =$\phi(b)$ and on all other terms $t$ in $G_{R,p,N}$, $\phi'(t)=\theta(t)$. Now, given the level one node $q$ in $G_{R,p,N}$, let $q'$ be a child node of $q$, then for any term $t'$ in $q'$, such that $t'$ occurs in the set $\{v1,v2,v3\}$, it must be the case that $t'$ occurs in $q$. Therefore, the result of applying $\phi'$ on $q'$ will in fact give us $tr(q')$ (recall that $tr$ corresponds to the transformation of $query$ atoms induced by $\phi$. In this way one can see that the term substitution given by $\phi$ will propogate all the way downwards over elements of $C_{R,p,N,\theta}$. This completes the case $k=0$. 

Now suppose we have proven the theorem for all values of $k<e$. Now let $q_{c},q_{o},q_{f}$ be such that the level of all these atoms in $e+1$, and let $q_{o}$ be $q_{o}$ does not correspond to a pre-condition of an input rule, where the pre-condition contains an existential variable. Now, let $q_{d}$ be the parent node of $q_{o}$. Let $r_{h}$ be the relevant rule and let the predicate corresponding to $q_{o}$ be $p_{z}$ and let the predicate corresponding to $q_{d}$ be $p_{y}$. Then due to an instantiation of a rule of the following form:
\begin{verbatim}
createSub(subInst_r_h(W''),e+1):-query(p_z(W_f),e+1),createSub(subInst_r_h(W'),o+1).
\end{verbatim}
where $query(p_{z}(W_{f}),e+1)$ = $q_{f}$, $W'$ is $\theta$ applied to the relevant set of terms $W$ from the abstract proof graph, and $W''$ is $\phi(W)$. Now due an instantiation of the following rule:
\begin{verbatim}
explains(p_z(W_f),p_y(U),e+1):-createSub(subInst_r_h(W''),e+1).
\end{verbatim} and the following $AG3$ rule:
\begin{verbatim}
query(Y,N-1):-explains(X,Y,N).    
\end{verbatim}
we get the atom $tr_{\phi}(q_{d})$. Now consider
$\phi'= T(\theta, \theta(q_{d}), q_{d}, tr_{\phi}(q_{d}))$, then $\phi'=\phi$
on the terms in $q_{d}$, that also appear in $q_{o}$, and $\phi' = \theta$ on
all other terms. However all the terms that appear in $q_{o}$ also appear in
$q_{d}$, since we assumed that $q_{o}$ did not have terms corresponding to
existential variables. Also the level of $q_{d}$ is $e$. Hence by the
inductive hypothesis we are done. Now, let $q_{c},q_{o},q_{f}$ be such that
some terms in the first argument of $q_{o}$ correspond to existential
variables. That is these terms are do not appear in the parent node of $q_{c}$
and are skolem functions whose input consists of terms in the parent node of
$q_{c}$. Let $V_{univ,q_{c}}$ consist of the set of terms in the first
argument of $q_{c}$ that correspond to universally quantified variables and
let $V_{ext,q_{c}}$ consist of the set of terms in the first argument of
$q_{c}$ that correspond to existentially quantified variables. Firstly,
consider $\phi'$ such that $\phi'=\phi$ on the terms in $V_{univ,q_{c}}$ and
$\phi' =\theta$ on all other terms in the abstract proof graph. Then given
this $\phi'$, note that we already get the concrete proof graph
$C_{R,p,n,\phi'}$, this is because, given the parent node $q'_{o}$, in the
abstract proof graph, we have $tr_{\phi'}(q'_{o})$ and since the level of
$q'_{o}$ is $e$, we know by the inductive hypothesis that the appropriate
transformation of the whole abstract proof graph follows. So in fact we to
prove the case where the level of $q_{c},q_{o},q_{f}$ is $e+1$, we can now
assume WLOG, that $q_{c_i}\neq q_{f_i}$ implies that $q_{o_i}$
corresponds to an existential variable where here $q_{c_i}$ denotes the
$i^{th}$ entry of the first argument of $q_{c}$ and similarly for the
others. So assume now that we are in this case and
$\phi= T(q_{c},q_{o},q_{f})$. Let $V'_{ext,q_{o}}$ be the set of terms in the
first argument of $q_{o}$ that correspond to existential variables. Now let
$q'_{o}$ be the parent node of $q_{o}$. Then due to the appropriate $AG2$ and
$AG3$ clauses, it follows that for all the child nodes $q''$ of $q'_{o}$, we
have $tr_{\phi}(q'')$. Due to a similar argument to the one we used for the
case $k=0$, it follows that for any descendant of $q_{d}$ of $q'_{o}$, we will
get $tr_{\phi}(q_{d})$. Now we claim that in the abstract proof graph, the
only nodes whose first entry contains terms from $V'_{ext,q_{o}}$ are
descendants of $q'_{o}$. Given a term $t$ from $V'_{ext,q_{o}}$, occurring in
a node $j$ of the minimal abstract proof graph, if $t$ does not correspond to
an existential variable in $j$, then since $t$ is not in the set
$\{v_{1},v_{2},..,v_{n}\}$, there exists some ancestor $j'$ of $j$ such that
$t$ corresponds to an existential variable in $j'$. Let $j_{p}$ be the parent
node of $j'$. Now, let $t$ be of the form
$skolemFn_{l_{b(g_{1},..,g_{m})}}$. Here $l$ refers to a input rule, $b$ refers
to some existential variable among the pre-conditons of $l$, and
$\{g_{1},g_{2},...,g_{m}\}$ refers to a fixed permutation of the arguments of
the post-condition of rule corresponding to $l$. However, from this we can
uniquely determine what the first entry of $j_{p}$ must be. Based on the order
$O_{l}$, the arguments of the relevant instantiation of the post-condition of
$l$ are given by some fixed permutation $\pi_{O_{l}}$ of
$\{g_{1},g_{2},...,g_{m}\}$. Therefore it follows that the first argument of
$j_{p}$ is in fact the same as that of $q'_{o}$. But now since we are working
with $\textit{minimal}$ abstract proof graphs it follows that
$j_{p} = q'_{o}$. This proves the claim and hence completes the proof of the
theorem.

\input{derivation_tree_figure}


 
\begin{corollary}[Adding facts]\label{addfact}
Given a rule set $R$ satisfying condition 4 from above consider $\langle R,q,U,C,N\rangle$, let $p$ be the predicate corresponding to $q$. Suppose $A$ is an answer set of $P^{semi-complete}_{<R,q,U,C,N>}$ and let $A$ contain $C_{R,p,N,\theta}$. Now say the atom $q_{c}$ $query(p_{i}(t_{1},t_{2},..,t_{j}),k)$ is in $C_{R,p,N,\theta}$. Let $q_{o}$ be some query atom from the set $S_{q_{c}}$ given by $query((e_{1},e_{2},...,e_{j}),k)$. Now suppose, $h_{f}= holds((a_{1},a_{2},...,a_{j}))$ is an arbitrary $holds$ atom such that the map $\psi$ from the $e_{i}s$ to the $a_{i}s$ as described in the definition above is well defined. Then upon adding the fact $holds(p_{i}(a_{1},a_{2},..,a_{j}))$ to $P^{semi-complete}_{<R,q,U,C,N>}$, the resulting program has an answer set $A'$ such that $A'$ contains $C_{R,p,N,\phi}$, where $\phi = T(\theta, q_{c}, q_{o}, q_{f})$, where $q_{f} = query(p_{i}(a_{1},a_{2},..,a_{j}),k)$. 
\end{corollary}
\textit{Proof} This follows from the theorem above and the rule\\ $query(X,N):-holds(X),max\_ab\_lvl(M),N = 0..M.$
\section{Applications and Extensions}\label{sec:applications_extensions}

\subsection{Maximal abduction depth}
For rule sets with no existential variables, if one wants to explore the maximal abduction space then this can be achieved simply by setting all the integer depth parameters to 0. For instance this is what we will get for our previous example.
\begin{lstlisting}[numbers=left]
% Encoding the goal
generate_proof(relA(v1,v2)).
query(X,0):-generate_proof(X).
goal:-holds(relA(P,R)).
:- not goal.

% Core rule translation
holds(relA(X,Y)) :- holds(relB(X, Y)),holds(relD(Y)), not holds(relE(Y)).
holds(relE(Y)) :- holds(relD(Y)), not holds(relF(Y)).

% AG1_exp
createSub(subInst_r1(X,Y),0) :- query(relA(X,Y) ,0).
createSub(subInst_r2(Y),0) :- query(relE(Y) ,0).

explains(relB(X, Y), relA(X,Y) ,0) :- createSub(subInst_r1(X,Y),0).
explains(relD(Y), relA(X,Y) ,0) :- createSub(subInst_r1(X,Y),0).
explains(relE(Y), relA(X,Y) ,0) :- createSub(subInst_r1(X,Y),0).
explains(relA(X,Y), relA(X,Y) ,0) :- createSub(subInst_r1(X,Y),0).


explains(relD(Y), relE(Y) ,0) :- createSub(subInst_r2(Y),0).
explains(relF(Y), relE(Y) ,0) :- createSub(subInst_r2(Y),0).
explains(relE(Y), relE(Y) ,0) :- createSub(subInst_r2(Y),0).


% AG2_exp for rule 1

createSub(subInst_r1(X,Y),0) :- createSub(subInst_r1(V_X,V_Y),0), holds(relA(X,Y)).
createSub(subInst_r1(X,Y),0) :- createSub(subInst_r1(V_X,V_Y),0), holds(relB(X,Y)).
createSub(subInst_r1(V_X,Y),0) :- createSub(subInst_r1(V_X,V_Y),0), holds(relD(Y)).
createSub(subInst_r1(V_X,Y),0) :- createSub(subInst_r1(V_X,V_Y),0), holds(relE(Y)).

createSub(subInst_r1(X,Y),0) :- createSub(subInst_r1(V_X,V_Y),0), query(relA(X,Y),0).
createSub(subInst_r1(X,Y),0) :- createSub(subInst_r1(V_X,V_Y),0), query(relB(X,Y),0).
createSub(subInst_r1(V_X,Y),0) :- createSub(subInst_r1(V_X,V_Y),0), query(relD(Y),0).
createSub(subInst_r1(V_X,Y),0) :- createSub(subInst_r1(V_X,V_Y),0), query(relF(Y),0).

% AG2_exp for rule 2

createSub(subInst_r2(Y),0) :- createSub(subInst_r2(V_Y),0), holds(relE(Y)).
createSub(subInst_r2(Y),0) :- createSub(subInst_r2(V_Y),0), holds(relD(Y)).
createSub(subInst_r2(Y),0) :- createSub(subInst_r2(V_Y),0), holds(relF(Y)).


createSub(subInst_r2(Y),0) :- createSub(subInst_r2(V_Y),0), query(relE(Y),0).
createSub(subInst_r2(Y),0) :- createSub(subInst_r2(V_Y),0), query(relD(Y),0).
createSub(subInst_r2(Y),0) :- createSub(subInst_r2(V_Y),0), query(relF(Y),0).

% AG3_exp
query(X,0):-explains(X,Y,0).
query(Y,0):-explains(X,Y,0).

% Supporting code
{abducedFact(X)}:-query(X,0).
holds(X):-abducedFact(X).
holds(X):-user_input(pos,X).


:~abducedFact(Y).[1@1,Y]
:-abducedFact(relA(X,Y)).
\end{lstlisting}
Such an ASP program is also guaranteed to have only finite answer sets.

\subsection{Mapping distinct variables to the same skolem terms}
These extra proof search rules are needed to expand the proof search space when the rule set $R$ does not satify the unique arguments property. Say rule $r1$ involves 3 variables $X, Y, Z$. Then we add the following to the proof-search encoding:
\begin{verbatim}
createSub(subInst_r1(X,X,Z),M-1)    :-createSub(subInst_r1(X,Y,Z),N),max_ab_lvl(M).

createSub(subInst_r1(X,Y,X),M-1)    :-createSub(subInst_r1(X,Y,Z),N),max_ab_lvl(M).

createSub(subInst_r1(Y,Y,Z),M-1)    :-createSub(subInst_r1(X,Y,Z),N),max_ab_lvl(M).

createSub(subInst_r1(X,Y,Y),M-1)    :-createSub(subInst_r1(X,Y,Z),N),max_ab_lvl(M).

createSub(subInst_r1(Z,Y,Z),M-1)    :-createSub(subInst_r1(X,Y,Z),N),max_ab_lvl(M).

createSub(subInst_r1(X,Z,Z),M-1)    :-createSub(subInst_r1(X,Y,Z),N),max_ab_lvl(M).
\end{verbatim}

\section{Future and Related work, Conclusion}\label{sec:conclusion}
\section{Novelty Factor}
Integration of abductive reasoning and 'why not' explanations. I don't think why-not explanations have been implemented interms of abductive reasoning in the literature. Rather the approach is to compute De Morgan duals of rules. Check Schulz's survey paper and some other more recent work like xclingo. 
\begin{verbatim}
https://hal.archives-ouvertes.fr/hal-03032897/document

https://arxiv.org/pdf/2009.10242v1.pdf
\end{verbatim}
Advantage of this explanation method is that we get a lot more control over depth of explanation, we get a more 'complete' why not explanation, it cn take user-inputs into account. Get some form of minimality in explanations. All this seems to neccesitate a very generalized abductive framework like the one presented.

\section{Papers to read}
Survey of Explanation approaches - Schulz etc.

See section 3.6.4 eg: "For example, justification approaches where all derivation steps are included in the
justification, that is all approaches other than LABAS justifications, may struggle
with the succinctness when explaining a large logic program, as explanations grow
with longer derivations. In contrast, LABAS justifications are independent of the
derivation length. However, a large logic program may also comprise more dependencies on negative literals, thus increasing the size of LABAS justifications. More
generally, it is an open problem how to effectively deal with the growing size (as
well as the previously mentioned exponential number) of justifications" The paper also mentions dealing with variables as only a partially dealt with challenge, and also mentions delaling with disjunction in rule heads as a potential challenge. However our system can infact be easily adapted to deal with disjunctions. 

See LABAS website
\begin{verbatim}
http://labas-justification.herokuapp.com/Tutorial.html    
\end{verbatim}
"The only approach able to handle non-normal
logic programs, i.e. logic programs with disjunctive heads, is the causal justification
approach, which can also deal with nested expressions in the body."

Open ASP, Abduction - PA Bonnati\\
Abduction with side effects - LM Pereira etc.\\
Abduction over unbounded domains via ASP - PA Bonnati\\ - Involves a complex procedure to reduce an input program to a 'relevant' sub-program. Only works on so called 'finitary programs'. Doesn't seem to be any support for explanation optimization. Requires one to define abducible skolem symbols from before hand.

CIFF proof procedure - F Toni etc.\\
Combining open world Description Logic reasonong with closed world ASP - Ian Horrocks etc.\\
sCASP papers\\
Focussing Proofs\\
Prolog based prover ie. LeanTAP\\
PTTP - Prolog Technology Theorem Prover\\
Open answer set Programming (OASP)\\
Implementing
Probabilistic Abductive Logic Programming
with Constraint Handling Rules - Henning Christiansen\\
Modelling variations of First Order Horn Abduction with Answer Set Programming- P.Schuller - Seems very similar to what I'm doing but there is no notion of integer 'levels' in the abductive proof thus easy to get into infinite backward search. Also, it is not integrated with an explanation mechanism as it is here. Lastly substitution of values for uninterpreted skolem functions is not really done automatically but rather handled through explicit equality. However overall this paper comes very close to the work here and we would need to study that paper carefully. (See FWD-A encoding) (Done, see file with tests on the complete encoding)

\section{Extra Material}
\subsection{Counter-example to completeness when rules have existential variables in pre-conditions}
\begin{verbatim}
p(X):-q(X,Y,Z),r(X,Y,Z).
r(X,Y,Y):-q(X,Y,Y).
\end{verbatim}
query is p(john), and predicate r is given CWA. 

Then without some additional user-input like $q(john, v1,v1)$, no solution is generated. Possible solution is to allow different vbls in pre-con to get mapped to the same skolem vbls.

Counter example to completeness when skolemization and NAF is involved
\begin{verbatim}
a(X):-q(X,Y,Z),not p(X,Y).
p(X,Y):-q(X,Y,Z),not b(X).
b(X):-q(X,Y,Y).

%query is a(john), level = 1, CWA on a(X).
% Compare skolemized output
%q(john,v1,v2).
% Fully instantiated
q(john,james,james).    
\end{verbatim}

\subsection{Completeness table}
\begin{verbatim}
Ext vbs   Integrity Cnst     NAF   Comp
N              Y              Y      N
N              N              Y      Y
N              Y              N      Y
N              N.             N.     Y  
Y              Y.             N.     N 
Y              Y              Y.     N
Y              N              Y.     N 
Y              N              N.     N 
\end{verbatim}


\subsection{Expanding Proof Search Space for rules with Existential variables in pre-conditions}

Optional if user-inputed query is non ground:
\begin{verbatim}
 explains(postcon(X,Y),postcon(X,Y),N+1):-createSub(subInst_r1(X,Y,Z),_N).   
\end{verbatim}
(Warning: With these additions this whole thing becomes liable to massive state space explosions (including infinite models) and bounds on abduction level are mandatory. Do we always still get finite models once max abduction level is imposed?)

So for a rule involving $N$ variables, we get $N(N-1)$ extra $create\_sub$ rules. This is to allow distinct variables in the source ASP rules to get mapped to the same skolem expressions, during proof search, thus overcoming the counter-examples to the completeness of the procedure.

Consider the ASP rule set:
\begin{verbatim}
p(X):-q(X).
q(X):-r(X).
\end{verbatim}
Intuitively, there are 3 separate minimal sets of facts, that in conjunction with the rule set would lead to the entailment of the atom $p(bob)$. These are $\{r(bob)\}$, $\{q(bob)\}$ and $\{p(bob)\}$. Each of these fact sets gives rise to a proof of $p(bob)$ of reducing depth. We have:
\begin{mathpar}
      \inferrule* [Right=R2,width=8em,
leftskip=2em,rightskip=2em]
{\inferrule* [Right=R1,width=8em,
leftskip=2em,rightskip=2em]{Fact : r(bob)}{q(bob)}}
{p(bob)}
\end{mathpar}

\begin{mathpar}
      \inferrule* [Right=R1,width=8em,
leftskip=2em,rightskip=2em]
{\inferrule* {}{Fact : q(bob)}}
{p(bob)}
\end{mathpar}

$Fact : p(bob)$


\subsubsection{Invariance of satisfiability under variable re-naming}
Given an abduction task $T= \langle R,Q,U,C,N\rangle$  we say $T$ has the
$invariance$ property if the following holds: given any proof tree $P_{S}$ of
$T$, corresponding to an abductive solution $S$ of $T$, consider a map $M$ on
predicate arguments in $P_{S}$ where $M$ is injective, $M$ is the identity map
on predicate arguments that occur in $Q$, and on all other arguments, $M$ maps
to fresh terms not occuring elsewhere in the logic program. Then the abductive
solution $M(S)$ obtained under any such map $M$ must also be a solution to the
abductive task $T$. 


\subsection{Formal Setup}
\subsubsection{Finite Answer sets property}
Given a set of source ASP rule $R$ we say that $R$ has the Finite Answer Sets property if for any finite set of facts $F$, the ASP program for $R$ together with the facts in $F$, always has at least one answer set and furthermore only has finite answer sets.
 \subsubsection{Unique arguments in predicates}
We say that a rule set $R$ satisfies the $uniqueness$ $of$ $arguments$ property if none of the predicates occuring in a given rule contain repeated arguments. For example the rule:
$p(X,Y,Y)\rightarrow q(X)$ is not allowed but the rule: $p(X,Y,Z)\rightarrow q(X)$ is fine. 

\subsection{Completeness, Minimality and Finiteness of Proof generation}

\subsubsection{Valid task}
Given a task $T = \langle R,Q,U,C,N\rangle$ we say $T$ is valid if $R$ obeys the finite answer sets property and the uniqeness of arguments property, $N$ is finite and $U$, $C$ are finite sets. 

\subsubsection{Theorem - Finiteness of Proof generation}
Given a valid task $\langle R,Q,U,C,N\rangle$, $\langle R,Q,U,C,N>_{ASP}$ has only finite answer sets. 

\subsubsection{Theorem - Completeness and Minimality of Proof Generation}
$Thm$ Given a valid task $T= \langle R,Q,U,C,N\rangle$, assume $C$ is empty. Then $T$ has a solution $F$ if and only if $\langle R,Q,U,C,N>_{ASP}$ has an answer set $\mathcal{S}$ such that the set of $abducedFact$ predicates in $\mathcal{S}$ also is a solution to $\langle R,Q,U,C,N\rangle$. Furthermore the optimal answer set of $\langle R,Q,U,C,N>_{ASP}$ corresponds to a $minimal$ solution if the proof graph is filled in bottom up by the user. If $C$ is non-empty then do we still get completeness assuming $R$ does not contain $NAF$?

$Proof$
Given a valid task $T= \langle R,Q,U,C,N\rangle$, assume $C$ is empty but that $R$ may contain NAF Then $T$ has a solution $F$ if and only if $\langle R,Q,U,C,N>_{ASP}$ has an answer set $\mathcal{S}$ such that the set of $abducedFact$ predicates in $\mathcal{S}$ also is a solution to $\langle R,Q,U,C,N\rangle$. Furthermore the optimal answer set of $\langle R,Q,U,C,N>_{ASP}$ corresponds to a $minimal$ solution if the proof graph is filled in bottom up by the user.

$Proof$ Now assume that $\langle R,Q,U,C,N\rangle$ is such that neither $R$ nor $C$ contain NAF, but $Q$ is a NAF atom...

Now assume that $\langle R,Q,U,C,N\rangle$ is such that neither $R$ nor $C$ contain NAF, but $Q$ is a positive atom...

Now assume that $\langle R,Q,U,C,N\rangle$ is such that $R$ contains NAF but $C$ is empty...

We now give a counter example to completeness when we have both NAF in the rules and a non-empty set of integrity constraints.

\subsection{Coresspondence with Classical FOL Semantics for rule sets without Negation-as-Failure}

Given a task $\langle R,Q,U,C,\infty\rangle$, suppose that $R$ forms a definite logic
program. That is there is no form of negation in $R$. Consider the associated
classical first order theory $T_{<R,Q,U,C,\infty>}$ which is constructed as
follows: For every predicate in $C$, we make the rules for that predicate
definitional, via something like Clark Completion. Add to the theory the rest
of the rules in $R$ as they are. for every positive atom in $U$ we add it to
the theory and for every negative atom, we add its classical negation. Finally
we add either $Q$ or in case of a negative query we add its classical
negation. Then we have the following:

\subsubsection{Theorem - Correspondence with Classical FOL}
$\langle R,Q,U,C,\infty\rangle$ has a solution $F$ if and only if $T_{<R,Q,U,C,\infty>}$ has a model according to classical FOL semantics.


\section{Completeness for restricted class of problems}
For the completeness proof we make the following assumptions leaving an investigation of the general case for future work. Given $\langle R,q,U,C,N\rangle$ we make the following assumptions.

\begin{enumerate}
\item $R$ contains no negation as failure.
\item $C$ is empty.
\item The set of predicates which occur in user supplied facts in $U$ is
  disjoint from the set of predicates which are prevented from being used as
  abducibles
\item No post condition of any rule in $R$ contains repeated variables. For example the rule:
$p(X,X):-r(X,X,Y)$ is not allowed but the rule: $p(X,Y):-r(X,X,Y)$ is allowed.
\end{enumerate}

Note that that these conditions mean that without loss of generality, for the
sake of proving completeness, we may assume that the set of user supplied
facts is empty.

\subsection{Lemma}
Assume $\langle R,q,U,C,N\rangle$, $\langle R,q',U,C,N\rangle$ are two problems satisfying the conditions above but $q'$ is obtained from $q$ by possibly changing some or all of the arguments of $q$. Then $\langle R,q,U,C,N\rangle$ has a solution if and only if $\langle R,q',U,C,N\rangle$ does.

First we prove the lemma by induction on $N$.
The case $N = 0$ is trivial. If there exists a solution for $\langle R,q,U,\emptyset,0\rangle$ then any instance of the predicate in $q$ can be abduced therefore $\langle R,q',U,\emptyset,0\rangle$ has a solution. Assume the result for some $N = k$ such that $k>0$. A non trivial solution to $\langle R,q,U,\emptyset,k+1\rangle$ implies the existence of a solution to the following set of problems $\langle R,q_{pre_{i}},U,\emptyset,k\rangle$ where the set of $q_{pre_{i}}$ where the $q_{pre_{i}}$ are the set of pre-conditions of a rule $r$ in $R$, under some substitution $\theta$ where $\theta$ applied to the post-condition of $r$ gives $q$. But then since $r$ contains no repeated variables, if $q$ unifies with the post condition of $r$ under some substituion $\theta$, then there exists some other substitution $\theta'$ for the variables in $r$ such that $\theta'$ applied to the postcondition of $r$ gives $q'$. Therefore a solution to the set of problems $\langle R,q'_{pre_{i}},U,\emptyset,k\rangle$ is also a solution to $\langle R,q',U,\emptyset,k+1\rangle$ where each $q'_{pre_{i}}$ is obtained from $q'_{pre_{i}}$ by possibly changing the arguments in the predicate. By the induction hypothesis such a solution to the set of problems $\langle R,q'_{pre_{i}},U,\emptyset,k\rangle$. Hence a solution to  $\langle R,q,U,\emptyset,k+1\rangle$ exists. This proves the lemma.

\subsection{Proof of main theorem}
We now prove the main theorem by induction on $N$. That is we prove that if
there exists a general solution $S$ to $\langle R,q,U,\emptyset,N\rangle$ then there exists
a ASP solution $S_{ASP}$ to $\langle R,q,U,\emptyset,N\rangle$. We prove this by induction
on $N$. The case $N=0$ is trivial. Assume the result for some $N=k>0$. The
existence of a non-trivial general solution to $\langle R,q,U,\emptyset,k+1\rangle$ implies
the existence of a solution to the following set of problems,
$\langle R,q_{pre_{i}},U,\emptyset,k\rangle$ where the set of $q_{pre_{i}}$ where the
$q_{pre_{i}}$ are the set of pre-conditions of a rule $r$ in $R$, under some
substitution $\theta$ where $\theta$ applied to the post-condition of $r$
gives $q$. But then by the inductive hypothesis there is an ASP solution to
the same set of problems. By the lemma proved above there exists an ASP
solution to following set of problems $\langle R,q'_{pre_{i}},U,\emptyset,k\rangle$, where
each $q'_{pre_{i}}$ is obtained from the corresponding $q_{pre_{i}}$, by
possibly replacing some predicate arguments with the appropriate skolem terms
for predicate arguments that correspond to existential variables in the
preconditions of $r$. Hence there exists an ASP solution to
$\langle R,q,U,\emptyset,N\rangle$.

\section{Pf Idea}

$Proof:$ By induction on $N$. The case $N=0$ is trivial. The inductive case crucially uses property (2). $q'$ unifies with the post condition of a rule if and only if $q$ does.
The main theorem is now again proved using induction on $N$. The case $N=0$ is trivial and the inductive case uses the lemma above.

$Pf$ $idea$: General non-trivial solution at depth $N$ impliies general solution to conjunction of pre-conditions at depth $N-1$ with some substitution of existential variables.

By the inductive hypothesis, this implies ASP solution to conjunction of pre-conditions with that substitution at depth $N-1$.

By the lemma this implies ASP solution to conjunction of pre-conditiions where existential variables are replaced with skolem terms. 

This implies ASP solution to the original problem at depth $N$.


\section{Proof sketch of Completeness}

Assume $\langle R,q,U,C,N\rangle$ is as above but that $C$ is empty and the predicates ocurring in positive ground atoms in $U$ and integrity constraints in $U$ form disjoint sets. Furthermore for the completeness proof we make two further assumptions on $R$.

\begin{enumerate}
\item For any finite set of facts $F$, the set $(F,R)$ is never unsatisfiable.

\item For any rule $r$ in $R$, the postcondition of $r$ contains no repeated
  variables. For example the rule:
  
$p(X,X):-r(X,X,Y)$ is not allowed but the rule: $p(X,Y):-r(X,X,Y)$ is allowed.

\item None of the positive atoms user supplied facts in $U$ contain skolem terms

Then the proof search procedure is complete and furthermore we have proof simplification if the proof graph is filled from bottom up. Later we suggest a modification to the proof search encoding that allows 2) to be relaxed.
\end{enumerate}

Given a arbitrary solution $S$, to $\langle R,q,U,\emptyset,N\rangle$, let
$S$, $U_{f}$ be such that $S\cup U_{f}$ is subset minimal where $U_{f}$ is the
set of user supplied facts in $U$ we can obtain a solution $S'$ by constructed
from $S\cup U_{f}$, replacing all existential variables in $S$, $U_{f}$, by
the appropriate skolem terms. (This crucially makes use of property 2 above)
Then this solution $S'$ is a (possibly sub-optimal) solution to $\langle
R,q,U,\emptyset,N\rangle$ which lies in the solution space generated by the
ASP program.  (Note : if pf can't be made rigorous just restrict to rules
without NAF, which can be proved rigorously).

\subsection{Proof simplification}
Proof graph is simplified if filled from bottom up.

\section{Further novel functionalities}
Allows one to be more 'fine-grained' about what things are abducible and what are not eg:
\begin{verbatim}
:-abducedFact(p(john)).    
\end{verbatim}
Means that $p(john)$ is not abducible but any other instance of the predicate $p$ is.\\
\newline
The constraint:
\begin{verbatim}
:-abducedFact(p(X)),abducedFact(q(X,Y)).
\end{verbatim}
Means that both together cannot be abduced but either one on it's own may be. Can extend this sort of 'conditional abduction' further eg.
\begin{verbatim}
:- abducedFact(p(X)),holds(h(X,Y)).  
\end{verbatim}


let $abducedFact(f)$ be an element of some optimal ASP solution $S$ corresponding to an optimal answer set of the program $P_{<R,q,U,\emptyset,N>}^{Comp}$ such that $f$ is of the form $p_{i}(v_{1},v_{2},..v_{n})$. Suppose the atom $p_{i}(t_{1},t_{2},..t_{n})$ gets added to $U$, where each $t_{j} = v_{j}$ if $v_{j}$ was a non skolem term. Call this new set of user-inputs $U'$. Then the program $P_{<R,q,U',\emptyset,N>}^{Comp}$ has an answer set where the corresponding solution $S'$ is obtained from $S$ in the following way. Replace every occurrence of the term $v_{k}$ in the arguments of an abduced atom in $S$ with the term $t_{k}$, where $v_{k}$ is a skolem term. Then remove $p_{i}(t_{1},t_{2},..t_{n})$ itself from the resulting set.

To prove this we first need the notion of a $minimal$ $proof$ $graph$ corresponding to an optimal ASP solution $S$ of a given problem $\langle R,q,U,\emptyset,N\rangle$.

$\textit{Pf Idea}$ : Work with min proof graphs corresponding to min solns. Show by induction that filling any atom in the min pf graph at depth $k$ automatically causes any remaining abducibles to get filled. Start by proving $k=1$ case.

\section{Second pf attempt}
Suppose there exists an answer set $A$ of $P_{<R,q,U,\emptyset,N>}^{Comp}$ such that $query(p_{i}(v_{1},v_{2},..v_{n}),k)$, $query(p_{j}(w_{1},w_{2},..w_{m}),l)$ are in $A$ for some $0\leq k, l \leq N$. Then replacing the place-holder arguments in one induces an identical substitution of the same place-holder arguments in the other. Example:

If an answer set of the original problem has:
$query(p_{i}(a,var_{1},var_{2},c,var_{3}),k)$ and $query(p_{j}(h,var_{3},var_{1},o),l)$ then adding the fact $holds(p_{i}(a,e,y,c,k))$ means that there exists an answer set of the new problem such that $query(p_{j}(h,c,e,o),l)$ is in it. 

To prove this we will first need the following lemma.

\subsubsection{Lemma 1}
Given a fixed rule set $R$, integer $N$ and predicate $p_{i}$, consider $\langle R,q,U,\emptyset,N\rangle$, where $U$ is arbitrary and $q$ is some arbitrary instantiation of the predicate $p_{i}$. Then given any rule $r_{k}$ in $R$ and any answer-set $A$ of $P_{<R,q,U,\emptyset,N>}^{Comp}$, the set of integers $i$ such that $createSub(subInst\_r_{k}(...),i)$ appears in $A$ is exactly some fixed subset of the set $\{1,...,N\}$. Given an $r_{k}$ call this set the $\textit{occurence set}$ of $r_{k}$. Given a rule $r_{k}$ it's occurence set $O_{k}$ can be constructed inductively as follows:\\
$1 \in O_{k}$ if and only if the rule $r_{k}$ has the predicate $q$ as it's
post-condition. For any $i>1$ and any rule $r_{l}$ having post condition
predicate $p$, $i\in O_{l}$ if and only if there exists a rule $r_{f}$ such
that $r_{f}$ contains $i-1$ in it's occurence set and the predicate $p$ occurs
in the pre-conditions of $r_{f}$. Firstly note that condition (4) from the
previous section ensurest that any $query(p(...),g)$ gives rises to
$createSub(subInst\_r_{h}(...),g+1)$ where $g$ is less than $N-1$ and $p$ is
the predicate that is the post-condition of rule $r_{h}$. In particular it
does not matter what the arguments of $p$ in $query(p(...),g)$ actually
are. So this establishes that the occurence set of a rule $r_{f}$ does
actually contain all the integers that occur as a result of the inductive
construction. Next we explain why the occurence set cannot contain integers
other than those captured by the inductive definition above. Clearly proof
expansion rules of type E1, E2 cannot introduce new occurence levels. A-priori
the only concern maybe the rule E3,
\begin{verbatim}
query(Y,N-1):-explains(X,Y,N),0<N, N<M, max_ab_lvl(M)
    
\end{verbatim} 
which may introduce fresh $query$ atoms and thus add to the occurence levels of a rule. However any $explains$ atom comes from a rule of the form 
\begin{verbatim}
explains(relB(P, R), relA(P) ,_N) :- createSub(subInst_r1(P,R),_N).
\end{verbatim} 
so any for any fresh $query(Y,N-1)$ created due to E3, there was already another atom of the form $query(Y',N-1)$ present in the answer set where $Y$, $Y'$ are different instantiations of the same predicate. Therefore the rule E3 does not add to the occurence set of any rule in the original rule-set $R$. Therefore the occurence set is independent of $U$ and the arguments of $q$ in the original problem $\langle R,q,U,\emptyset,N\rangle$.

\subsubsection{Lemma 2}
Fix some term $T$ and consider ${<R,q,U,\emptyset,N>}$ where some predicate argument of $q$ is the term $T$. Then given some rule $r_{k}$ in $R$ if $j$ is in the occurence set of $r_{k}$ then in any answer set $A$
of $P_{<R,q,U,\emptyset,N>}^{Comp}$ there exists the atom $createSub(subInst\_r_{k}(T,T,...,T),j)$. 
\subsubsection{Proof of main theorem}
Given $query(p_{i}(a,var_{1},var_{2},c,var_{3}),k)$ and $query(p_{j}(h,var_{3},var_{1},o),l)$. The main theorem follows by induction on $k$, via the rule 
\begin{verbatim}
query(Y,N-1):-explains(X,Y,N),0<N, N<M, max_ab_lvl(M).   
\end{verbatim}
The case $k=0$ follows from Lemma 2 and re-write rules of the form 
\begin{verbatim}
createSub(subInst_r1(X1,Y2,Y3),N):-createSub(subInst_r1(Y1,Y2,Y3),N),
createSub(subInst_r1(X1,X2,X3),N).
createSub(subInst_r1(Y1,X2,Y3),N):-createSub(subInst_r1(Y1,Y2,Y3),N),
createSub(subInst_r1(X1,X2,X3),N).
createSub(subInst_r1(Y1,Y2,X3),N):-createSub(subInst_r1(Y1,Y2,Y3),N),
createSub(subInst_r1(X1,X2,X3),N).
\end{verbatim}

\section{Discusion of skolem term and place-holder term elimination}
An interesting avenue for further work is to identify a minimal set of proof-expansion rules necessary to achive a reasonable notion of skolem term/place-holder term elimination in minimal abductive solutions. For example what kind of term elimination properties are achieved when only proof expansion rules of the following kind are included:
\begin{verbatim}
createSub(subInst_r1(P,R),_N) :- createSub(subInst_r1(V_P,V_R),_N), holds(relB(P, R)).
createSub(subInst_r1(V_P,R),_N) :- createSub(subInst_r1(V_P,V_R),_N), holds(relD(R)).

createSub(subInst_r2(V_P,R),_N) :- createSub(subInst_r2(V_P,V_R),_N), holds(relA(R)).
createSub(subInst_r2(P,V_R),_N) :- createSub(subInst_r2(V_P,V_R),_N), holds(relC(P)).    
\end{verbatim}



We present a method for calculating possible proofs of a query with respect to a given Answer Set Programming (ASP) rule set using an abductive process where the space of abducibles is automatically constructed just from the input rules alone. Given a (possibly empty) set of user provided facts, our method is able to infer any additional facts that may be needed for the entailment of a query and then output the set of abducibles, all without the user needing to explicitly specify the space of all abducibles. We also present a method to generate a set of directed edges corresponding to the the justification graph for the query. Furthermore, through different forms of term substitution, our method is able to take user provided facts into account and adapt the proofs accordingly. Past work in implementing abductive reasoning systems has been primarily based on top-down execution methods with either Prolog or more recently, goal-directed ASP as the underlying engine. However goal directed methods may result in solvers that are not truly declarative. Much less work has been done on realizing abduction in a bottom up solver like Clingo. The work in this paper describes novel ASP programs which can be run directly in Clingo to yield the abductive solutions and directed edge sets without needing to modify the underlying solving engine. 

We present a method for calculating possible proofs of a query with respect to
a given Answer Set Programming (ASP) rule set using an abductive process where
the space of abducibles is automatically constructed just from the input rules
alone. Given a (possibly empty) set of user provided facts, our method is able
to infer any additional facts that may be needed for the entailment of a query
and then output the set of abducibles, without the user needing to explicitly
specify the space of all abducibles. We also present a method to generate a
set of directed edges corresponding to the the justification graph for the
query. Furthermore, through different forms of term substitution, our method
is able to take user provided facts into account and suitably modify the
abductive solutions. Past work on abduction has been primarily based on goal
directed methods. However these methods can result in solvers that are not
truly declarative. Much less work has been done on realizing abduction in a
bottom up solver like the Clingo ASP solver. We describe novel ASP programs
which can be run directly in Clingo to yield the abductive solutions and
directed edge sets without needing to modify the underlying solving engine.

Given a n -ary predicate $p_{i}$ consider the complete level $N$ proof graph of $p_{i}(v_{1},v_{2},...,v_{n})$. Now suppose that given some $\langle R,q,U,\emptyset,N\rangle$, where $q$ is some instantiation of the predicate $p_{i}$, there exists a an answer set $A$ of $P_{<R,q,U,\emptyset,N>}^{Comp}$ such that $A$ contains the complete proof level $N$ graph of $p_{i}(t_{1},t_{2},...,t_{n})$ for some set of terms  $T = t_{1},..,t_{n}$. (Here the $t_{j}s$ need not be distinct)

Define the map $\phi$ by $\phi(v_{k})= t_{k}$. It follows that the complete level $N$ proof graph  of $p_{i}(t_{1},t_{2},...,t_{n})$ can be obtained from the complete level $N$ proof graph of $p_{i}(v_{1},v_{2},...,v_{n})$ by applying the map $\phi$ to the corresponding atoms of the proof graph. (This is ensured by condition 4 above which ensures that unification with the post-condition of a rule can always happen) Now say $query(p_{j}(t_{d_{1}},...,t_{d_{f}}),k)$ occurs in the complete level $N$ proof graph of $p_{i}(t_{1},t_{2},...,t_{n})$ where clearly $k\leq N$.

Suppose now we add the atom $query(p_{j}(a_{1},...,a{f}),k)$ to the ASP program $P_{<R,q,U,\emptyset,N>}^{Comp}$. Recall that $v_{d_{s}}$ is the pre-image of $t_{d_{s}}$ under $\phi$. Now say there exists a map $\psi$ mapping each $v_{d_{c}}$ to the corresponding $a_{c}$. Such a map may not always exist for example if it forces the map to be one - to - many)

Then there exists an answer set $A'$ of $P_{<R,q,U,\emptyset,N>}^{Comp}$ such that $A'$ contains the complete level $N$ proof graph for $p_{i}(b_{1},b_{2},...,b_{n})$, where each $b_{i}$ is the image of $v_{i}$ under the map $\phi'$ where $\phi'$ is defined as follows: for some $v_{g}$ if it is the pre-image of some $t_{d_{l}}$ then $\phi'$ of $v_{g}$ is $\psi(v_{g})$, otherwise $\phi'(v_{g}) = \phi(v_{g})= t_{g}$.

$\textit{Proof}$ First note that an answer set contains the complete level $N$ proof graph for $p_{i}(b_{1},b_{2},...,b_{n})$ if and only if it contains the atom $query(p_{i}(b_{1},b_{2},...,b_{n}),0)$. We will now prove this result by induction on $k$, the second argument of the atom $query(p_{j}(a_{1},...,a{f}),k)$. Firstly note that if $k = 0$ then $p_{j} = p_{i}$ and the map $\phi'$ is given by $\phi'(v_{i}) = a_{i}$. This establishes the result for $k=0$.  Say the result is true for all $k\leq o$, where $o<N$. Now say the complete level $N$ proof graph of $p_{i}(t_{1},t_{2},...,t_{n})$ contains the atom $query(p_{z}(t_{w_{1}},t_{w_{2}},..,t_{w_{r}}),o+1)$, and we add the atom $query(p_{z}(h_{1},h_{2},..,h_{r}),o+1)$ to the ASP program. Also suppose there exists the appropriate map $\psi$ from the pre-images of the $t_{w_{i}}s$ under $\phi$ to the corresponding $h_{i}s$. Then there exists a rule $r_{c}$ such that $p_{z}(t_{w_{1}},t_{w_{2}},..,t_{w_{r}})$ is a pre-condition of some appropriate instantiation of $r_{c}$ in the proof graph. Therefore there exists an atom of the form $create\_sub(subInst\_r_{c}(W),o+1)$ where $W$ is a tuple made up of variables in the instantiation of $r_{c}$ and $W$ is obtained by applying the map $\phi$ to the corresponding $create\_sub$ atom in the proof graph of $p_{i}(v_{1},v_{2},...,v_{n})$. Now a proof search expansion rule of the form E7 is instantiated. Specifically we get the following instantiation 
\begin{verbatim}
createSub(subInst_r_c(W'),o+1) :- createSub(subInst_r_c(W),o+1), query(p_z(h1,h2,..,hr),o+1),
max_ab_lvl(M).
\end{verbatim}

Here $W$ is as above and $W'$ is now given by the image of the tuple $I$ under
the appropriate map $\phi'$ where $I$ is the pre-image of $W$ under $\phi$ and
$\phi'$ is the map constructed from the maps $\phi$ and $\psi$ as described
before. Now say in the original proof graph for
$p_{i}(t_{1},t_{2},...,t_{n})$, the atom
$query(p_{u}(t_{h_{1}},t_{h_{2}},...t_{h_{q}}),o)$ corresponds to the post
condition of the particular instantiation of $r_{c}$ due to which
$query(p_{z}(t_{w_{1}},t_{w_{2}},..,t_{w_{r}}),o+1)$ occurs in the proof
graph. Note that because no rule in $R$ has existential variables in
pre-conditions, it must be the case that
$\{t_{w_{1}},...,t_{w_{r}}\}\subseteq\{t_{h_{1}},...,t_{h_{q}}\}$. Now because
of ASP rules of the form $query(...):-createSub(...)$ and the rule
\begin{verbatim}
query(Y,N-1):-explains(X,Y,N),0<N, N<M, max_ab_lvl(M).    
\end{verbatim}

There exists an atom $query(p_{u}(x_{1},x_{2},..,x_{q}),o)$ in the ASP program
where each $x_{i}$ is given by applying the map $\phi'$ from above on the
pre-image of the corresponding $t_{h_{i}}$ under $\phi$. So by the inductive
hypothesis we are done.


Proof strategy: Induction on $k$
\begin{enumerate}
    \item Prove result for $k =0 $
    \item Let $[t_{1},t_{2},..,t_{j}]$,$[a_{1},a_{2},...,a_{j}]$ be such that if $t_{x}\neq a_{x}$, then $e_{x}$ first appears in $G_{R,p,n}$ inside a $query$ atom whose integer argument is $k$.
    \item Prove general result by showing that $query(p_{i}(a_{1},a_{2},..,a_{j}),k)$ generates a $query$ atom with integer $k-1$, which also induces the same substitution except possibly for those $a_{m}s$ which refer to existential vars. So this allows us to use (2), and inductive hyp. for $k-1$ $query$ atom.
\end{enumerate}


%\bibliographystyle{alpha}
\bibliographystyle{ACM-Reference-Format}
\bibliography{main}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
