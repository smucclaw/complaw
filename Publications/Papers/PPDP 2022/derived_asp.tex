\section{Derived ASP Programs}\label{sec:derived_asp}
\subsection{A First Example}
Before we give the details of the main sets of rule translations that allow
abductive reasoning and justification generation, here is a simple example to
illustrate some key ideas and what the desired output for an abductive problem
is. Consider the rule set $R$ given by the 3 rules
\begin{lstlisting}[frame=none]
p(X,Y):-q(X,Y),s(Y).
p(X,Y):-g(X,Y).
d(X,Y):-g(X,Y).
\end{lstlisting}
Now let $q$ be $p(john,james)$, let $U$ consist of the user provided fact
$r(john)$ and let $U$ also include the constraint on abducibles $:-p(X,Y)$
meaning that no instance of the predicate $p$ may be abduced. Next let the set
$C$ contain the single constraint $:-d(X,Y)$ meaning that we require a stable
model of the user given facts, the abducibles, and the rules, which does not
contain any instance of the predicate $d$, finally let $N = 2$. Then for this
problem the minimal abductive solution can be represented by
\textit{abducedFact(q(john,james)), abducedFact(s(james))}, which is what we
want to get out of our encoding. Intuitively, the way we will solve this
abductive reasoning problem is by first encoding the input rules such as the
ones above in the usual forward direction. Then we will have a representation which
corresponds to 'reversing' the rules, \ie we go from post-conditions to
pre-conditions. These 'reveresed' rules
generate a maximal space of abducibles which then feed into the forward rule
translation. Finally we will have integrity constraints that ensure that the
atom which we want to be true (represented by $q$) is indeed entailed by the
abductive solution. An adapted version of this 'reversed rule' representation
also enables us to generate a set of directed edges corresponding to a
justification graph. The technical challenge in this process comes from
finding a way to deal with existential variables and the depth of abducible generation.

\subsection{Input Rule translations}

\subsubsection{Forward Translation}
Given an input ASP rule 
\begin{lstlisting}[frame=none]
pre_con_1(V1),pre_con_2(V2),...,pre_con(Vk),
   not pre_con(Vk+1),...,not pre_con_n(Vn) -> post_con(V).
\end{lstlisting}
we translate it in the following way:
\begin{lstlisting}[frame=none]
holds(post_con(V)):-holds(pre_con(V1)),...,holds(pre_con(Vk)), not holds(pre_con(Vk+1)), ..., not holds(pre_con(Vn)). 
\end{lstlisting}

We repeat this for each source ASP rule. For each constraint in $C$, we simply
enclose each atom in the constraint inside the $holds$ predicate. For example
if $C$ contains the constraint $:-b(X,Y).$, (meaning that we require an
abductive solution such that the there exists a stable model of the abduced
facts, rules and user provided facts, which contains no instantiations of the
predicate $b$), we encode that constraint as: 
\begin{lstlisting}[frame=none]
:-holds(b(X,Y)).
\end{lstlisting}

\subsubsection{Generating Abducibles}
Before diving into the details of the abducibles generation encoding let us give a brief intuition for some key meta-predicates and rules that will show up. Firstly the binary meta-predicate $query$ has as its first argument an atom which may become a candidate for abduction and as its second argument an integer corresponding roughly to the depth level of that atom with respect to $(R,q)$. Next the meta predicate $explains$ has as its first argument, an atom which forms a pre-condition of some input rule instantiation, and as its second argument the corresponding input rule instantiation post condition. The third argument of the $explains$ meta predicate carries the depth of the atom in the first argument. The final key meta-predicate is $createSub$. $createSub$ carries information about input rule instantiations. The first argument of $createSub$ is a tuple which carries generated rule instantiations of a particular rule via the instantiations of the variables in the rule in some fixed order, the second argument of $createSub$ is again a integer depth parameter. Let us now explain the general structure of some of the rules in the abducibles generation encoding to illustrate the purpose of these meta predicates. Firstly we have abduction generation rules with the structure:
\begin{lstlisting}[frame=none]
createSub(...,N+1):-query(...,N),N<M,max_ab_lvl(M).
\end{lstlisting}
Intuitively in this rule, the first argument of the $query$ meta-predicate generates an instantiation of an input rule where that atom is the post-condition of the rule. Skolem terms are used for rules with existential variables in pre-conditions. Then we have abducible generation rules with the structure:
\begin{lstlisting}[frame=none]
explains(...,N):-createSub(...,N).
\end{lstlisting}
Here a given $createSub$ atom generates an $explains$ atom where the first argument of the $explains$ atom carries an input rule pre-condition given by the rule instantiation corresponding to the $createSub$ atom and the second argument of the $explains$ atom is the instantiation of the rule post-condition. Next we have abducible generation rules with the structure:
\begin{lstlisting}[frame=none]
query(...):-explains(...).
\end{lstlisting}
Here the first two arguments of the $explains$ meta predicate, get passed on to generate two instances of the $query$ meta predicate. One can see from this that intuitively, a given $query$ atom that carries an input rule post-condition generates a $createSub$ atom that carries an input rule instantiation. This then generates an $explains$ atom whose left hand side argument is a rule pre-condition which then generates a new $query$ atom. This is the central part of the backward chaining process. The choice rule
\begin{lstlisting}[frame=none]
{abducedFact(X)}:-query(X,N).
\end{lstlisting}
Then produces the abducibles. Next we will describe the general structure of two kinds of rules which are key to enable a notion of term substitution where user-input is taken into account to simplify the generated abductive proof. First we have 
\begin{lstlisting}[frame=none]
createSub(...):-createSub(...),holds(...).
\end{lstlisting} 
and next we have 
\begin{lstlisting}[frame=none]
createSub(...):-createSub(...),query(...).
\end{lstlisting}
In the first kind of rule, arguments of $holds$ atoms can 'combine' with instances of the $createSub$ meta-predicate to yeild new instances of $createSub$. The intuition here is that if a certain instance of an input rule precondition/postcondition has  been established via the $holds$ predicate then this creates new substitutions for variables in that input rule which then leads to other input rule preconditions given by that substitution being included in the space of generated abducibles. The same intuition applies for abducible generation rules of the second kind, where instances of the $query$ predicate create new input rule substitutions. It turns out that constructing these abducible generation rules in a 'naive' way can lead to infinite answer sets, when there are skolem terms involved, even when the integer depth argument of all these meta-predicates is bounded. Hence we have different encodings for when there are skolem terms involved versus when there no skolem terms involved. Let us now get into the technical details of how these rules are constructed. First we will need a way to assign appropriate skolem terms to existential variables in pre-conditions. Given some rule in our rule set, say rule $r_{j}$, We fix some order
$O_{{j}}$ on the variables occuring in the combined set of variables from
the post and pre-conditions of the rule $r_{j}$. Now we will describe a
skolemization map that assigns an existential variable in a pre-condition of
$r_{j}$ to a skolem term. Firstly, let the rule $r_{j}$ carry unique integer
id $j$. Let $v$ be a variable that occurs in some rule precondition but not
the post condition. Then under this skolemization map, the variable $v$ gets
mapped to
\begin{lstlisting}[frame=none]
skolemFn_j_v_(V)    
\end{lstlisting}
where $V$ denotes the variables in the post-condition occuring in the order inherited from $O_{r_{j}}$. For example consider the rule $r_{1}$: 
\begin{lstlisting}[frame=none]
p(Y,X):- q(X),r(X,Y),s(Z).    
\end{lstlisting} 
Assume that this rule carries integer id $1$. Let $O_{1}$ be $[X,Y,Z]$. Then
the variable $Z$ gets mapped to the skolem term $skolemFn\_1\_Z(X,Y)$.

\subsubsection{AG1}
Given an input ASP rule $r$ in $R$
\begin{lstlisting}[frame=none]
pre_con_1(V1),pre_con_2(V2),...,pre_con(Vk),not pre_con(Vk+1),...,not pre_con_n(Vn) -> post_con(V).
\end{lstlisting}
our first set of translated abducible generation rules $AG1$ is given by the following. 
\begin{lstlisting}[frame=none]
create_subs(sub_Inst_j((V_sk),N+1):-query(post_con(V),N),max_ab_lvl(M), N<M-1.
\end{lstlisting}
Here $V_{sk}$, denotes the ordered list $O_{j}$ but with existential variables replaced by their skolem term counter parts. Here $j$ is the integer id for the rule. The integer $M=N+1$, where $N$ is the fifth entry of the tuple representing the abduction task, which represents the maximum depth of an abducible.
Next we have the following rules:
\begin{lstlisting}[frame=none]
explains(pre_con_1(V1),post_con(V),N):-create_subs(sub_Inst_t((V),N).
explains(pre_con_2(V2),post_con(V),N):-create_subs(sub_Inst_t((V),N).
...
explains(pre_con_n(Vn),post_con(V),N):-create_subs(sub_Inst_t((V),N).
\end{lstlisting}
Here $V$ denotes all the variables occuring in the rule in the order $O_{j}$.
\subsubsection{AG2}
Now we shall construct the second set
of abducible generating rules $AG2$. Given $O_{j}$ construct $F_{j}$ be adjoining the character
$V\_$ to each entry of $O_{j}$. So for our example above $F_{1}$ becomes
$[V\_X,$ $V\_Y,V\_Z]$. Given a pre-condition $p$
occurring in rule $r$ with id $j$, $M_{r,p}$ is an ordered list constructed as follows. The
$i_{th}$ element of $M_{r,p}$ is the $i_{th}$ element of $O_{j}$ if the
$i_{th}$ element of $O_{j}$ is a variable which occurs in $p$. Otherwise, the
$i_{th}$ element of $M_{r,p}$ is given by the $i_{th}$ element of $F_{r}$. Now
for each negated or positive precondition $p$ we have the following rule:
\begin{lstlisting}[frame=none]
 create_subs(sub_Inst_t(M_(r,p)),M-1):-create_subs(sub_Inst_t(F_r),N),
                       holds(p),max_ab_lvl(M), N<M.   
\end{lstlisting}
Repeat this for each pre-condition. This is the set of rules $AG2$.

%\remms{\texttt{max\_ab\_lvl} should be motivated}

\subsubsection{AG3}
Finally $AG3$ consists of just the single rule:
\begin{lstlisting}[frame=none]
query(X,N):-explains(X,Y,N),max_ab_lvl(M),N<M.
\end{lstlisting}
Let us consider another example.
Consider the input ASP rule:
\begin{verbatim}
a(X):- b(X,Y,Z), not c(X), not d(Y) .    
\end{verbatim}
Say this rule $r$ has rule id $5$. 
Let $O_{5}$ be $[X,Y,Z]$. Here the encoding for the rule $AG1$ is:
\begin{lstlisting}[frame=none]
create_subs(subs_Inst_5(X,skolemFn_5_Y(X),skolemFn_5_Z(X)),N+1):-
   query(a(X),N),max_ab_lvl(M),N<M-1.

explains(b(X,Y,Z),a(X),N):-create_subs(subs_Inst_5(X,Y,Z),N).

explains(c(X),a(X),N):-create_subs(subs_Inst_5(X,Y,Z),N).

explains(d(Y),a(X),N):-create_subs(subs_Inst_5(X,Y,Z),N).
\end{lstlisting}
AG2 is given by:

\begin{lstlisting}[frame=none]
create_subs(subs_Inst_5(X,Y,Z),M-1):-
     create_subs(subs_Inst_5(V_X,V_Y,V_Z),N), 
     holds(b(X,Y,Z)),max_ab_lvl(M),N<M.

create_subs(subs_Inst_5(X,V_Y,V_Z),M-1):-
create_subs(subs_Inst_5(V_X,V_Y,V_Z),N), holds(c(X)),max_ab_lvl(M),N<M.

create_subs(subs_Inst_5(V_X,Y,V_Z),M-1):-
create_subs(subs_Inst_5(V_X,V_Y,V_Z),N), holds(d(Y)),max_ab_lvl(M),N<M.
\end{lstlisting}

\subsubsection{Supporting code for Abduction} 
Given the original problem $\langle R,q,U,C,N\rangle$, set $M=N+1$. Then we have the following: 
\begin{verbatim}
max_ab_lvl(M).
query(Q,0):-generate_proof(Q).
{abducedFact(X)}:-query(X,M).
holds(X):-abducedFact(X).

holds(X):-user_input(pos,X).
\end{verbatim}
For any predicate $p$, say of arity $n$ such that no instance of $p$ may be abduced, we add the constraint.
\begin{verbatim} 
:-abducedFact(p(X1,X2,...,Xn)).
\end{verbatim}
If instead only a specific ground instance of $p$ or a partially ground instance of $p$ should be prevented from being abduced then we simply adapt the above constraint accordingly. For instance if $p$ is a binary predicate and we want that no instance of $p$ where the first argument is $alpha$ should be abduced we have the constraint
\begin{verbatim} 
:-abducedFact(p(alpha,X)).
\end{verbatim}
Next we add the following $weak$ constraint so that in the optimal abductive
solution as few abducibles as possible are used.
%\remms{what does $[1@1,X]$ mean?}
\begin{verbatim} 
:~abducedFact(X).[1@1,X]
\end{verbatim}

\subsubsection{Specifying the goal}
Here is the code to encode the goal of the abductive reasoning process represented by the parameter $q$. If q is a ground atom say $p(a1,a2..,an)$ for some predicate $p$ then we
have:
%\remms{\texttt{-: not goal} needs some explanation.}
\begin{lstlisting}[frame=none]
generate_proof(p(a1,a2,...,an)).
goal:-holds(p(a1,a2,..,an)).
:- not goal.
\end{lstlisting}
If on the other hand $q$ is non-ground or only partially ground then we have the following. Say our goal is of the form $p(a,X,b,Y,Y)$, which means that $X$,$Y$ are existential variables. Then for the example we have the following:
\begin{lstlisting}[frame=none]
generate_proof(p(a,v1,b,v2,v2)).
goal:-holds(p(a,X,b,Y,Y)).
:- not goal.
\end{lstlisting}
Here $v1$, $v2$ are fresh constants. If $q$ is a ground NAF atom say $\textit{not p}$ then we simply write 
\begin{lstlisting}[frame=none]
generate_proof(p).
goal:-not holds(p).
:- not goal.
\end{lstlisting}
Given $\langle R,q,U,C,N \rangle$ let the complete derived ASP program that uses $AG1$, $AG2$, $AG3$, the supporting code and the forward translation be called $P^{res}_<R,q,U,C,N>$. We will now give a modified abduction generation encoding which can be used when no rule in $R$ contains an existential variable. As mentioned before, it turns out that using this modified encoding on rules that have existential variables can lead to infinite answer sets. After giving this modified encoding we will explain in detail the encodings with the aid of an example. 
\subsection{Extending abduction generation space for rules without existential variables}
When we have rules without existential variables, we can construct a larger
space of abducibles without worrying about our ASP programs having infinite
answer sets because there are now no skolem expressions. The encoding $AG1$ is
the same as before but now clearly there will be no skolem terms. The new
version of $AG2$ which we shall call $AG2_{exp}$ now becomes for each rule 
\begin{lstlisting}[frame=none]
create_subs(sub_Inst_t(M_(r,p)),N):-
   create_subs(sub_Inst_t(F_r),N),holds(p).   
\end{lstlisting}
Notice that as opposed to the previous encoding, here the integer argument of the $createSub$ predicate on the left hand side is $N$ as opposed to $M-1$. Repeat this for each pre-condition $p$. Then for the post-condition of the rule $p'$, we have:
\begin{lstlisting}[frame=none]
create_subs(sub_Inst_t(M_(r,p')),N):-
   create_subs(sub_Inst_t(F_r),N),holds(p').   
\end{lstlisting}
 
Here $M_{r,p'}$ is defined exactly the same way as $M_{r,p}$ for some pre-condition $p$. Next, for each rule and for each pre-condition $p$ in the rule we have.
\begin{lstlisting}[frame=none]
create_subs(sub_Inst_t(M_(r,p)),N):-
   create_subs(sub_Inst_t(F_r),N),query(p,L).   
\end{lstlisting}

For the post-condition $p'$ we have:
\begin{lstlisting}[frame=none]
create_subs(sub_Inst_t(M_(r,p')),N):-
   create_subs(sub_Inst_t(F_r),N),query(p',L).   
\end{lstlisting}

This completes the encoding $AG2_{exp}$. The adapted version of $AG3$,
$AG3_{exp}$, is given by adding to $AG3$ one extra rule. So $AG3_{exp}$ is: 
\begin{lstlisting}[frame=none]
query(X,N):-explains(X,Y,N),max_ab_lvl(M),N<M.
query(Y,N-1):-explains(X,Y,N),max_ab_lvl(M),0<N,N<M.
\end{lstlisting}
Given $\langle R,q,U,C,N \rangle$ let the complete ASP program that uses $AG1_{exp}$, $AG2_{exp}, AG3_{exp}$, the supporting code and the forward translation be called $P_{<R,q,U,C,N>}^{exp}$
\subsection{Discussion of Abduction space generation}

\subsubsection{Full term substitution}
We first give an example of the expanded abduction space encoding to explain
the intuition behind various parts of the encoding. Consider the rule set
below that has no existential variables but which has negation as failure and
where the goal is un-ground.
\begin{lstlisting}[frame=none]
relA(X,Y):-relB(X,Y), relD(Y), not relE(Y).
relE(Y):-relD(Y), not relF(Y).
\end{lstlisting}
Let the goal $q$ be $relA(P,R)$, where $P$,$R$ are un-ground existential
variables. Next suppose that the only constraint on abducibles is that no
instantiation of $relA$ can be abduced and further suppose that the set of
user provided facts is initially empty. Finally let $N=4$. Here is the
complete encoding for this problem.

\begin{lstlisting}[numbers=left]
max_ab_lvl(5).
% Encoding the goal
generate_proof(relA(v1,v2)).
query(X,0):-generate_proof(X).
goal:-holds(relA(P,R)).
:- not goal.

% forward translation
holds(relA(X,Y)) :- holds(relB(X, Y)),holds(relD(Y)), not holds(relE(Y)).
holds(relE(Y)) :- holds(relD(Y)), not holds(relF(Y)).

% AG1_exp
createSub(subInst_r1(X,Y),N+1) :- query(relA(X,Y),N),max_ab_lvl(M),N<M-1. (* \label{abdInstR1} *)
createSub(subInst_r2(Y),N+1) :- query(relE(Y) ,N),max_ab_lvl(M),N<M-1. (* \label{abdInstR2} *)

explains(relB(X, Y), relA(X,Y) ,N) :- createSub(subInst_r1(X,Y),N). (* \label{abdExplR1start} *)
explains(relD(Y), relA(X,Y) ,N) :- createSub(subInst_r1(X,Y),N).
explains(relE(Y), relA(X,Y) ,N) :- createSub(subInst_r1(X,Y),N). (* \label{abdExplR1end} *)


explains(relD(Y), relE(Y) ,N) :- createSub(subInst_r2(Y),N). (* \label{abdExplR2start} *)
explains(relF(Y), relE(Y) ,N) :- createSub(subInst_r2(Y),N). (* \label{abdExplR2end} *)


% AG2_exp for rule 1

createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), holds(relA(X,Y)).
createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), holds(relB(X,Y)).
createSub(subInst_r1(V_X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), holds(relD(Y)).
createSub(subInst_r1(V_X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), holds(relE(Y)).

createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), query(relA(X,Y),L).
createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), query(relB(X,Y),L).
createSub(subInst_r1(V_X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), query(relD(Y),L).
createSub(subInst_r1(V_X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), query(relE(Y),L).

% AG2_exp for rule 2

createSub(subInst_r2(Y),N) :- createSub(subInst_r2(V_Y),N), holds(relE(Y)).
createSub(subInst_r2(Y),N) :- createSub(subInst_r2(V_Y),N), holds(relD(Y)).
createSub(subInst_r2(Y),N) :- createSub(subInst_r2(V_Y),N), holds(relF(Y)).


createSub(subInst_r2(Y),N) :- createSub(subInst_r2(V_Y),N), query(relE(Y),L).
createSub(subInst_r2(Y),N) :- createSub(subInst_r2(V_Y),N), query(relD(Y),L).
createSub(subInst_r2(Y),N) :- createSub(subInst_r2(V_Y),N), query(relF(Y),L).

% AG3_exp
query(X,N):-explains(X,Y,N),max_ab_lvl(M),N<M.(* \label{abdQuery} *)
query(Y,N-1):-explains(X,Y,N),max_ab_lvl(M),N<M,0<N.(* \label{abdAbdHold} *)

% Supporting code
{abducedFact(X)}:-query(X,N).  (* \label{abdChoice} *)
holds(X):-abducedFact(X).      (* \label{abdHoldsAbduced} *)
holds(X):-user_input(pos,X).   (* \label{abdHoldsUI} *)


:~abducedFact(Y).[1@1,Y]    (* \label{abdAbducedFact} *)
:-abducedFact(relA(X,Y)).

\end{lstlisting}



We will now discuss various parts of the encoding.

As mentioned earlier, the general idea is to recursively generate a
maximal space of abducibles by 'reversing' the rules and then checking via the
Forward Translation and encoding of the goal, which abducibles are needed
for entailment of the original query. More specifically in line with the intuitive discussion from before, any atom
of the form $query(h,i)$ generates an input rule instantiation where $h$ is
the post-condition that particular rule instantiation. Such rule
instantiations are represented by the $createSub$ atom. In the example above,
this is done via lines \ref{abdInstR1}, \ref{abdInstR2} of the encoding. Line \ref{abdInstR1} corresponds to
instantiations of rule 1 and line \ref{abdInstR2} corresponds to instantiations of rule
2. Then any such $createSub$ atom, generates the appropriate set of $explains$
atoms. This is lines \ref{abdExplR1start}-\ref{abdExplR1end} for rule 1 in the example, and lines \ref{abdExplR2start}, \ref{abdExplR2end} for
rule 2. The first argument of an $explains$ atom is a pre-condition of body
atom corresponding to the rule instantiation given by the $createSub$
atom. The second argument is post-condition or head of the rule
instantiation. We have one such $explains$ atom for each rule
pre-condition. Via line \ref{abdQuery}, the first argument of an $explains$ atom becomes
the first argument of a $query$ atom. This new $query$ atom then recursively
generates more $query$ atoms via the process described. Any $query$ atom
corresponds to a candidate for abduction via the choice rule in line \ref{abdChoice}. Any
fact which is abduced must hold due to line \ref{abdHoldsAbduced}. At this point, before moving
ahead let us first briefly comment further upon the integer arguments occuring in the
$explains$, $createSub$ and $query$ atoms.

The integer parameter roughly
represents the depth of an abducible in the proof graph of the original
query. When a $query$ atom carrying the post-condition of a rule generates a
rule instantiation like in line \ref{abdInstR1} for example, the integer argument of the
corresponding $createSub$ atom increases by one. Then an explains $atoms$
derived from the application of a rule like line \ref{abdExplR1start} retains the same integer
argument and so does the corresponding fresh $query$ atom generated from the
application of the rule on line \ref{abdQuery}. Note that a fresh $query$ atom can only be
created from an $explains$ atom if the integer parameter of the $explains$
atom is less than $M$. The use of these integer parameters is important
when we need skolem functions/terms in our abducible generation encoding due
to having rules with existentially quantified variables in pre-conditions. The
use of these integer parameters allows us to control the depth of the
abducible generating space thus preventing infinite answer sets even in the
presence of skolem functions. We will discuss this more later on. For now let
us turn our attention to some of the other parts of the encoding. The
$AG2_{exp}$ encoding enables a notion of implicit term substitution
in (minimal) abductive solutions. This set of rules creates new instantiations
of the input rules based on which other atoms are true. As stated earlier, creating new instantiations of the core input rules via the $createSub$ atoms, then allows
new abducibles to be added to the generated space of abducibles. Let us
illustrate some of these ideas with an example. Upon running the above ASP
program as the optimal solution given by the solver is: 

\begin{lstlisting}[frame=none]
abducedFact(relD(v2)) 
abducedFact(relB(v1,v2)) 
abducedFact(relF(v2))    
\end{lstlisting}
Now if $relB(john,james)$ is added to the set of user provided facts then firstly, due to line \ref{abdHoldsUI} $holds(relB(john,james))$ becomes true. Then we have the following instantiation of line 28.
\begin{lstlisting}[frame=none]
createSub(subInst_r1(john,james),1):-
   createSub(subInst_r1(v1,v2),1),holds(relB(john,james)). 
\end{lstlisting}
Hence due to lines \ref{abdExplR1start} and \ref{abdAbdHold}, the atom
$query(relA(john,james),0)$ becomes true. This leads to the atoms
$query(relD(james),1)$ and $query(relF(james),2)$ becoming true. Hence the atoms $relD(james)$ and $relF(james)$ become part of the space of abducibles and the solver gives us the new optimal solution:
\begin{lstlisting}[frame=none]
abducedFact(relD(james)) 
abducedFact(relF(james)) 
\end{lstlisting}
On the other hand if we instead add the fact $relF(mary)$ to the initially empty set of user provided facts then we get the follwing instantiation of line 41:
\begin{lstlisting}[frame=none]
createSub(subInst_r2(v2),2):-createSub(subInst_r2(v2),2),
holds(relF(mary)).
\end{lstlisting}
Hence the atom $createSub(subInst\_r2(mary),2)$ becomes true. Via line 22, and line \ref{abdAbdHold} the atom $query(relE(mary),1)$ becomes true. We thus get the following instantiation of line 35:
\begin{lstlisting}[frame=none]
createSub(subInst_r1(v1,mary),1):- createSub(subInst_r1(v1,v2),1), query(relE(mary),1).   
\end{lstlisting}
Thus the atom $createSub(subInst\_r1(v1,mary),1)$ becomes true, which then via say line \ref{abdExplR1start} and line \ref{abdAbdHold} causes the atom\\ 
$query(relA(v1,mary),0)$ to become true. Now, because of\\ $query(relA(v1,mary),0)$, 
$relD(mary)$, $relB(v1,mary)$ become part of the space of abducibles and the solver gives us the optimal abductive solution: 
\begin{lstlisting}[frame=none]
abducedFact(relD(mary)) 
abducedFact(relB(v1,mary))
\end{lstlisting}
and a similar result is obtained if we add an instance of the predicate $relD$
to the initially empty set of user provided facts. Thus with this encoding we
have full implicit term substitution. The place holder or 'dummy' variables
$v1$, $v2$, always get replaced away in the optimal abductive solution based
on the user provided facts.
%\remms{But one can still get an abduced fact containing a Skolem function?} 
A subtle point here is that there is no notion of
equality between terms. We are not setting $v2 = mary$. We are instead
enlarging the space of abducibles in a systematic way based on user provided
facts so that a more optimal solution which involves replacing the term $v2$
for the term $mary$ can be realized. Note that adding an 'unrelated' fact such
as say $relG(mary)$ will not enlarge the space of abducibles in any way. So in
some sense what we have is a method to enlarge the space of abducibles in an
'economical' way while still supporting a notion of term substitution. We will
formulate and prove a formal result regarding this notion of term substitution
later on.

\subsubsection{Partial term substitution}

When skolem terms/function are used to handle existential variables, we have
to use the non- expanded abducible generation encoding which forces us to give
up on complete term substituion.  This is because having the complete term
substitution mechanism can result in programs that have infinitely large
abducible spaces. To recover finiteness of the space of the abducibles we have
to forgo full term substitution. What we get instead is a kind of partial term
substitution mechanism where skolem terms may only sometimes be substituted
for user provided terms.  First let us examine why in the presence of skolem
functions, even a subset of the expanded abduction generation encoding can
lead to infinite answer sets.

Consider the rule set consisting of just the single rule 
\begin{verbatim}
relA(X):-relB(X,Y),relA(Y).
\end{verbatim}

Suppose the goal is $a(john)$
Consider the encoding below, which is a subset of the expanded abducible generation encoding.
\begin{lstlisting}[numbers=left]
max_ab_lvl(5).
query(relA(bob),0).
:-not holds(relA(bob)).

holds(relA(X)) :- holds(relB(X, Y)),holds(relA(Y)).

explains(relB(X, Y), relA(X) ,N) :- createSub(subInst_r1(X,Y),N).
explains(relA(Y), relA(X) ,N) :- createSub(subInst_r1(X,Y),N).


createSub(subInst_r1(X,skolemFn_r1_Y(X)),N+1) :- query(relA(X) ,N),max_ab_lvl(M),N<M-1.

createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), holds(relB(X, Y)).
createSub(subInst_r1(V_X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N),holds(relA(Y)).


query(X,N):-explains(X,Y,N),max_ab_lvl(M),N<M.
{abducedFact(X)}:-query(X,N).
holds(X):-abducedFact(X).
holds(X):-user_input(pos,X).

:~abducedFact(Y).[1@1,Y]
:-abducedFact(relA(bob)).
\end{lstlisting}

Due to line 11 in the encoding we get the atom\begin{lstlisting}[frame=none]
createSub(subInst_r1(bob,skolemFn_r1_Y(bob)),1).
\end{lstlisting}
Then due to lines 7 and 8 of the encoding we get the atoms \begin{lstlisting}[frame=none]
query(relA(skolemFn_r1_Y(bob)),1) query(relB(bob,skolemFn_r1_Y(bob)),1).
\end{lstlisting} 

Then via lines 11 and 7 and due to the atom
\begin{lstlisting}[frame=none]
query(relA(skolemFn_r1_Y(bob)),1)
\end{lstlisting} we get the atom \begin{lstlisting}[frame=none]
query(relB(skolemFn_r1_Y(bob), skolemFn_r1_Y(skolemFn_r1_Y(bob))),2)
\end{lstlisting} 
Then due to lines 18, 19, we get the atom \begin{lstlisting}[frame=none]
holds(relB(skolemFn_r1_Y(bob), skolemFn_r1_Y(skolemFn_r1_Y(bob))
\end{lstlisting}
Then due to line 13 of the encoding and the atom \begin{lstlisting}[frame=none]
createSub(subInst_r1(bob,skolemFn_r1_Y(bob)),1)
\end{lstlisting} we get the atom
\begin{lstlisting}[frame=none]
createSub(subInst_r1(skolemFn_r1_Y(bob), skolemFn_r1_Y(skolemFn_r1_Y(bob))),1)
\end{lstlisting}
Then due line 8 and line 17, we get the atom \begin{lstlisting}[frame=none]
query(relA(skolemFn_r1_Y(skolemFn_r1_Y(bob)),1)
\end{lstlisting}

In this way we can see that with the encoding above we would have answer sets
that contain atoms of the form\\ $query(relA(skolemFn\_r1\_Y(...),1)$ for
aribtrarily large skolem function nesting depth. Hence the encoding above
leads to infinitely large answer sets.

Intuitively, the core problem is lines like 13, 14 where the skolem depth of
terms in the $createSub$ predicate has no relation with the integer argument
of the $createSub$ predicate, thus allowing for abducibles, where the skolem
depth of the arguments inside predicates can be arbitrarily large despite
having a finite maximum abduction depth level. The solution to this problem
then is to replace the $N$ occuring as the integer argument of the $createSub$
predicate in the head of the rule on lines 13, 14 with $M-1$, where the $M$
corresponds to the argument of $max\_ab\_lvl$. This means that $query$ atoms
which occur due to the use of rules like line 13, 14 cannot further cause
fresh $query$ atoms to be added to the abducibles space via rules like the one
on line 11.

As a result of this however we lose complete term substitution. Consider the following abduction problem. $R$ is given by the following ASP rules:
\begin{lstlisting}[frame=none]
relA(P):-relB(P,R),relD(R).
relB(P,R):-relA(R),relC(P).
\end{lstlisting}
Let $q$ be the atom $relA(john)$, let $U$ consist of the constraints $:-abducedFact(relA(john)).$, $:-abducedFact(relB(X,Y)).$ meaning that $q$ cannot itself be abduced and no instantiation of the predicate $relB$ can be abduced. Let the set of user provided facts be empty for now. Let the set $C$ also be empty and let $N = 4$. This is the non expanded abduction encoding for this problem. 
\begin{lstlisting}[numbers=left]
max_ab_lvl(5).

% Encoding the goal
generate_proof(relA(john)).
goal:-holds(relA(john)).
:-not goal.
query(X,0):-generate_proof(X).

% Core rule translation
holds(relA(P)) :- holds(relB(P, R)),holds(relD(R)).
holds(relB(P, R)) :- holds(relA(R)), holds(relC(P)).

% AG1
createSub(subInst_r1(P,skolemFn_r1_R(P)),N+1) :- query(relA(P) ,N),max_ab_lvl(M),N<M-1.
createSub(subInst_r2(P,Q),N+1) :- query(relB(P, Q) ,N),max_ab_lvl(M),N<M-1.



explains(relB(P, R), relA(P) ,N) :- createSub(subInst_r1(P,R),N).
explains(relD(R), relA(P) ,N) :- createSub(subInst_r1(P,R),N).


explains(relA(R), relB(P,R) ,N) :- createSub(subInst_r2(P,R),N).
explains(relC(P), relB(P,R) ,N) :- createSub(subInst_r2(P,R),N).


% AG2 for rule 1
createSub(subInst_r1(P,R),M-1) :- createSub(subInst_r1(V_P,V_R),N), holds(relB(P, R)),max_ab_lvl(M).
createSub(subInst_r1(V_P,R),M-1) :- createSub(subInst_r1(V_P,V_R),N), holds(relD(R)),max_ab_lvl(M).

% AG2 for rule 2
createSub(subInst_r2(V_P,R),M-1) :- createSub(subInst_r2(V_P,V_R),N), holds(relA(R)),max_ab_lvl(M).
createSub(subInst_r2(P,V_R),M-1) :- createSub(subInst_r2(V_P,V_R),N), holds(relC(P)),max_ab_lvl(M).

% AG3
query(X,N):-explains(X,Y,N),max_ab_lvl(M),N<M.

% Supporting code
{abducedFact(X)}:-query(X,N).
holds(X):-abducedFact(X).
holds(X):-user_input(pos,X).


:~abducedFact(Y).[1@1,Y]
:-abducedFact(relA(john)).
:-abducedFact(relB(X,Y)).


\end{lstlisting}
Running this program in Clingo, we get the output 
\begin{verbatim}
abducedFact(relC(john))
abducedFact(relD(skolemFn_r1_R(skolemFn_r1_R(john))))
abducedFact(relA(skolemFn_r1_R(skolemFn_r1_R(john))))    
\end{verbatim}
as the solution with the least number of abducibles.
Now adding $relC(john)$ as a user provided fact gives the following smaller abductive solution
\begin{verbatim}
abducedFact(relD(skolemFn_r1_R(skolemFn_r1_R(john))))
abducedFact(relA(skolemFn_r1_R(skolemFn_r1_R(john))))    
\end{verbatim}
Now if we further add $relA(mary)$ to the set of user provided facts then we
get as a minimal abductive solution the answer $relD(mary)$. This is because
by after adding these facts, $holds(relB(john,mary))$ becomes true. Then by
line 28 of the encoding\\
$createSub(subInst\_r1(john,mary),4)$ becomes
true. Then by line 20, and line 36 $query(relD(mary),4)$ becomes true which
then gives us the miinimal abductive solution. However if instead of adding
the fact $relA(mary)$ we instead add the fact $relD(mary)$, then we do not get
a  substitution of terms does not take place and the minimal abductive
solution is still
\begin{verbatim}
abducedFact(relD(skolemFn_r1_R(skolemFn_r1_R(john))))
abducedFact(relA(skolemFn_r1_R(skolemFn_r1_R(john))))    
\end{verbatim} 
This is because by line 29, the atom\\ $createSub(subInst\_r1(john,mary),4)$ becomes true,
which due to line 19 and line 36 makes $query(relB(john,mary),4)$
true. However now this cannot cause the atom $query(relA(mary),5)$ to become
true because line 15 cannot apply due to the constraint on the integer
argument of the $query$ atom. So what we have can be regarded as a partial
term substitution mechanism.


\subsubsection{Replacing skolem functions by a single constant}

Let us see how having term substitution as a derived effect via enlargement of
the space of abducibles rather than doing term substitution through an
explicit equality predicate allows us to better handle problems where the core
rules have existential variables but we do not wish to use skolem functions in
the abductive reasoning process. Recall that not having skolem functions
allows us to get full term substitution without the possiblity of infinitely
large answer sets. Consider the problem $,\langle R,q,U,C,N \rangle$ where $R$ is the
following input rule set: 

\begin{verbatim}
relA(X):-relB(X,Y),relC(X,Y).
relB(X,Y):-relD(X,Y,Z),relE(X,Y,Z).
\end{verbatim}

let our $q$ be $relA(john)$. Let the initial set of user provided facts be empty, furthermore, suppose that no instance of $relA$ or $relB$ may be abduced. Finally let the set $C$ be emppty and let $N=4$.  
Consider the following encoding
\begin{lstlisting}[numbers=left]
max_ab_lvl(5).
% Encoding the goal
generate_proof(relA(john)).
query(X,0):-generate_proof(X).
goal:-holds(relA(john)).
:- not goal.



% Core rule translation
holds(relA(X)) :- holds(relB(X, Y)),holds(relC(X,Y)).
holds(relB(X,Y)) :- holds(relD(X,Y,Z)), holds(relE(X,Y,Z)).

% AG1_exp
createSub(subInst_r1(X,extVar),N+1) :- query(relA(X) ,N),max_ab_lvl(M),N<M-1.
createSub(subInst_r2(X,Y,extVar),N+1) :- query(relB(X,Y) ,N),max_ab_lvl(M),N<M-1.

explains(relB(X, Y), relA(X) ,N) :- createSub(subInst_r1(X,Y),N).
explains(relC(X, Y), relA(X) ,N) :- createSub(subInst_r1(X,Y),N).

explains(relD(X,Y,Z), relB(X,Y) ,N) :- createSub(subInst_r2(X,Y,Z),N).
explains(relE(X,Y,Z), relB(X,Y) ,N) :- createSub(subInst_r2(X,Y,Z),N).


% AG2_exp for rule 1

createSub(subInst_r1(X,V_Y),N) :- createSub(subInst_r1(V_X,V_Y),N), holds(relA(X)).
createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), holds(relB(X,Y)).
createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), holds(relC(X,Y)).

createSub(subInst_r1(X,V_Y),N) :- createSub(subInst_r1(V_X,V_Y),N), query(relA(X),L).
createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), query(relB(X,Y),L).
createSub(subInst_r1(X,Y),N) :- createSub(subInst_r1(V_X,V_Y),N), query(relC(X,Y),L).


% AG2_exp for rule 2

createSub(subInst_r2(X,Y,V_Z),N) :- createSub(subInst_r2(V_X,V_Y,V_Z),N), holds(relB(X,Y)).
createSub(subInst_r2(X,Y,Z),N) :- createSub(subInst_r2(V_X,V_Y,V_Z),N), holds(relD(X,Y,Z)).
createSub(subInst_r2(X,Y,Z),N) :- createSub(subInst_r2(V_X,V_Y,V_Z),N), holds(relE(X,Y,Z)).


createSub(subInst_r2(X,Y,V_Z),N) :- createSub(subInst_r2(V_X,V_Y,V_Z),N), query(relB(X,Y),L).
createSub(subInst_r2(X,Y,Z),N) :- createSub(subInst_r2(V_X,V_Y,V_Z),N), query(relD(X,Y,Z),L).
createSub(subInst_r2(X,Y,Z),N) :- createSub(subInst_r2(V_X,V_Y,V_Z),N), query(relE(X,Y,Z),L).

% AG3_exp
query(X,N):-explains(X,Y,N),max_ab_lvl(M),N<M.
query(Y,N-1):-explains(X,Y,N),max_ab_lvl(M),N<M,0<N.

% Supporting code
{abducedFact(X)}:-query(X,N).
holds(X):-abducedFact(X).
holds(X):-user_input(pos,X).


:~abducedFact(Y).[1@1,Y]
:-abducedFact(relA(X)).
:-abducedFact(relB(X,Y)).

\end{lstlisting}

Note that in lines 15, 16 instead of using skolem functions we use a single
fresh constant $extVar$ to represent the existential variable in both
rules. Now, when we run the program we get the following optimal solution

\begin{verbatim}
abducedFact(relC(john,extVar))
abducedFact(relE(john,extVar,extVar))
abducedFact(relD(john,extVar,extVar))    
\end{verbatim}

Now because, term substitution is only a derived effect and there is no
equality relation, it is possible for different instances of $extVar$ to get
replaced (or not) by different constants upon the addition of some user
provided facts. For instance upon adding the fact $relD(john,james,mary)$, we get
the optimal solution:

\begin{verbatim}
abducedFact(relC(john,james))
abducedFact(relE(john,james,mary))    
\end{verbatim}

So some instances of $extVar$ from the original solution have been replaced by 'james' and others by 'mary'. What this means is that each occurence of $extVar$ in the original solution can be thought of as simply a place-holder for a term where each instance maybe a placeholder for a different term. When we use skolem functions instead this is simply more explicit because we have different skolem terms representing different existential variables. More formally in the first solution the variables $[X,Y,Z]$ get mapped to $[john, extVar,extVar]$ respectively. Upon the addition of the extra fact the we get the mapping $[X,Y,Z]\rightarrow[john,james,mary]$. Using an equality relation to get from the first solution to the second would be impossible because we would need both the following equalities to hold: $extVar = james$, $extVar = mary$. (Of course the above solution could be obtained if one simply grounds the rules over the entire domain of constants but as mentioned in the introduction, the methods in this paper are aimed at avoiding such a naÃ¯ve grounding as in general, one may get too many substitutions for existential variables)


Given $<R,q,U,C,N>$, let this ASP program where we use $AG1_{exp}$ , $AG2_{exp}$, $AG3_{exp}$ but replace all use of skolem terms with $extVar$ be called $P_{<R,q,U,C,N>}^{semi-res}$.\\ We will now turn to the problem of generating a set of directed edges corresponding the computed abductive solution.



\subsection{Generating Justification Trees}

Given a source rule 
\begin{lstlisting}[frame=none]
pre_con_1(V1),pre_con_2(V2),...,pre_con_k(Vk),not pre_con_k+1(Vk+1),...,not pre_con_n(Vn) -> 
post_con(V).
\end{lstlisting}

For each positive pre-condition $pre\_con\_u(V_{u})$, we add the following ASP rule:

\begin{lstlisting}[frame=none]
causedBy(pos,pre_con_u(Vu), post_con(V),N+1):-holds(post_con(V)), holds(pre_con_1(V1)),
holds(pre_con_2(V2)),...,holds(pre_con_k(Vk)),not holds(pre_con_k+1(Vk+1)),...,
not holds(pre_con_n(Vn)),justify(post_con(V),N).   
\end{lstlisting}
For each negative precondition $pre\_con\_f(V_{f})$ we add the following ASP rule: 
\begin{lstlisting}[frame=none]
causedBy(neg,pre_con_f(Vf), post_con(V),N+1):-holds(post_con(V)), holds(pre_con_1(V1)),
holds(pre_con_2(V2)),...,holds(pre_con_k(Vk)),not holds(pre_con_k+1(Vk+1)),...,
not holds(pre_con_n(Vn)), justify(post_con(V),N).
\end{lstlisting}

\subsubsection{Supporting code for justification tree}
\mbox{}

\begin{lstlisting}[frame=none]
justify(X,N):-causedBy(pos,X,Y,N), not user_input(pos,X),N<M, max_graph_lvl(M).
directedEdge(Sgn,X,Y):-causedBy(Sgn,X,Y,M).

justify(X,0):-gen_graph(X),not user_input(pos,X).

directedEdge(pos,userFact,X):-directedEdge(pos,X,Y), user_input(pos,X).

directedEdge(pos,userFact,X):-gen_graph(X), user_input(pos,X).
\end{lstlisting}

\subsection{Discussion of Justification generation}

The intuition for the justification graph encoding is that given some user
provided facts $F$ and an input rule set $R$, an atom $a$ is only contained in
a stable model $M$ of $F$, $R$ if either $a$ is in $F$ or there exists some
rule $r$ in $R$ such that for some ground instantiation $r_{g}$ of $r$, all
the pre-conditions of $r_{g}$, (ie. the body atoms) are true in $M$ and the
post-condition (ie. head) of $r_{g}$ is $a$. Here the truth value of $NAF$
atoms is interpreted in the usual way. The edges for the justification graph
are calculated recursively. An atom $justify(h,k)$ represents the fact that
$holds(h)$ needs to be justified. If $r_{g}$ is a ground instantiantion of an
input rule where the post condition of $r_{g}$ is $h$ and all the
pre-conditions of $r_{g}$ are true then for every positive precondition
$b_{i}$ of $r_{g}$ we have the atom $causedBy(pos,b_{i},h,N)$ and for every
$NAF$ pre-condition $b_{j}$ we have the atom $causedBy(neg,b_{j},h,k)$. Then
if $k<max\_graph\_lvl$, we have the atoms $justify(b_{i},k+1)$, for every
positive pre-condition $b_{i}$. Finally each $causedBy$ atom generates a
$directedEdge$ atom, and these atoms are the set of directed edges
representing the justification graph.


\subsection{Some example executions}
Given the following program
\begin{lstlisting}[numbers=left]
gen_graph(relA(john)).
max_graph_lvl(5).

user_input(pos,relE(john,james,mary)).
user_input(pos,relD(john,james,mary)). 

holds(X):-user_input(pos,X).

holds(relA(X)) :- holds(relB(X, Y)),not holds(relC(X,Y)).
holds(relB(X,Y)) :- holds(relD(X,Y,Z)), holds(relE(X,Y,Z)).

causedBy(pos,relB(X,Y),relA(X),N+1):-holds(relA(X)),holds(relB(X, Y)),not holds(relC(X,Y)),justify(relA(X),N).
causedBy(neg,relC(X,Y),relA(X),N+1):-holds(relA(X)),holds(relB(X, Y)),not holds(relC(X,Y)),justify(relA(X),N).

causedBy(pos,relD(X,Y,Z),relB(X,Y),N+1):-holds(relB(X,Y)),
holds(relD(X,Y,Z)),holds(relE(X,Y,Z)),justify(relB(X,Y),N).
causedBy(pos,relE(X,Y,Z),relB(X,Y),N+1):-holds(relB(X,Y)),
holds(relD(X,Y,Z)),holds(relE(X,Y,Z)),justify(relB(X,Y),N).

justify(X,N):-causedBy(pos,X,Y,N), not user_input(pos,X),N<M, max_graph_lvl(M).
directedEdge(Sgn,X,Y):-causedBy(Sgn,X,Y,M).

justify(X,0):-gen_graph(X),not user_input(pos,X).

directedEdge(pos,userFact,X):-directedEdge(pos,X,Y), user_input(pos,X).

directedEdge(pos,userFact,X):-gen_graph(X), user_input(pos,X).
\end{lstlisting}
We get the following set of directed edges representing the justification graph. 
\begin{lstlisting}[frame=none]
directedEdge(pos,relB(john,james),relA(john))
directedEdge(pos,relE(john,james,mary),relB(john,james))
directedEdge(pos,relD(john,james,mary),relB(john,james))
directedEdge(neg,relC(john,james),relA(john))
directedEdge(pos,userFact,relD(john,james,mary))
directedEdge(pos,userFact,relE(john,james,mary))
\end{lstlisting}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
