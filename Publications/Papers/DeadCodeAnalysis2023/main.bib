%% This BibTeX bibliography file was created using BibDesk.
%% https://bibdesk.sourceforge.io/

%% Created for Martin STRECKER at 2023-09-08 12:44:59 +0800 


%% Saved with string encoding Unicode (UTF-8) 



@article{coupette_hartung_etal_law_smells_2022,
	abstract = {Building on the computer science concept of code smells, we initiate the study of law smells, i.e., patterns in legal texts that pose threats to the comprehensibility and maintainability of the law. With five intuitive law smells as running examples---namely, duplicated phrase, long element, large reference tree, ambiguous syntax, and natural language obsession---, we develop a comprehensive law smell taxonomy. This taxonomy classifies law smells by when they can be detected, which aspects of law they relate to, and how they can be discovered. We introduce text-based and graph-based methods to identify instances of law smells, confirming their utility in practice using the United States Code as a test case. Our work demonstrates how ideas from software engineering can be leveraged to assess and improve the quality of legal code, thus drawing attention to an understudied area in the intersection of law and computer science and highlighting the potential of computational legal drafting.},
	author = {Coupette, Corinna and Hartung, Dirk and Beckedorf, Janis and B{\"o}ther, Maximilian and Katz, Daniel Martin},
	date = {2023/06/01},
	date-added = {2023-09-08 12:41:27 +0800},
	date-modified = {2023-09-08 12:43:47 +0800},
	doi = {10.1007/s10506-022-09315-w},
	id = {Coupette2023},
	isbn = {1572-8382},
	journal = {Artificial Intelligence and Law},
	number = {2},
	pages = {335--368},
	title = {Law Smells},
	url = {https://doi.org/10.1007/s10506-022-09315-w},
	volume = {31},
	year = {2023},
	bdsk-url-1 = {https://doi.org/10.1007/s10506-022-09315-w}}


@article{scott_marcus_structured_legislation_2015,
	author = {J. Scott Marcus},
	date-added = {2023-09-08 14:36:28 +0800},
	date-modified = {2023-09-08 14:36:28 +0800},
	doi = {10.5235/175214612800902534},
	eprint = {https://doi.org/10.5235/175214612800902534},
	journal = {Legisprudence},
	number = {1},
	pages = {1-33},
	publisher = {Routledge},
	title = {Structured Legislation: Toward the Synthesis of Better Law and Regulation of Electronic Communications},
	url = {https://doi.org/10.5235/175214612800902534},
	volume = {6},
	year = {2012},
	bdsk-url-1 = {https://doi.org/10.5235/175214612800902534}}

@article{fungwacharakorn_tsushima_satoh_legal_debugging_2021,
	abstract = {There are cases in which the literal interpretation of statutes may lead to counterintuitive consequences. When such cases go to high courts, judges may handle these counterintuitive consequences by identifying problematic rule conditions. Given that the law consists of a large number of rule conditions, it is demanding and exhaustive to figure out which condition is problematic. For solving this problem, our work aims to assist judges in civil law systems to resolve counterintuitive consequences using logic program representation of statutes and Legal Debugging. The core principle of Legal Debugging is to cooperate with a user to find a culprit, a root cause of counterintuitive consequences. This article proposes an algorithm to resolve a culprit. Since the statutes are represented by logic rules but changes in law are initiated by cases, we adopt a prototypical case with judgement specified by a set of rules. Then, to resolve a culprit, we reconstruct a program so that it provides reasons as if we applied case-based reasoning to a new set of prototypical cases with judgement, which include a new set of facts relevant to a considering case.},
	author = {Fungwacharakorn, Wachara and Tsushima, Kanae and Satoh, Ken},
	date = {2021/12/01},
	date-added = {2023-09-08 14:31:50 +0800},
	date-modified = {2023-09-08 14:33:15 +0800},
	doi = {10.1007/s10506-021-09283-7},
	id = {Fungwacharakorn2021},
	isbn = {1572-8382},
	journal = {Artificial Intelligence and Law},
	number = {4},
	pages = {541--557},
	title = {Resolving counterintuitive consequences in law using legal debugging},
	url = {https://doi.org/10.1007/s10506-021-09283-7},
	volume = {29},
	year = {2021},
	bdsk-url-1 = {https://doi.org/10.1007/s10506-021-09283-7}}

@article{fungwacharakorn_satoh_legal_rule_revision_debugging_2022,
	abstract = {Computational law researchers have long been interested in developing machine legal reasoning systems and machine-readable rule-bases to simulate legal reasoning given by judges. Basically, legal rule-bases rely on literal interpretations of statutes. In practice, however, literal interpretation of statute can have counterintuitive consequences. To deal with such consequences, English courts (the courts of England and Wales) have developed rules of judicial interpretation for reinterpreting statutes i.e. choosing or modifying the meaning of the statute's wording (golden rule) or determining the statute's purpose (mischief rule), and these rules have not been investigated in computational law. Previous research proposed the concept of legal debugging to formalize detection and resolution of counterintuitive consequences in legal rule-bases. Legal debugging consists of two steps. The first step is culprit detection, which involves interacting with a judge in order to identify a culprit, which is intuitively a part of statute that can be determined as a root cause of counterintuitive consequences. The second step is culprit resolution, which involves revising the rule-base to resolve a detected culprit. In this paper, we match two inductive logic programming approaches to two rules of judicial interpretation. The first approach is a bottom-up approach, which involves identifying an exceptional situation of the case and generalizing the legal rule revision. We match the bottom-up approach to the golden rule by using knowledge bases in the form of legal ontologies. The second approach is a top-down approach, which involves determining the purpose of the statute and refining the legal rule revision so that the revision fits within the context of the statute. We match the top-down approach to the mischief rule by using knowledge bases in the form of metarules. By using these matches, legal debugging can perform more practical legal revisions during the culprit resolution step.},
	author = {Wachara Fungwacharakorn and Ken Satoh},
	date-added = {2023-09-08 15:24:09 +0800},
	date-modified = {2023-09-08 15:24:09 +0800},
	doi = {https://doi.org/10.1016/j.clsr.2022.105696},
	issn = {0267-3649},
	journal = {Computer Law \& Security Review},
	keywords = {Algorithmic law, Legal reasoning, Legal debugging},
	pages = {105696},
	title = {Toward a practical legal rule revision in legal debugging},
	url = {https://www.sciencedirect.com/science/article/pii/S0267364922000437},
	volume = {46},
	year = {2022},
	bdsk-url-1 = {https://www.sciencedirect.com/science/article/pii/S0267364922000437},
	bdsk-url-2 = {https://doi.org/10.1016/j.clsr.2022.105696}}

@inproceedings{neubauer_etal_accurate_dead_code_detection_2016,
  author       = {Felix Neubauer and
                  Karsten Scheibler and
                  Bernd Becker and
                  Ahmed Mahdi and
                  Martin Fr{\"{a}}nzle and
                  Tino Teige and
                  Tom Bienm{\"{u}}ller and
                  Detlef Fehrer},
  editor       = {Erika {\'{A}}brah{\'{a}}m and
                  James H. Davenport and
                  Pascal Fontaine},
  title        = {Accurate Dead Code Detection in Embedded {C} Code by Arithmetic Constraint
                  Solving},
  booktitle    = {Proceedings of the 1st Workshop on Satisfiability Checking and Symbolic
                  Computation co-located with 18th International Symposium on Symbolic
                  and Numeric Algorithms for Scientific Computing {(SYNASC} 2016), Timisoara,
                  Romania, September 24, 2016},
  series       = {{CEUR} Workshop Proceedings},
  volume       = {1804},
  pages        = {32--38},
  publisher    = {CEUR-WS.org},
  year         = {2016},
  url          = {https://ceur-ws.org/Vol-1804/paper-07.pdf},
  timestamp    = {Fri, 10 Mar 2023 16:22:35 +0100},
  biburl       = {https://dblp.org/rec/conf/synasc/NeubauerS0MFTBF16.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@incollection{coppo_damiani_giannini_analyses_funct_progr_dead_code_1998,
  title={Inference based analyses of functional programs: dead-code and strictness},
  author={Coppo, Mario and Damiani, Ferruccio and Giannini, Paola},
  booktitle={Theories of Types and Proofs},
  volume={2},
  pages={143--177},
  year={1998},
  publisher={Mathematical Society of Japan}
}
  

@inproceedings{benton_relational_corr_proofs_static_analyses_2004,
author = {Benton, Nick},
title = {Simple Relational Correctness Proofs for Static Analyses and Program Transformations},
year = {2004},
isbn = {158113729X},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/964001.964003},
doi = {10.1145/964001.964003},
abstract = {We show how some classical static analyses for imperative programs, and the optimizing transformations which they enable, may be expressed and proved correct using elementary logical and denotationaltechniques. The key ingredients are an interpretation of program properties as relations, rather than predicates, and a realization that although many program analyses are traditionally formulated in very intensional terms, the associated transformations are actually enabled by more liberal extensional properties.We illustrate our approach with formal systems for analysing and transforming while-programs. The first is a simple type system which tracks constancy and dependency information and can be used to perform dead-code elimination, constant propagation and program slicing as well as capturing a form of secure information flow. The second is a relational version of Hoare logic, which significantly generalizes our first type system and can also justify optimizations including hoisting loop invariants. Finally we show how a simple available expression analysis and redundancy elimination transformation may be justified by translation into relational Hoare logic.},
booktitle = {Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {14â€“25},
numpages = {12},
keywords = {partial equivalence relations, security, Hoare logic, optimizing compilation, dependency, program analysis, information flow, denotational semantics, types},
location = {Venice, Italy},
series = {POPL '04}
}

  

@ARTICLE{romano_etal_2020,

  author={Romano, Simone and Vendome, Christopher and Scanniello, Giuseppe and Poshyvanyk, Denys},

  journal={IEEE Transactions on Software Engineering}, 

  title={A Multi-Study Investigation into Dead Code}, 

  year={2020},

  volume={46},

  number={1},

  pages={71-99},

  doi={10.1109/TSE.2018.2842781}}
