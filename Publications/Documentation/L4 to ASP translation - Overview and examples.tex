\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{L4 to ASP translation - Overview and examples}
\author{}

\begin{document}
\maketitle


\section{Introduction}

In this document we will give a set of translations from a restricted rule syntax (such as a subset of L4) to corresponding sets of ASP rules, needed for a  prototype of the ASP justification tree generation and abductive proof generation procedures. We first give 3 main sets of translation for prolog-like rules that have no existential quantifiers. The first translation is for the core (defeasible) forward reasoning procedure. The next translation set is for abductive proof generation, the last is for justification tree generation. Note that all three work together to achieve any one functionality. There is also some fixed ASP code that is independent of the input rule set that 'glues' everything together that we shall not mention here.\\
\newline
After dealing with the case where there are no existential quantifiers, we turn to the case where there are existential quantifiers in rule pre-conditions. Here the translation for the abductive proof generation process is considerably more complex but the translations for the other two functionalities remain exactly the same. For now we consider the simpler case of no existential quantifiers.
\section{Assumed input rule syntax}
We assume that the input rule syntax from a source such as L4 is compatible with the syntax for prolog-like rules. More specifically we assume that each source rule has exactly the following form (or can be put into the following form):
\begin{verbatim}
pre_con_1(V1),pre_con_2(V2)...,pre_con_n(Vn) -> post_con(V).
\end{verbatim}
We further make the following assumptions:\\
1. Each pre-condition $pre\_con_{i}(V_{i})$ is atomic and so is the post-condition $post\_con(V)$.\\
2. $V_{i}$ is the set of variables occuring in the $i^{th}$ pre-condition $pre\_con_{i}(V_{i})$ and $V$ is the set of variables occuring in the post condition $post\_con(V)$. We assume that $V_{1}\cup V_{2}\cup ... \cup V_{n} = V$.\\
3. Each variable occurring in either a pre-condition or the post condition is universally quantified over.\\
4. Each input rule of the form above carries with it an integer rule id. possibly originating in the legislation.
\section{Main input rule translation}
Given an input rule \begin{verbatim}
pre_con_1(V1),pre_con_2(V2)...,pre_con_n(Vn) -> post_con(V).
\end{verbatim} obeying all the properties in (2), say this rule has integer rule id. $n$, then we write the following rule in our ASP program: \begin{verbatim}
according_to(n,post_con(V)):-legally_holds(pre_con(V1)),...,legally_holds(pre_con(Vn)).    
\end{verbatim} 
\section{ASP code for Abductive Proof generation}
Given an input rule \begin{verbatim}
pre_con_1(V1),pre_con_2(V2)...,pre_con_n(Vn) -> post_con(V).
\end{verbatim} obeying all the properties in (2), we add the following set of ASP rules to our ASP program: \begin{verbatim}
explains(pre_con_1(V1),post_con(V),N+1):-query(post_con(V),N).
explains(pre_con_2(V2),post_con(V),N+1):-query(post_con(V),N).
                          .
                          .
                          .
                        
explains(pre_con_n(Vn),post_con(V),N+1):-query(post_con(V),N).
\end{verbatim}
We repeat this for each input rule. 
\section{ASP code for Justification Tree generation}
Given an input rule \begin{verbatim}
pre_con_1(V1),pre_con_2(V2)...,pre_con_n(Vn) -> post_con(V).
\end{verbatim} obeying all the properties in (2), with integer rule id $n$ we add the following set of ASP rules to our ASP program:\begin{verbatim}
caused_by(pos,legally_holds(pre_con_1(V1)),according_to(n,post_con(V)),N+1)
:-according_to(post_con(V)),legally_holds(pre_con_1(V1)),...,legally_holds(pre_con_n(Vn)),
justify(according_to(post_con(V),N).  
            .
            .
            .
caused_by(pos,legally_holds(pre_con_n(Vn)),according_to(n,post_con(V)),N+1)
:-according_to(post_con(V)),legally_holds(pre_con_1(V1)),...,legally_holds(pre_con_n(Vn)),
justify(according_to(post_con(V),N).             
\end{verbatim}
We repeat this for each input rule. 

\section{Encoding negatives}
For each pair of atoms $C$, $C1$ such that $C$, $C1$ are negatives of each other, we have the following set of ASP rules:
\begin{verbatim}
opposes(C,C1):-according_to(R,C).
opposes(C1,C):-according_to(R,C1).

opposes(C,C1):-query(C,N).
opposes(C1,C):-query(C1,N).

opposes(C,C1):-legally_holds(C).
opposes(C1,C):-legally_holds(C1).
\end{verbatim}

\section{Abductive Proof Generation translation - II}
\subsubsection{General procedure}
Given a prolog like rule 
\begin{verbatim}
c(X1,X2,...Xn):-...,a(X(i_1),X(i_2),...,Y_(i_1),Y_(i_2)...),...    
\end{verbatim}
Let $a(Xi_1,Xi_2,...,Yi_1,Yi_2...)$ be one of the conjuncts in the antecedent of the rule such that each $X_{k}$ is in the set $\{X1,...,Xn\}$ and is universally quantified. Furthermore let all the $Y_{k}s$ be existentially quantified. Assume that each variable $X1, X2$,...,$Xn$ occurs in some conjunct in the antecedent. Let $\{X1,...,Xn,Y1,..,Ym\}$ be the entire set of variables appearing in the rule. Furthermore, let the rule have integer id $t$.\\
\newline
Then first we have the following set of ASP rules:
\begin{verbatim}
legally_holds(subs_vbls_t(X1,V2...,V_(m+n))).    :-query(c(X1,X2,..,Xn),N),
                                 legally_holds(subs_vbls_t(V1,V2...,V_(m+n))). 

legally_holds(subs_vbls_t(V1,X2...,V_(m+n))).    :-query(c(X1,X2,..,Xn),N),
                               legally_holds(subs_vbls_t(V1,V2...,V_(m+n))).  

.
.
.

legally_holds(subs_vbls_t(V1,V2,Xn,...,V_(m+n))).    :-query(c(X1,X2,..,Xn),N),
                               legally_holds(subs_vbls_t(V1,V2...,V_(m+n))).  
\end{verbatim}

Next we have the following ASP rule:
\begin{verbatim}
legally_holds(subs_vbls_t(X1,X2,..,Xn, skolemn_vbl_t_1(X1,X2,..,Xn),skolemn_vbl_t_2(X1,X2,...,Xn),

...,skolemn_vbl_t_m(X1,X2,...,Xn)):-query(c(X1,X2,..,Xn),N).
\end{verbatim}

Finally for each conjunct in the antecedent we have the following ASP rules:
\begin{verbatim}
explains(a(X(i_1),X(i_2),...,skolemn_vbl_t_(i_1)(X1,X2,...,Xn),skolemn_vbl_t_(i_2)(X1,X2,...,Xn)...)
,c(X1,X2,...,Xn),N+1):-query(c(X1,X2,..,Xn),N).  

explains(a(V(i_1),V(i_2),...,V(n+i_1),V(n+i_2),...),c(V1,V2,..,Vn),N+1):-query(c(U1,...,Un),N)
,legally_holds(subs_vbls_t(V1,V2,...,V_(m+n))).

legally_holds(subs_vbls_t(V1,..,X(i_1),...,X(i_2),...,Vn,V_(n+1),...,Y_(i_1),...,Y_(i_2),...,V(n+m)))
:-legally_holds(subs_vbls_t(V1,V2,...V_(m+n))),
legally_holds(a(X(i_1),X(i_2),...,Y_(i_1),Y_(i_2)...)).
\end{verbatim}
We shall now exemplify the above with a concrete example

Consider the folllowing rule
\begin{verbatim}
holds(a(X,X1)):-holds(b(X,Y1)),holds(e(X1,Y1,Y2)).
\end{verbatim}

Then we have the following ASP rules:
\begin{verbatim}
legally_holds(subs_vbls_1(X,V1,V2,V3)):-query(a(X,X1),N),legally_holds(subs_vbls_1(V,V1,V2,V3)).
legally_holds(subs_vbls_1(V,X1,V2,V3)):-query(a(X,X1),N),legally_holds(subs_vbls_1(V,V1,V2,V3)).
\end{verbatim}

Next we have:
\begin{verbatim}
legally_holds(subs_vbls_1(X,X1,skolemn_vbl_1_1(X,X1),skolemn_vbl_1_2(X,X1))):-query(a(X,X1),N).
\end{verbatim}

Next:
\begin{verbatim}
explains(b(X,skolemn_vbl_1_1(X,X1)),a(X,X1),N+1):-query(a(X,X1),N).

explains(e(X1,skolemn_vbl_1_1(X,X1),skolemn_vbl_1_2(X,X1)),a(X),N+1):-query(a(X,X1),N).
    
\end{verbatim}

Finally:
\begin{verbatim}
explains(b(X,Y1),a(X,X1),N+1):-query(a(U,U1),N),legally_holds(subs_vbls_1(X,X1,Y1,Y2)).

explains(e(X1,Y1,Y2),a(X,X1),N+1):-query(a(U,U1),N),legally_holds(subs_vbls_1(X,X1,Y1,Y2)).    
\end{verbatim}

and 

\begin{verbatim}
legally_holds(subs_vbls_1(X,V1,Y1,V3)):-legally_holds(b(X,Y1)),
legally_holds(subs_vbls_1(V,V1,V2,V3)).


legally_holds(subs_vbls_1(V,X1,Y1,Y2)):-legally_holds(e(X1,Y1,Y2)),
legally_holds(subs_vbls_1(V,V1,V2,V3)).

\end{verbatim}
\section{Simpler encoding for Abductive Proof Gneration for rules with ext. quant.}

Consider the following raw input rule again:
\begin{verbatim}
a(X,X1):-b(X,Y1),e(X1,Y1,Y2).
\end{verbatim}

This time we have only the following ASP rules in the translation for abductive proof generation.

\begin{verbatim}
explains(b(X,skolemn_vbl_1_1(X,X1)),a(X,X1),N+1):-query(a(X,X1),N).

explains(e(X1,skolemn_vbl_1_1(X,X1),skolemn_vbl_1_2(X,X1)),a(X),N+1):-query(a(X,X1),N).

create_subs(subs_vbls_1(X,X1,skolemn_vbl_1_1(X,X1),skolemn_vbl_1_2(X,X1)),N+1):-query(a(X,X1),N).


explains(b(X,Y1),a(X,X1),N):-create_subs(subs_vbls_1(X,X1,Y1,Y2),N).
explains(e(X1,Y1,Y2),a(X,X1),N):-create_subs(subs_vbls_1(X,X1,Y1,Y2),N).

create_subs(subs_vbls_1(X,V1,Y1,V3),N):-legally_holds(b(X,Y1)),
create_subs(subs_vbls_1(V,V1,V2,V3),N).


create_subs(subs_vbls_1(V,X1,Y1,Y2),N):-legally_holds(e(X1,Y1,Y2)),
create_subs(subs_vbls_1(V,V1,V2,V3),N).
    
\end{verbatim}

\section{Comments}
The technical hurdle with abductive proof generation for rules with existential quantifiers is that a priori, not all the variables in the premises are known. Therefore the need for skolemization in the initial proof generation, the skolem variables act as "place-holder" variable values. However as the user supplies certain predicates as fact we want the system to simplify the generated proof by 'using' the variable instantiations provided by the user wherever possible. (Ie even in predicates that have not been explicitly supplied by the user) Hence we have this extra 'create-subs' predicate that holds the set of generated possible variable instantiations (only relevant combinations not strictly speaking all possible instantiations) and then supplies these values to enable the proof to be completed.\\
\newline
The two questions that need to be explored here are the 'completeness' of this variable substitution generation process and the question of whether in certain cases, this procedure could lead to a potentially infinite combinatorial explosion for the generated possible variable substitution combinations.




\end{document}