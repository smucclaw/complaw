#+TITLE: Onboarding for SMU CCLAW Assistant Research Engineers and Trainees

SMU CCLAW's Research Programme in Computational Law welcomes junior engineers.

* Welcome

This is a welcome letter from the Research Programme's principal investigator to the recently hired junior engineer. Thank you for choosing to join us. When recruiting the team we selected for a range of backgrounds and levels of experience. Some team members have decades of experience; some are relatively new to coding, but I believe that everyone will have a chance to make a contribution.

Whether that contribution takes the form of programming, documentation, evangelism, testing, support, or design, remains to be seen. But in general, the best way to position yourself to make useful contributions to the team, is to have a wide range of relevant skills and competencies. Take it from Robert C. Martin, author of /The Clean Coder: A Code of Conduct for Professional Programmers/:

#+BEGIN_QUOTE
Do you know what a Nassi-Shneiderman chart is? If not, why not? Do you know the difference between a Mealy and a Moore state machine? You should. Could you write a quicksort without looking it up? Do you know what the term “Transform Analysis” means? Could you perform a functional decomposition with Data Flow Diagrams? What does the term “Tramp Data” mean? Have you heard the term “Conascence”? What is a Parnas Table?
#+END_QUOTE

Obviously, people aren't born knowing these things. Some people studied them in (what must have been a /very/ thorough course in) undergraduate computer science. Others acquire them mostly during their career -- "on-the-job training". If you're reading this, you're probably in the latter category. I certainly am. I didn't know what all the above things were until "Uncle Bob" made me go look them up.

To help you acquire useful skills, we have outlined an experience that is equal parts
- self-instruction :: a reading list and links to recommended third-party courses
- project-based :: structured contributions to the Research Programme at various levels of difficulty
- apprenticeship :: opportunities to pair program with engineers and work together on the same teams

This document focuses on the readings and video component. If you have joined the Programme as a junior engineer, consider this one pillar of your professional education. If you are worried that this is too much for you to take on, you please be assured that your employee performance will not be tied directly to completion of readings and courses; you will not be tested by your manager. Projects, task, and team assignments will be given separately. But delivering those assignments will go better if you know this stuff. And you will find that your colleagues in software engineering share a certain professional vocabulary because they have all been through something like this curriculum. Wouldn't you want to be on the same page as them?

** Qualifications and Temperament

The following curriculum assumes minimal computer science experience. You might have a degree, but that degree might not be in computer science. If you're a self-taught programmer with significant technical abilities already, I beg your indulgence; just keep in mind that this document caters to people who may not have done any programming at all.

The curriculum does assume a temperament suited to problem-solving, acquisition of technical skills, and high tolerance for frustration.

And it assumes the sort of intelligence associated with logical reasoning and critical thinking, but also with creative imagination.

It also assumes that you possess very strong English reading, writing, and conversational skills both spoken and written. You should be fluent enough in English that the idea of reading and writing a lot of it does not bother you.

How do you know if you have these skills? If, as a child, you were always to be found reading a book, you're probably fine. If the Sorting Hat would [[https://www.hpmor.com/chapter/10][put you in Ravenclaw, rather than Gryffindor]], if your friends and family go to you for help with technology problems, you're probably a pretty technical person. (See what others have said: [[https://www.wayup.com/guide/types-skills-best-computer-science-major/][1]], [[https://www.computersciencezone.org/10-skills-necessary-coding/][2]])

Maybe you enjoy games like the [[https://store.steampowered.com/bundle/234/Portal_Bundle/][Portal series]] and [[https://www.lazada.sg/catalog/?q=zelda+breath+wild&_keyori=ss&from=input&spm=a2o42.pdp.search.go.59702848XsoLUx][Zelda: Breath of the Wild]]. You try hard to solve the puzzles yourself before giving up and looking for the answer online. Maybe your hobbies are all creative in some way, and technology-related as well.

We tried to recruit for people who are good at both technology and people.

A career in software can rarely be conducted in isolation. The saying goes: "technical skills get you in the door, social skills get you up the ladder." Some highly technical individuals may scoff at that, and say: "[[https://en.wikipedia.org/wiki/ReiserFS][I can single-handedly develop a filesystem]]; I don't need people." And it's true that unlike kings and queens, wizards have an alternative path to power and impact: scaling through technology, rather than through people. But that is the archetype of the Saruman; isn't it be better to be a Gandalf?

At SMUCCLAW, even if you are working from home, or working remotely, you will be expected to participate as a member of a team. Because opensource communities often attract people with widely varying personal backgrounds, social norms, and communication styles, not to mention all the concrete characteristics that usually come up in discussions about "isms", they adopt [[https://opensource.guide/code-of-conduct/][Codes of Conduct]] to clarify standards of behaviour.

Where teamwork is concerned, the business world frequently recommends:
- [[https://www.amazon.com/Crucial-Conversations-Talking-Stakes-Second/dp/1469266822][Crucial Conversations]]
- [[https://www.nonviolentcommunication.com/][Nonviolent Communication]]
- [[https://www.amazon.com/Getting-Yes-Negotiating-Agreement-Without-ebook/dp/B0051SDM5Q/][Getting To Yes]]

** Why go through this curriculum?

The world is full of people in situations which do not give them the opportunity to fulfill their potential: they are fish who have been asked to fly, birds who have been asked to swim.

Check out Epicurious's [[https://www.epicurious.com/video/watch/500-vs-16-steak-dinner-pro-chef-home-cook-swap-ingredients][Ingredient Swap]]. Two chefs: one home cook, one professional expert. Most self-taught working programmers are like Lorenzo: well-meaning, doing the best they can, really likeable people. But if you're Frank, you know the history, the context, the pros and cons. Your mastery of technique is so complete that you can guess pretty accurately how something will turn out even if you've never done it before.

Would you rather be a Lorenzo or a Frank?

If you ask your colleagues, they will tell you that, on the whole, programming is fun! After a few months, you may find that you enjoy the work, and look forward to periods of focus, the sense of accomplishment you get from solving one problem after another, and the sense of impact associated with knowing that people are reading your documentation and relying on your working code. Having fun and feeling good is a sign you should keep going! The world will be your oyster.

But if you find that you aren't having fun, that you do not enjoy the work, that it's not just hard but simply incompatible with the way your brain works, that's a good discovery too: better to know now, than spend years doing something you hate.

You may already be an experienced programmer, with one or two languages under your belt, and a number of projects in your portfolio. You already get what the [[http://threevirtues.com/][Three Virtues]] is saying. In that case, this curriculum assumes that you see yourself as a lifelong learner; that you are challenging yourself to go outside your comfort zone; that your goal is to level up.

What does leveling up mean? Well, our context, it means this: Most programmers rely on third-party libraries; but can you imagine yourself writing a third-party library that other programmers rely on? All programmers start by learning an existing language, like Python or Javascript; can you imagine yourself writing a new language that other programmers learn? Language design and development is one of the highest forms of achievement in computer science, and if you start climbing those mountains you will find yourself in rarefied and respected company.

Let me offer a couple analogies. If you ask some people "where do eggs come from?" they will say, "the supermarket." Where does water come from? "Out of the tap." And that's fine for 98% of the population.

But you're in the other 2%. Maybe not quite so special as this [[https://www.reddit.com/r/edmproduction/comments/2j142b/for_anyone_who_uses_tribal_drum_samples_what/cl7g1wr/][legendary quote from the music community]] -- this is closer to 0.0002%:

#+BEGIN_QUOTE
I thought using loops was cheating, so I programmed my own using samples. I then thought using samples was cheating, so I recorded real drums. I then thought that programming it was cheating, so I learned to play drums for real. I then thought using bought drums was cheating, so I learned to make my own. I then thought using premade skins was cheating, so I killed a goat and skinned it. I then thought that was cheating too, so I grew my own goat from a baby goat. I also think that is cheating, but I'm not sure where to go from here. I haven't made any music lately, what with all the goat farming and all.
#+END_QUOTE

The point I'm trying to make is this: when you write a program, you are very conscious that your program is a made thing: it was created in response to specific goals, by a specific person who was born on a specific date and has a specific set of skills. It has a certain amount of documentation and a user interface that makes it easy or hard to use. And it has shortcomings and flaws that you can see quite clearly, because you have a Platonic ideal intent for what you want it to be, and you can see all the ways in which your work falls short.

Programming languages are also made things, with histories and biographies of their own. Just as you might be curious about the life story of a particular celebrity chef or a music band that you like, you might want to know where languages come from, how they are born, and how they grow up.

If you have the right temperament for technology, this curriculum will help you gain the theory and practice needed to understand and create computing technology across the span from individual bit in a CPU register, to Internet-scale applications. In the past, you may have used languages like Python and frameworks like React. But have you ever wondered where Python came from, what kind of thinking it would take to create a framework like React? This curriculum will, with luck and perseverance, move you closer to being able to make your unique contribution to the world of technology. [[https://www.quora.com/What-technical-skills-should-a-computer-science-graduate-have/answer/David-Lovering][Knowing the history of the field is helpful, too]], because as the saying goes, "Those who do not read history are doomed to repeat it." (See also: https://www.quora.com/Why-was-the-prediction-of-future-of-programming-Bret-Victor-not-realized)

*** Sidebar: On Work
Speaking of "work": many people use "work" as a verb: "I worked really hard today." Professional creatives have the luxury of using "work" as a noun: "this is my greatest work to date." As a professional programmer, "work" is both verb and noun. And, if all goes well, "work" is also "play".

*** Sidebar: On Jargon
One of the risks of being self-taught is that you don't know the official names for things, and that leads to really unproductive Googling.

A fair chunk of formal education is knowing what certain concepts are called, so that when you find yourself working with them, you can talk about them intelligently with other people. They don't let you be a doctor if you don't pass anatomy.

** The skill tree

In video games like /Zelda: Breath of the Wild/, players acquire armour, skills, and weapons in a rough sequence from easy to hard (the technical term for this is a "[[http://matt.might.net/articles/partial-orders/][partial order]]"). The early training levels acquaint you with basic game mechanics: how to walk, run, jump, crouch. How to engage in combat with ranged weapons and hand-to-hand. How to add things to your inventory and purchase upgrades. How to talk to NPCs and other characters.

Once you've leveled up enough, you start fighting mini-bosses, bosses, and, eventually, the final boss. Many games follow that structure for a reason: it's deeply human. It's how people learn, and stay motivated. Learning is play!

The partially ordered sequence in which you acquire these skills is called a "skill tree".

Developing software is similar enough to playing videogames that people have sketched skill trees for coding: [[http://dungeonsanddevelopers.com]] for web development, https://github.com/miloyip/game-programmer for game development. If you don't like the thought of reading dozens and dozens of thick books, a professional career may not be right for you ... whether that career is in law, medicine, or engineering. But if you approach those books as fun -- as opportunities to gain skill, mastery, and power, which help to level you up, then that attitude will keep you [[https://www.researchgate.net/profile/Sarah_Beecham/publication/287589352_Motivating_Software_Engineers_Working_in_Virtual_Teams_Across_the_Globe/links/587cb9fe08aed3826aefcb94/Motivating-Software-Engineers-Working-in-Virtual-Teams-Across-the-Globe.pdf][motivated]] through the slog.

/Zelda: BOTW/ has four divine beasts (Vahs Ruta, Rudania, Medoh, and Naboris) and one final boss: Calamity Ganon.

Likewise, the Research Programme has four major quests (NLG, FV, IDE/LSP, DMN/BPMN) and one final boss: the DSL.

Zelda also has dozens of side quests, 120 shrine dungeons, and 900 Korok puzzles scattered across the landscape. While you don't have to solve all of them to win the game, they will make you a better player and offer many opportunities to enjoy the game more. Have you followed the blue glow at night to Satori Mountain? It's really beautiful!

The Research Programme likewise offers numerous side quests: Internet protocols, cryptography, standards processes, the philosophy of open source, editor integrations, data visualization, SVG, APIs. And there are plenty of slightly tedious Korok puzzles. All this might smack of [[https://seths.blog/2005/03/dont_shave_that/][yak-shaving]], but it's part of skilling up.

Imagine a conversation with a skilled chef:

"I want lasagna for dinner. But I don't have any pre-bought in the fridge."

"I can make lasagna."

"But I don't have any lasagna pasta sheets."

"No problem, I can roll them; just give me flour and an egg."

"I have some eggs in the fridge but I don't know which are hardboiled and which are raw."

"There's a spinning trick you can use to find out."

"Ok. I want extra onions and garlic. Can you do that?"

"Sure, no problem. I'll start the prep by chopping onions and garlic."

"Here you go."

"So, uh, this knife you have, it really needs to be sharpened."

"Do you how to sharpen a knife? I think I have a sharpening stone lying around somewhere, that I've never used."

"Yes, I can sharpen your knife. Give me the stone."

"Uh, actually, I can't find it."

"Okay, do you have sandpaper?"

"Let me check ... nope, I don't have any."

"Never mind, I can use the bottom of a ceramic bowl."

This is the sort of skill tree that comes up all the time in cooking. A master of the kitchen doesn't just know how to cook a dish; they know how to strip and season a wok, build a fire for smoking, upgrade the firmware on the sous vide circulator, bandage a wound, and sharpen a knife three different ways.

In computing, the training levels begin with Unix, file editing, and connecting to our shared server over a cryptographically secured link. In the immortal words of Trinity in the Matrix: "[[https://www.youtube.com/watch?v=1eRxp_r9Qx4][I'm in.]]"

*** Resources

CCLAW has a shared AWS Linux instance which you will be given a user account on. If you do not have access to a Unix system of your own, you can use your shell account there to do your work. All you need on your computer is a terminal program and SSH.

**** Workstation

If you do not have a computer of your own, please mention this to management; it may be possible to issue you a work laptop.

A magician never forgets [[https://www.youtube.com/watch?v=AzGX4APCBjA][their first wand]]; a hacker never forgets their first Unix machine. For less than $200, you can order your own [[https://sg.cytron.io/c-raspberry-pi/p-RPi-4B-8G-Basic-Kit-5-UK-Plug-w-RPI4B8G?src=category.discovery][Raspberry Pi with 8 gigs of ram]].

**** Access to readings and courses

You may prefer to buy your own copy of books; alternatively, look to the library.

The edX CS50 courses recommended in this guide are free to take, though if you want certification you will have to pay separately.

**** Your Teammates

Your teammates are a resource, but a valuable resource. One way you can show respect for them is by asking Google first and your teammates second.

What do I mean by that?

You may have had the experience of being in a movie theatre movie with someone who constantly asked their friends, out loud, "oh my god, who do you think was the murderer? Who is this character and why are they behaving that way?"

Don't be that person. Try to solve your own problems first; some amount of time between five minutes and an hour is probably appropriate. Beyond an hour, if you're still lost, it's probably okay to reach out to ask for clues. If you're following explicit directions and the directions seem to be obviously faulty, go with the five-minute end of that range. If you can suggest an improvement to the directions, even better.

It's okay to document your learning journey out loud, by the way. On our shared Slack chat you can say, "Here is a thing I'm trying to figure out. I'm not asking anyone for help yet, I'm just letting you know what I'm doing, and when I reach the solution, I'll share that too, in case it benefits anybody else in future." This is such an important practice that we have not one but two channels on Slack for this: #[[https://en.wikipedia.org/wiki/Rubber_duck_debugging][rubberduck]] and #[[https://blog.adrianbolboaca.ro/2012/12/teddy-bear-pair-programming/][teddybear]]. (Indeed, it's not just okay, it's a virtue; the willingness to be wrong, or ignorant, in public goes hand in hand with humility and, ultimately, confidence.)

At that point someone else may feel the urge to jump in and help. This is better. Everybody likes to be helpful. Nobody likes to be interrupted.

I wrote this section with the hopes of pre-empting such a situation; if I were to write it after an incident occurred, the people involved in that incident might feel unfairly singled out, as the victims of passive-aggressive policy-making. So, better safe than sorry.

See also:
- [[http://www.catb.org/~esr/faqs/smart-questions.html][How To Ask Questions The Smart Way]]
- [[https://www.eyrie.org/~eagle/faqs/questions.html][Why Ask Questions in Public?]]
- [[http://xyproblem.info/][XY Problem]]

*** This Guide is Open Source

If you find any errors or want to make any changes, fork the repository, commit changes to your fork, and send a pull request.

The content of this guide is licensed under CC BY-NC-SA 4.0: https://creativecommons.org/licenses/by-nc-sa/4.0/

* Project-based Learning

If you're chomping at the bit, this section will satisfy -- or at least pique -- your curiosity about what we are trying to accomplish at CCLAW.

Actual tasks are defined elsewhere -- in Asana, or Github Issues -- but these are some of the main quests and side quests that the team may attempt over the coming months and years.

As you read through this list of projects, ask yourself: "how would I attempt to do this with the skills I currently possess? What new skills might I have to learn to achieve these goals?"

** Make it possible for a non-lawyer to think through a legal scenario with the help of their computer, without having to ask a human.

If you need to think about a business scenario that deals largely with numbers -- for example, with a budget -- you might turn to a spreadsheet and use that to "help you think".

Today, that's not possible for legal scenarios. You wouldn't open Microsoft Word and start typing and expect to see sentences automatically compute themselves, the way Excel might automaticallly calculate a sum or an average.

"Am I allowed to do X?"

"I want to achieve X. What do I need to do?"

"I want to make an agreement with someone else. Help me draft an agreement that sets out our respective obligations and deadlines."

"I've been asked to sign a contract for X. I'm concerned about scenario Y -- can I do Z, or will I have to do Z? How does X deal with Y?"

** Make it possible to encode a law or a contract in a formal language.

... this is the goal of the DSL track of work.

** Make it possible to convert such an encoded law or contract, back to a natural language such as English, automatically.

... and other languages, too.

This is the goal of the NLG track of work.

The English doesn't have to be super readable; it only has to be as good as [[http://revisor.mo.gov/main/OneSection.aspx?section=233.285&bid=12522&hl=][current legal writing]].

** Make it possible for a non-lawyer to download existing libraries and examples of source code written by other people, and tweak them.

... from Github, perhaps.

** Make it possible for somebody drafting in our DSL to get the same kind of help from their editor as you would for another language.

IntelliSense, tab completion, linting, type checking ... all these things should help a drafter.

This is the goal of the IDE track of work.

** Make it possible for advanced IDE features to help a drafter find bugs in their code.

"Your proposed law/contract makes it impossible for somebody to actually perform their obligations, because line 12 conflicts with line 63."

This is the goal of the FV track of work.

** Make it possible to embed an encoded contract via XML into a PDF using XMP.

XMP does for PDFs, what EXIF does for JPGs ... kind of.

** As part of DSL development, identify and leverage an existing formalism for constitutive rules.

As the Rates Rebates example shows, some rules are essentially mathematical formulae: how much rebate am I entitled to under condtions X and Y.

There are existing business tools that save us from reinventing that particular wheel. Explore DMN: Decision Model & Notation. There's a good tutorial by Camunda.

Read about the history and the pros and cons of Model-Driven Architecture.

** Specify DMNMD for Markdown

DMN is too good a DSL to be stuck in a graphical UI. Use Markdown tables to allow people who prefer text editors, to write decision tables in text.

What would a decision table look like, translated to Markdown? Let's call that DMNMD, where the "MD" stands for Markdown.

This is the start of the DMN track of work.

** Implement DMNMD in native Python

Now we have a way to avoiding massively complex if/then/else statements. Build it in Python.

- Read Hillelogram's article on decision tables.
- Try out the Camunda DMN demo online. Read their tutorial.
- Write documentation and a specification for DMNMD in your favourite language.
- Try converting some gnarly code you wrote recently to DMN syntax.
- Implement an MVP proof of concept in your favourite language for a simplified DMNMD: supporting only a unique hit policy and S-FEEL comparison expressions in your favourite language. Don't bother supporting separator escaping, just do a string split. You can revisit this and do a proper parser later when you have more programming language / compiler theory under your belt. You can do a simple implementation just by reading the Camunda tutorial, you don't even really need to read the DMN spec to grasp how it works.

** Implement DMNMD in native Typescript

Same as Python, but for Typescript. Stick your work on Github first. Then consider sticking it in npm under the SMUCCLAW account. Eventually this will become a top-level package.

** Implement DMNMD in your favourite language

If you come from some other language, like Rust or Go or Ruby, go nuts -- same idea as above.

** Document your implementation of DMNMD.

There are four kinds of documentation.

** Make it possible to convert a DMNMD table to natural language.

How would you spell out the DMNMD table in English?

This is part of the NLG track of work.

** Consider doing the same for BPMN that we did for DMN.

While DMN is "purer" in a functional sense, BPMN deals with multiple actors, passing messages to one another, acting in time.

** Build out planners, expert systems, and interactive scenario explorers.

See the Drools suite of systems, like OptaPlanner, for an example.

** Can legal text be drafted as a satisfaction of a system of constraints?

* README FIRST: Foundational reading and Courses

I'm impatient to get started! What should I read?

** [[http://cristal.inria.fr/~weis/info/commandline.html][In the Beginning was the Command Line]], Neal Stephenson

** [[https://www.amazon.sg/Clean-Coder-Conduct-Professional-Programmers/dp/0137081073][The Clean Coder]], by Robert C. Martin

** [[https://www.edx.org/course/cs50s-introduction-to-computer-science][CS50]] from edX

This is a roughly 12 week course.

https://courses.edx.org/courses/course-v1:HarvardX+CS50+X/course/

There are actually three different courses that I want you to take.
- [[https://courses.edx.org/courses/course-v1:HarvardX+CS50+X/course/][CS50x]] ::  the basic prata kosong
- [[https://cs50.harvard.edu/ai/2020/][CS50 AI]] :: seven lectures on different techniques in AI
- [[https://courses.edx.org/courses/course-v1:HarvardX+CS50L+Law/course/][CS50 for Lawyers]] :: revisit CS50, but from the perspective of lawyers

** Tracking Your Progress

If you'd like to use Asana to track your progress through these readings and exercises, you can create tasks for yourself, log your progress in the tasks, and click "done" when you've accomplished the task!

* [[http://matt.might.net/articles/what-cs-majors-should-know/][What Every Computer Science Major Should Know]], by Matt Might

Matt Might gathers on a single page what most university curricula incoherently scatter across four years' worth of course descriptions.

Robert Martin's /Clean Coder/ says "Know Your Field":

#+BEGIN_QUOTE
A wealth of ideas, disciplines, techniques, tools, and terminologies decorate the last fifty years of our field. How much of this do you know? If you want to be a professional, you should know a sizable chunk of it and constantly be increasing the size of that chunk.
#+END_QUOTE

At CCLAW, we focus on the "traditional AI" aspects of computer science: knowledge representation and reasoning ("KRR"), logic programming, scheduling and planning problems, rule systems.

But the more you learn, the better. Knowledge is power. If you ever find yourself struggling because you've bitten off more than you can chew, remember there are giants whose shoulders you can stand on.

I recommend taking up his curriculum in the following order:

** The Unix philosophy

The original Unix paper is at http://www.scs.stanford.edu/18wi-cs140/sched/readings/unix.pdf -- I think his link to it may have bit-rotted.

- https://www.amazon.com/UNIX-Linux-System-Administration-Handbook/dp/0134277554/ref=dp_ob_title_bk
- https://en.wikipedia.org/wiki/Unix_philosophy#:~:text=The%20Unix%20philosophy%20emphasizes%20building,as%20opposed%20to%20monolithic%20design.

If you run a Mac, you have a Unix system. If you run Windows, you may be successful with https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux, or you may be better off with an account on our shared AWS instance.

*** Shell multiplexing

You have your choice of tmux or screen.

*** Shells themselves

You have your choice of bash or [[https://ohmyz.sh/][zsh]].

** SICP

[[https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html][Structure and Interpretation of Computer Programs]] helps you realize how ubiquitous parsers and domain-specific languages are in computing. Every time you run a Python program in your terminal, at least two interpreters swing into action, doing an enormous amount of work within just a few short milliseconds. Can you say what the interpreters are and what they do?

SICP expands your mental vocabulary and grammar; you will start to think about computing problems the way computer scientists do.

** About Editors

A good first editor nowadays might be VS Code, Atom, or Sublime.

If you are a Mac user, learn just enough Emacs to use its keybindings,
and then see where else those keybindings work. The tutorial should
take you about an hour. See https://gist.github.com/cheapRoc/9670905

Speaking of keybindings, you may enjoy installing [[https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?hl=en][Vimium]] for your web browser, so you don't have to reach for the mouse so often.

** Languages

From Matt Might's list, I would suggest starting with

- Javascript :: (update: Typescript and Deno); this is the /lingua franca/ of the web today.
- Python :: after Javascript will give you a good appreciation for "comparative linguistics" -- you can analyze differences in vocabulary and grammar, and begin to abstract the idea of a language feature. Python and Javascript are like two dialects of Chinese.
- Haskell :: Read [[https://pchiusano.github.io/2017-01-20/why-not-haskell.html][Why Not Haskell]]; [[https://web.archive.org/web/20200608072453/https://dixonary.co.uk/blog/haskell/pain][The Pain Points of Haskell]]; [[https://www.stephendiehl.com/posts/marketing.html][On Marketing Haskell]] to prepare yourself for a very different, almost alien, mode of thought. You may, after some time, say "nice place to visit, don't want to live there." But you will never use [[https://lodash.com/][lodash]] the same way again; and when you work with a dynamically typed language, you will better understand what people mean when they say "[[http://earlbarr.com/publications/typestudy.pdf][BIGNUM% of bugs are type errors]]".
- Prolog :: for an introduction to unification and backtracking as first-class language features; know enough to appreciate [[https://www.metalevel.at/prolog][the Power of Prolog]].
- Racket :: enough Lisp to hack your .emacs, understand homoiconicity, and appreciate the [[http://winestockwebdesign.com/Essays/Lisp_Curse.html][Lisp Curse]] essay.

together, these will give you good exposure to enough programming paradigms that you will know which language to use for a given situation.

Once you're there, you can proceed to more advanced, specialized languages. For example, if you work in constraint or logic programming, you can explore Curry, Flora-2, and ErgoAI.

Most programming languages take at least two weeks to even begin to
grapple with. Getting the compiler installed, and your editor working
with the language, may take an hour if you're lucky or a day if you're
not. Any introductory tutorial will come with exercises that you
really should work through. After that, it will take you many months
to get good -- to know the idioms, the warts, and the libraries.

For the purposes of this curriculum you might choose to dedicate at
least three months to each language; and you should use all the
resources you can find, including books (yes, actual physical hardcopy
books from the library -- sometimes softcopy books have formatting and
layout issues which create unnecessary mysteries), video courses,
online documentation and third-party tutorials, and community forums.

http://www.rosettacode.org/wiki/Rosetta_Code is kind of like cheat codes: "programming chrestomathy".

*** Standard Skills

In every language you should master a basic set of useful skills:
- read, manipulate, and write text files, line-by-line
- work with regular expressions; implement grep
- retrieve a URL
- interact with the end user at the terminal or in a REPL
- read, manipulate, and write JSON
- read, manipulate, and write XML
- read, manipulate, and write HTML

You should be able to implement a web scraper in at least one language. Don't worry, there are plenty of good libraries out there, like Puppeteer for Javascript.

*** Implementing an interpreter

Work through the New Zealand Benefits RaC exercise (link to be provided).

*** Haskell online resources

Matt Might says: "Haskell is the crown jewel of the Hindley-Milner family of languages. Fully exploiting laziness, Haskell comes closest to programming in pure mathematics of any major programming language."

This statement is worth unpacking. Back in the 1990s, an influential book was published with the title /[[https://en.wikipedia.org/wiki/Software_design_pattern][Design Patterns]]/: essentially, problems that repeatedly arise in software development, and how to solve them.

For example, in cooking, every culture implements the Dumpling pattern: a meat or vegetable filling is wholly encapsulated by a carbohydrate layer, and cooked. The insides stay edible longer, because the carbohydrate layer acts as a barrier to microbes and insects. The product is also easier to handle as the outside layer stays dry while the insides are moist. To quote the [[https://www.dumplingemoji.com/][Dumpling Emoji Project]]: "Dumplings are a seemingly universal food, popular throughout the world’s cultures. Poland has pierogi. Nepal has momos. Russia has pelmeni. Japan has gyoza. Italy has ravioli. Georgia has khinkali. Korea has mandoo. Argentina has empanadas. Jews have kreplach. China has potstickers."

As the Wikipedia page notes, /a primary criticism of Design Patterns is that its patterns are simply workarounds for missing features in C++, replacing elegant abstract features with lengthy concrete patterns, essentially becoming a "human compiler" or "generating by hand the expansions of some macro". Peter Norvig demonstrates that 16 out of the 23 patterns in Design Patterns are simplified or eliminated (via direct language support) in Lisp or Dylan./

Haskell programmers, being masters of abstraction, would agree: if a certain programming problem keeps recurring, then obviously the correct approach is to solve the general case in the form of a reusable library; that library abstracts out the essence of the pattern, taking care of the hard bits, and allows you to customize it to suit your particular problem.

Follow that line of thinking to its logical conclusion, and you might observe that writing Haskell bears certain similarities to the composition of certain challenge poems in Imperial China, where the challenge forbade repetition: you couldn't use the same word twice through the entire poem.

In Haskell, the idea of factoring out repeated code can be taken to the extreme.

Because such advanced patterns are embodied in the language itself and its frequently-used libraries, Haskell could fairly be considered of the hardest languages to learn: writing a new program in Haskell is like writing a poem in Classical Chinese, in which every other phrase is required to reference a different classic poem written by a centuries-dead master.

The upside: when you look at code written by less sophisticated programmers in less sophisticated languages, your first reaction will be: "90% of the work you're doing here isn't even about solving your actual problem; it's just you micromanaging the computer to get you to the point of being able to solve it. But in Haskell you wouldn't have to do that 90% because it's already taken care of by the language or some standard library."

Of course, to be fair, Joel's Law of Leaky Abstractions suggests that one day, sooner or later, you will have to grapple with the abstracted-away complexity: just because it's hidden in somebody else's library doesn't mean you won't have to figure it out for yourself.

All that being said: these resources are recommended:

- http://haskellbook.com/
- https://www.udemy.com/course/learning-path-haskell-functional-programming-and-haskell/ offers 73 lectures.
- http://dev.stephendiehl.com/hask/
- https://ocharles.org.uk/posts/2014-12-01-24-days-of-ghc-extensions.html
- https://ocharles.org.uk/pages/2012-12-01-24-days-of-hackage.html
- https://ocharles.org.uk/pages/2013-12-01-24-days-of-hackage.html

"Learn You A Haskell" has been popular for some time, perhaps due to stylistic similarities with /[[https://en.wikipedia.org/wiki/Why%27s_(poignant)_Guide_to_Ruby][why's (poignant) Guide to Ruby]]/, but it was written at a time when those other two resources were not available. Now that they are, I no longer recommend LYAH.

** Formal Methods

- https://www.hillelwayne.com/post/decision-tables/
- https://www.theatlantic.com/technology/archive/2017/09/saving-the-world-from-code/540393/

** Artificial Intelligence

- Gödel, Escher, Bach.
- Russell & Norvig.
- https://www.doc.ic.ac.uk/~rak/history.pdf
- https://www.doc.ic.ac.uk/~rak/papers/newbook.pdf
- https://cs50.harvard.edu/ai/2020/

** Networking

Understand the workings of TCP/IP, UDP, DNS, SMTP, and HTTP.

Using the ~telnet~ or ~netcat~ commands, send an email by hand by talking to SMTP port 25.

Load a web page by hand by asking for it from port 80.

Visit the history of cloud computing (once called "grid computing"). Visit a machine room after reading [[http://www.winestockwebdesign.com/Essays/Eternal_Mainframe.html][The Eternal Mainframe]].

** Ethics

Discuss:

- What did "[[https://quoteinvestigator.com/2018/04/24/ink/][I never argue with a man who buys ink by the barrel]]" mean when it was first said? What argument do [[https://www.theatlantic.com/technology/archive/2014/08/advertising-is-the-internets-original-sin/376041/][The Internet's Original Sin]] and [[http://www.winestockwebdesign.com/Essays/Eternal_Mainframe.html][The Eternal Mainframe]] have in common? Where would you locate projects like [[https://www.nytimes.com/2019/05/13/us/politics/georgia-official-code-copyright.html][Carl Malamud's Public.Resource]], [[https://freedombox.org/][FreedomBox]], and [[https://www.wired.com/story/join-mastodon-twitter-alternative/][Mastodon]] on a spectrum relative to Facebook, LexisNexis, and Westlaw? What predictions did [[https://www.amazon.com/Master-Switch-Rise-Information-Empires/dp/0307390993][Tim Wu's Master Switch]] make, and how have those predictions fared in the ten years since publication?
- What is an imprimatur? How did state and religious powers respond to the invention of the printing press? The life of Christophe Plantin may prove instructive. How were his professional duties at odds with his personal beliefs? The dates June 1, 1501, and June 15, 1520, may turn up as significant in your research. How would you compare those events with [[https://www.forbes.com/sites/carlieporterfield/2020/06/03/twitter-suspends-account-copying-trumps-tweets-for-glorifying-violence/][news from June 3, 2020]]?
- How do you see these considerations applying to the future of legal tech, and to the specific aims of the Research Programme in Computational Law?
- Why factors contribute to the widespread sharing of standards via forums like the IETF, sharing of software on sites like Github, and to the sharing of knowledge about software on sites like Khan Academy, Udemy, and Stack Overflow? What degree of sharing can be found in other fields such as medicine, accounting, law, makeup, cooking, costuming, and applied psychology?

** The rest of Matt Might's curriculum

... can probably wait until you find yourself embarking on specific side quests that need those skills. While the research programme does not touch these areas specifically, every working (web-era) programmer should know:

- SQL (Postgres, SQLite, or MySQL)
- Apache and Nginx; wget and curl
- Some Javascript framework for front-end development
- basic public-key cryptography (GPG to understand the concepts, openssl to create an SSL certificate of your own)

Enough OS architecture to understand https://blog.quarkslab.com/playing-around-with-the-fuchsia-operating-system.html

Content addressing. [[https://en.wikipedia.org/wiki/Distributed_hash_table][DHTs]]. The architeture of BitTorrent. IPFS. And [[https://www.unisonweb.org/docs/tour][Unison]]. [[https://nixos.org/features.html][Nix and NixOS]].

** Law as an Application Domain in Computer Science

- https://courses.edx.org/courses/course-v1:HarvardX+CS50L+Law/course/

* Other Things An Educated Technologist Should Know

In conversations among experienced technologists, many of the following references are expected to be common knowledge "within the tribe".

** History of the Internet and the Web
*** [[https://www.theatlantic.com/magazine/archive/1945/07/as-we-may-think/303881/][As We May Think, by Vannevar Bush]] introduces the Memex
**** Probably the closest thing today is [[https://roamresearch.com/][Roam Research]]. Give it a try, see if you like it.
**** What is the history of Wikipedia? Where did wikis come from? What was the first wiki?
**** If you are an Emacs user, try out [[http://orgmode.org/][org-mode]]. There are online tutorials.
**** Open Source Community Culture

A great deal of Unix history is bound up with the FOSS movement.
- The [[https://www.gnu.org/gnu/manifesto.en.html][GNU Manifesto]] and [[https://www.gnu.org/licenses/gpl-3.0.html][Public License]]
- [[http://www.catb.org/~esr/writings/cathedral-bazaar/][The Cathedral and The Bazaar]]
- https://opensource.com/resources/what-open-source
- http://creativecommons.org/

*** [[https://www.amazon.sg/Soul-New-Machine-Tracy-Kidder/dp/0316491977][The Soul of a New Machine]] and [[https://en.wikipedia.org/wiki/Halt_and_Catch_Fire_(TV_series)][Halt & Catch Fire]] go well together

*** [[https://en.wikipedia.org/wiki/The_Mother_of_All_Demos][The Mother of All Demos]]

*** [[http://worrydream.com/dbx/][The Future of Programming, by Bret Victor]]

*** When and what was the AI Winter and the AI Spring?


*** [[https://www.imdb.com/title/tt1285016/][The Social Network]]
about Facebook

*** Jobs biography movies
there are quite a few

*** Infrastructure

- What is an IP address?
- What are the reserved IP addresses?
- What is your IP address?
- How is an IP address different from an ethernet address?
- What is your ethernet adress?
- What is a domain name?
- What is a URL?
- What is the URL, domain name, and IP address for the last website you opened?
- What is HTML?
- What is HTTP?
- What is an RFC?
- What RFC defines HTTP?
- What is the IETF?
- What is RFC 2119? What piece of legislation in your country is most similar to RFC 2119?

** Science Fiction
*** Neuromancer, William Gibson
*** Snow Crash, Neal Stephenson
*** Diamond Age, Neal Stephenson

** Critical Thinking
*** [[https://en.wikipedia.org/wiki/Wason_selection_task][The Wason Selection Task]]
*** [[https://www.theatlantic.com/magazine/archive/2018/09/cognitive-bias/565775/][Cognitive Biases]]
*** [[https://thebestschools.org/magazine/15-logical-fallacies-know/][Logical Fallacies]]

** [[http://threevirtues.com/][The Three Virtues of a Programmer]]

** Software Engineering as a Professional Career

*** [[https://www.amazon.sg/Clean-Coder-Conduct-Professional-Programmers/dp/0137081073][The Clean Coder, by Robert C. Martin]]

makes a case for test-driven development and argues for professionalization of software engineering.

*** Hamming's Art of Doing Science and Engineering: http://worrydream.com/refs/Hamming-TheArtOfDoingScienceAndEngineering.pdf


** Hacker Culture

*** [[http://www.catb.org/~esr/jargon/html/appendixb.html][A Portrait of J. Random Hacker]] offers a snapshot from the early days of the American Internet, reflecting the gender and cultural biases prevalent at that time.
*** [[http://www.catb.org/~esr/faqs/smart-questions.html][How To Ask Questions The Smart Way]]
*** [[https://sol.gfxile.net/dontask.html][Don't ask to ask, just ask]]
*** [[https://www.eyrie.org/~eagle/faqs/questions.html][Why Ask Questions in Public?]]
*** [[http://xyproblem.info/][XY Problem]]
*** [[https://www.ietf.org/about/participate/tao/][The Tao of IETF]]

** Open Source

If you're new to open source, there are plenty of guides out there:
- https://opensource.guide/how-to-contribute/

After you've gained some familiarity with open source and open standards in computing, 

** Communities of Coders

[[https://github.com/][Github]] was once described as a social network where every post has to make the world better in some way.

- https://www.atlassian.com/git/tutorials/merging-vs-rebasing

[[https://stackoverflow.com/][Stack Overflow]] is where we go to ask for help. Don't just be a taker, be a giver too: answer other people's questions, and soon you'll be learning much faster than if you were only trying to answer your own.

Go on IRC and lurk on your favourite channels; when I'm learning a new technology, watching other people struggle with problems, and watching the experienced members of the channel help out, is like a sneak preview of the issues I can expect to face in a few weeks or months myself, and a cheat code to learn the answers ahead of time.

If you already know Python, then sit on the Freenode #python channel.

If you already know Javascript, then sit on the Freenode #javascript channel. Or #typescript.

Watch newbies pop up with questions.

Watch how the experienced members of the channel deal with them.

When a new question comes up, can you get to the answer before someone else does?

** Data Visualization, Graphic Design, and Architecture

*** [[https://www.edwardtufte.com/tufte/books_vdqi][Edward Tufte's books]] are a classic in visual communications.

*** [[https://www.amazon.sg/Elements-Typographic-Style-Version-4-0/dp/0881792128][Robert Bringhurst does for typography]] what Tufte does for graphics.

*** [[https://www.amazon.com/Pattern-Language-Buildings-Construction-Environmental/dp/0195019199][A Pattern Language]], and Christopher Alexander's other books.

inspired the software design patterns movement.

** Professional and Collegial Communication

*** It's okay to say "I don't know".

All things considered, humans are pretty good at making guesses under conditions of uncertainty: it's what we're evolved to do.

But science and engineering are domains where admitting that you don't know the answer, is a virtue -- or at least, an important fact so that others do not proceed on faulty or incomplete information.

In fact, the scientific method itself could be seen as turning "I don't know" into an engine responsible for most of the human advancement of the last four hundred years.

If we were less embarrassed about our own ignorance, we would cure it much faster. Just think of anybody who admits "I don't know" as one of [[https://xkcd.com/1053/][today's lucky 10,000]].

https://www.pinkelephantcomms.com/dont-know-answer/

*** Egoless programming requires psychological safety.

https://en.wikipedia.org/wiki/Egoless_programming

https://en.wikipedia.org/wiki/The_Five_Dysfunctions_of_a_Team

https://en.wikipedia.org/wiki/Psychological_safety

*** Crucial Conversations: https://www.amazon.com/Crucial-Conversations-Talking-Stakes-Second/dp/1469266822

** The School vs Work Value System

20th-century style schooling imparts the following unspoken rules:
- The problem is a standard question which has been solved before; there is a known, correct answer.
- The problem is a slight variation on something posed to millions of other schoolchildren.
- You have to solve it on your own; working with others is considered cheating.
- Looking up the answer is considered cheating.

At about age 20--25, if you move into tech, the rules change:
- The problem has never been solved before; if a known answer existed, you would be able to download it.
- While the problem may be a variation on a theme, you may never have been properly taught that theme.
- You are encouraged to work with colleagues to solve the problem as well and as fast as you can.
- Looking up the answer is called "research". How do you do research? You can start by searching Google. At least twice. Or it wouldn't be re-search. Ha, ha.

Sometimes you will encounter somebody who seems to be applying the school value system at work, applying long hours to developing their own solution to a problem which they could have just downloaded, and refusing to accept outside help because that would be cheating. Be careful not to be that person.

** Domain Specific Languages

As Bjare Stroustrup once remarked, if you're trying to solve a problem, first design a programming language expressive enough to elegantly represent solutions in your problem domain; implement the language with an interpretr or compiler or embedded DSL; then implement the solution to your original problem in that language, which should now be simple enough for you to do "as an exercise for the reader."

You may already know a number of DSLs: HTML; Markdown; Wiki; regular expressions; TeX and LaTeX; Makefile syntax; shell scripts. You can think of them as side quests.

** Lost Arts from the Early Days of Computing

Hillel Wayne's [[https://www.hillelwayne.com/post/decision-tables/][introduction to Decision Tables]] describes them as having "fallen out of common knowledge". It is interesting to think of computing, being one of the youngest disciplines in the world relative to, say, medicine or law, as being old enough to have a history that people forget; but so it goes.

** Innovation and Business

*** [[https://www.amazon.com/Innovators-Solution-Creating-Sustaining-Successful/dp/1422196577][Clayton Christensen's Disruption Framework]]

*** [[https://www.cio.com/article/3526687/an-introduction-to-wardley-value-chain-mapping.html][Wardley Maps]]

*** [[https://www.amazon.com/Doing-Capitalism-Innovation-Economy-Speculation/dp/1107031257][Doing Capitalism in the Innovation Economy, by Janeway]]

*** [[https://www.amazon.com/Nature-Technology-What-How-Evolves/dp/1416544062][The Nature of Technology]] by W. Brian Arthur

*** [[https://www.amazon.com/Inside-Publishing-Revolution-Adobe-Story/dp/0321115643][Inside the Publishing Revolution]]
is a history of Adobe

* Apprenticeship

The Centre works with a number of senior engineers. Juniors will have the opportunity to join them in pair programming sessions.


