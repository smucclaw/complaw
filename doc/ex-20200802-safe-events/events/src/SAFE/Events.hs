{-# LANGUAGE OverloadedStrings, DuplicateRecordFields, QuasiQuotes, LambdaCase #-}
{-# OPTIONS_GHC -F -pgmF=record-dot-preprocessor #-}

-- DO NOT EDIT THIS FILE!
-- direct edits will be clobbered.
--
-- this file is autogenerated by tangling ex-20200802-safe-events/README.org
-- open the README.org in emacs and hit C-c C-v t to regenerate this file.

module SAFE.Events where
import Data.Map
import Data.Maybe
import Data.Tree
import Data.Tree.Pretty

data Imbued a = Imbued { underlying :: a
                       , attrs      :: Map String MyParamVal }
data EventBody = EvName String
               | GreenLight -- once the light turns green i.e. the clause is "entered"
               | NoticeReceived String (Maybe Party)
               deriving (Show, Eq)

-- every node has two children.
-- tail is the happy path, to which "execution" proceeds if the node is performed satisfactorily
-- head is the unhappy path.
type Agreement = Tree Clause

-- TODO: devise a monadic notation to make this even more readable as an EDSL
-- this syntax allows us to say x `hence` y `lest` z
infixr 7 `hence`
infixr 7 `lest`
x `hence` yz = Node x yz
y `lest`  z  = [ z, y ]

data Party = Party { name :: String
  , attrsc :: (Map String MyParamVal)
  } deriving (Show, Eq)
data Transaction = MkTxn [Party] Agreement
getAgreement (MkTxn ps a) = a

type MyYMD = (Integer, Int, Int)
type Event = (Maybe MyYMD, EventBody)
data Deontic = Must | May | Shant deriving (Show, Eq)

data State = World { date :: MyYMD
                   , history :: [Event]
                   } deriving (Show, Eq)
type ActionParams = Map String MyParamVal
data MyParamVal = MyString String
                | MyBool   Bool
                | MyInt    Int
                | MyChar   Char
                | MyList   [MyParamVal]
                deriving (Show, Eq)
mystr  (MyString x) = x
mybool (MyBool   x) = x
myint  (MyInt    x) = x
mychar (MyChar   x) = x
mylist (MyList   x) = x
data Action = MkAct { name   :: String
                    , params :: ActionParams }
            deriving (Show, Eq)

-- todo: expand this to the fuller set of DMN temporal predicates
data Temporal = T_Before MyYMD
              | T_After  MyYMD
              | T_Event  EventBody -- how to scope a relative event reference?
              | T_Rel    Days Temporal
              deriving (Show, Eq)
type Days = Int

data Clause = MkCl { name       ::  String
                   , conditions :: [State]
                   , upon       ::  Event
                   , parties    :: [Party]
                   , deontic    ::  Deontic
                   , actions    :: [Action]
                   , temporal   ::  Temporal
                   }
            | Fulfilled
            | Breach
  deriving (Show, Eq)
fulfilled = Node Fulfilled []
breach    = Node Breach []
getName MkCl { name = n } = n
getName Fulfilled         = "Fulfilled"
getName Breach            = "Breach"
transferFunds :: MyYMD -> Party -> Int -> String -> Clause
transferFunds closingDate investor amount dest =
  MkCl { name       = "transfer funds"
       , conditions = []
       , upon       = (Just closingDate, EvName "closing")
       , parties    = [investor]
       , deontic    = Must
       , actions    = [MkAct "transfer funds"
         (fromList [("currency",    MyString "USD")
                   ,("amount",      MyInt    amount)
                   ,("destination", MyString dest)])]
       , temporal   = T_Rel 3 (T_Event (EvName "closing"))
  }
issuePreferred :: Party -> Party -> Int -> Clause
issuePreferred company investor numShares =
  MkCl { name       = "issue shares"
       , conditions = [] -- always
       , upon       = (Nothing, GreenLight)
       , parties    = [company]
       , deontic    = Must
       , actions    = [MkAct "issue shares"
                      (fromList [("issues",          MyBool True)
                                ,("sells",           MyBool True)
                                ,("security",        MyString "preferred")
                                ,("valuation_fixed", MyBool True)
                                ,("val_p_p_o",       MyString "pre_money")
                                ,("numShares",       MyInt numShares)
                                ])]
       , temporal   = T_Rel 5 (T_Event (EvName "closing"))
       }

mktxns :: Party -> [(Party,Int)] -> MyYMD -> Float -> [Transaction]
mktxns company investorAmounts closingDate pricepershare = do
  (investor,amount) <- investorAmounts
  let investorSendsMoney  = transferFunds closingDate investor amount (unwords $ mystr <$> [attrsc company ! k | k <- [ "bank", "acct" ] ])
      companyIssuesShares = issuePreferred company investor (floor (fromIntegral amount / pricepershare))
  return $
    -- a transaction is an agreement between the parties: company and investor
    MkTxn [company,investor]
    -- the state graph of the contract. you may consider this a finite state machine.
    (investorSendsMoney
      `hence` (companyIssuesShares
                `hence` fulfilled
                `lest`  breach)
      `lest`  breach)
-- the "hence" and "lest" bits basically mean "then" and "else"
-- see section 2.3 of Hvitved https://drive.google.com/file/d/1sLmVMZqHhQDzj8dikKt-8CNemF-nGCn1/view?usp=sharing
-- together, "hence" and "lest" construct a tree of clauses:
--       Node investorSendsMoney [ Node Breach [],
--                                 Node companyIssuesShare [ Node Breach [], Node Fulfilled [] ] ]
-- in which the first element is "what if the clause fails" and the second element is "what if the clause succeeds, then control passes to ..."

-- this agreement is an example of a declarative specification, and contains enough information for a PGF component to generate English:

--     "When in the course of human events on the date of closing the
--     aforesaid Investor pays the Correct Sum, being 100,000 Dollars,
--     then immediately and without delaye the Company shall issue
--     five hundred Shares of Preferred Stock and if it should fail to
--     do so within five days the Company shall be in BREACHE!."

asDAG :: Transaction -> String
asDAG (MkTxn parties agreement) = unlines [ unwords ( "Parties:" : ( ( name :: Party->String ) <$> parties ) )
                                          , drawVerticalTree ( getName <$> agreement ) ]
