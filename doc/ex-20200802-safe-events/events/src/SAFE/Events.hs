{-# LANGUAGE OverloadedStrings, DuplicateRecordFields, QuasiQuotes #-}
{-# OPTIONS_GHC -F -pgmF=record-dot-preprocessor #-}

-- DO NOT EDIT THIS FILE!
-- direct edits will be clobbered.
-- 
-- this file is autogenerated by tangling ex-20200802-safe-events/README.org
-- open the README.org in emacs and hit C-c C-v t to regenerate this file.

module SAFE.Events where
import Data.Map
import Data.Maybe
import Data.Tree
import Data.Tree.Pretty

data Imbued a = Imbued { underlying :: a
                       , attrs      :: Map String MyParamVal }
data EventBody = EvName String
               | GreenLight -- once the light turns green i.e. the clause is "entered"
               | NoticeReceived String (Maybe Party)
               deriving (Show, Eq)

-- every node has two children.
-- tail is the happy path, to which "execution" proceeds if the node is performed satisfactorily
-- head is the unhappy path.
type Agreement = Tree Clause

-- TODO: devise a monadic notation to make this even more readable as an EDSL
-- this syntax allows us to say x `hence` y `lest` z
infixr 7 `hence`
infixr 7 `lest`
x `hence` yz = Node x yz
y `lest`  z  = [ z, y ]

data Party = Party { name :: String
  , attrsc :: (Map String MyParamVal)
  } deriving (Show, Eq)
data Transaction = MkTxn [Party] Agreement
getAgreement (MkTxn ps a) = a

type MyYMD = (Integer, Int, Int)
type Event = (Maybe MyYMD, EventBody)
data Deontic = Must | May | Shant deriving (Show, Eq)

data State = World { date :: MyYMD
                   , history :: [Event]
                   } deriving (Show, Eq)
type ActionParams = Map String MyParamVal
data MyParamVal = MyString String
                | MyBool   Bool
                | MyInt    Int
                | MyChar   Char
                | MyList   [MyParamVal]
                deriving (Show, Eq)
mystr  (MyString x) = x
mybool (MyBool   x) = x
myint  (MyInt    x) = x
mychar (MyChar   x) = x
mylist (MyList   x) = x
data Action = MkAct { name   :: String
                    , params :: ActionParams }
            deriving (Show, Eq)

-- todo: expand this to the fuller set of DMN temporal predicates
data Temporal = T_Before MyYMD
              | T_After  MyYMD
              | T_Event  EventBody -- how to scope a relative event reference?
              | T_Rel    Days Temporal
              deriving (Show, Eq)
type Days = Int

data Clause = MkCl { name       :: String
                   , conditions :: [State]
                   , upon       :: Event
                   , parties    :: [Party]
                   , deontic    :: Deontic
                   , actions    :: [Action]
                   , temporal   :: Temporal
                   }
            | Fulfilled
            | Breach
  deriving (Show, Eq)
fulfilled = Node Fulfilled []
breach    = Node Breach []
transferFunds :: MyYMD -> Party -> Int -> String -> Clause
transferFunds closingDate investor amount dest =
  MkCl { name = "transfer funds"
       , conditions = []
       , upon = (Just closingDate, EvName "closing")
       , parties = [investor]
       , deontic = Must
       , actions = [MkAct "transfer funds"
         (fromList [("currency",    MyString "USD")
                   ,("amount",      MyInt    amount)
                   ,("destination", MyString dest)])]
       , temporal = T_Rel 3 (T_Event (EvName "closing"))
  }
issuePreferred :: Party -> Party -> Int -> Clause
issuePreferred company investor numShares =
  MkCl { name = "issue shares"
       , conditions = [] -- always
       , upon       = (Nothing, GreenLight)
       , parties    = [company]
       , deontic    = Must
       , actions    = [MkAct "issue shares"
                      (fromList [("issues",          MyBool True)
                                ,("sells",           MyBool True)
                                ,("security",        MyString "preferred")
                                ,("valuation_fixed", MyBool True)
                                ,("val_p_p_o",       MyString "pre_money")
                                ,("numShares",       MyInt numShares)
                                ])]
       , temporal   = T_Rel 5 (T_Event (EvName "closing"))
       }

mktxns :: Party -> [(Party,Int)] -> MyYMD -> Float -> [Transaction]
mktxns company investorAmounts closingDate pricepershare = do
  (investor,amount) <- investorAmounts
  let investorSendsMoney  = transferFunds closingDate investor amount (unwords $ mystr <$> [attrsc company ! k | k <- [ "bank", "acct" ] ])
      companyIssuesShares = issuePreferred company investor (floor (fromIntegral amount / pricepershare))
  return $
    -- a transaction is an agreement between the parties: company and investor
    MkTxn [company,investor]
    -- the state graph of the contract. you may consider this a finite state machine.
    (investorSendsMoney
      `hence` (companyIssuesShares
                `hence` fulfilled
                `lest`  breach)
      `lest`  breach)
asDAG :: Transaction -> String
asDAG (MkTxn parties agreement) = unlines [ unwords ( "Between" : ( ( name :: Party->String ) <$> parties ) ) 
                                          , drawVerticalTree ( ( name :: Clause -> String ) <$> agreement ) ]
