{-# LANGUAGE OverloadedStrings, DuplicateRecordFields, QuasiQuotes #-}
{-# OPTIONS_GHC -F -pgmF=record-dot-preprocessor #-}

-- DO NOT EDIT THIS FILE!
-- direct edits will be clobbered.
-- 
-- this file is autogenerated!
-- open the parent README.org in emacs and hit   C-c C-v t   to regenerate this file.

module L4.Parser where
import L4.Types
import Text.Megaparsec
import Text.Megaparsec.Char
import qualified Data.List.NonEmpty as NE
import qualified Text.Megaparsec.Char.Lexer as L
import Data.Void
import Data.List.Split

type Parser = Parsec Void String

l4program :: Parser L4Program
l4program = do
  many newline
  statements <- many l4statement
  many newline
  eof
  L4Program { statements = statements, hints = [] } <$ eof

l4statement :: Parser Statement
l4statement = do
  ruleNum <- string "RULE" >> sc *> integer
  stm <- stmDeem (Stm "source text" "filename" 0 (Just ruleNum)) -- <|> stmDefine <|> stmRegulative
  return stm

stmDeem :: StmCommon -> Parser Statement
stmDeem stmc = do
  oa <- (lexeme "DEEM" *> lexeme objectAttribute) <?> "deem line"
  ce <- conditionExpr <?> "condition expression"
  return $ Deem (HHOP oa) ce stmc

objectAttribute :: Parser ObjectAttribute
objectAttribute = do
  mychars <- many (alphaNumChar <|> char '.' <|> char '_')
  let mywords = splitOn "." mychars
  return $ MkOP (ObjectSpec (NE.fromList $ init mywords)) (last mywords)

conditionExpr :: Parser ConditionExpr
conditionExpr = do
  ce <- lexeme "WHEN" *> (many $ noneOf ("\n" :: String))
  return $ MkCE Normal (CEStr ce)


-- see https://markkarpov.com/tutorial/megaparsec.html
sc :: Parser ()
sc = L.space
  space1                         -- (2)
  (L.skipLineComment "//")       -- (3)
  (L.skipBlockComment "/*" "*/") -- (4)

lexeme :: Parser a -> Parser a
lexeme = L.lexeme sc

symbol :: String -> Parser String
symbol = L.symbol sc

integer :: Parser Int
integer = lexeme L.decimal
