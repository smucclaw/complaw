#+TITLE: Hello World for Deliverable Rules

Government regulations decree that potatoes may be traded only if they are harvested from plants planted on the two days immediately preceding and following a full moon, unless an exemption is granted by the Director of Agriculture.

* Background

Rules As Code is a fine idea, but very abstract. What could it look like, concretely?

Suppose a client wants to place an order for a Rules As Code project. The client is a system integrator project manager type entity. Their initial architecture diagram breaks down the moving parts thus:

| role          | responsibility                                            |
|---------------+-----------------------------------------------------------|
| App Developer | Produce working front-end UI                              |
|               | which interacts with end-user                             |
|               | based on back-end rules                                   |
|               | to elicit user input                                      |
|               | and produce advisory opinions                             |
|               | and produce documents for filing.                         |
|---------------+-----------------------------------------------------------|
| Back-end      | Produce an API implementing an expert system rule engine: |
| rule engine   | given a current goal and knowledge state,                 |
| developer     | returns a list of working assumptions,                    |
|               | tentative conclusions, and questions to ask,              |
|               | which will help the system get closer to the goal.        |
|               | This rule engine in turn relies on a rule base.           |
|---------------+-----------------------------------------------------------|
| Back-end      | Produce a library of rules consumable by a rule engine:   |
| rule base     | The rules include an ontology / type system,              |
| developer     | forward-chaining (if/then) rules, and                     |
|               | backward-chaining (then/if) rules.                        |
|               | The rules also encode constitutive rules and              |
|               | prescriptive rules.                                       |

In this project, the rule engine and rule base developer are the same party. It is possible that in future, a previously developed rule base can be repurposed and reused. Other apps and rule engines may wish to consume the same rules. Or the front-end app developer may prefer to include the rule base in their single-page app directly, with a minimal embedded rule engine.

* Case, version 1:

Government regulations decree that potatoes may be traded only if they are harvested from plants planted on the two days immediately preceding and following a full moon, unless an exemption is granted by the Director of Agriculture.

Farmers want to know:
- when are the next available dates for planting potatoes?
- what counts as a potato?
- given a past potato already planted on a given date, was that potato legal?
- what is the penalty for planting an illegal potato?
- what paperwork do I need to file, if any, in compliance with this regulation?

Rule developers want to know:
- For the purposes of the regulations, when does a full moon occur?
- What algorithm determines the mapping from a full moon to the two approved days?
- What if a full moon technically occurs at noontime on a given day? In other words the moon is equally full on two nights.

App developers want to know:
- knowing that the rules are strange and arbitrary and may change in the future at any time, what reasonably robust architecture can be expected to survive future regulatory changes without much re-work, if any?

* Assumptions

Let's assume that an authoritative list of full-moon dates exists at https://www.almanac.com/astronomy/moon/full

* Test Cases

** When are the next available dates for planting potatoes?

*** App: data panel in app shows the next four dates available for planting

The app requests dates from a rule engine over the usual JSON API.

#+begin_src json
// the app asks:
{ "request": { "key":  "nextAvailableDates"
             , "for":  "potatoes"
             , "date": "2020-08-06"
             , "asOf": "2020-08-06"
             , "limit": "4"
             , "id":   "1001", "version": "1", "locale": "en_SG" } }

// the rule engine answers:
{ "response": { "id": "1001"
              , "dates": ["2020-09-01", "2020-09-02", "2020-10-01", "2020-10-02"] } }
#+end_src

It's up to the app to convert the dates to a more human-friendly representation.

*** Rule engine: requests relevant rules in an executable form from the rule base

To compute those dates, the rule engine requested the underlying rules from the rule base, in an executable form.

#+begin_src json
  { "request": { "key":  "nextAvailableDates"
               , "for":  "potatoes"
               , "date": "2020-08-06"
               , "asOf": "2020-08-06"
               , "lang": "typescript"
               , "id":   "1002", "version": "1", "locale": "en_SG" } }
#+end_src

The response from the rule base shows up as a non-Turing-complete, "safe" subset of Typescript:

#+begin_src typescript :tangle potato.ts
    function nextAvailableDates (date: Date, asOf: Date, limit: number) : Date[] {
      return legalDates(asOf)
        .filter(x => x >= date)
        .splice(0, limit)
    }

    function legalDates(asOf: Date) : Date[] { // rule 4
      return fullMoonDates(asOf)
        .flatMap(x => [x, addDays(x,1)]) // \x -> [x, dateAdd x 1]
    }

    function fullMoonDates(asOf: Date) : Date[] { // rule 5
      return getDatesFromURL("https://www.almanac.com/astronomy/moon/full/")
    }

#+end_src

How did the rule base produce those functions?

*** Rule base

The rule base encodes the original decree in a semantically lossless, machine-readable form:

#+begin_src text :tangle potato.l4
   RULE   1
   PARTY  P
   SHANT  trade Item
   WHEN   Item.isPotato
   UNLESS Item.isLegalPotato
       OR UNLIKELY P.hasExemption(FROM DirectorOfAgriculture) // implicitly "THAT P MAY trade Item"
 
   RULE 2
   DEEM Item.isPotato
   WHEN Item.species ~ ["Solanum tuberosum"]
 
   RULE 3
   DEEM Item.isLegalPotato
   WHEN Item.isPotato
    AND Item.wasPlanted ~ anyOf LegalDates

     RULE 4
   DEFINE LegalDates
    BEING a list of dates each called LegalDate
    GIVEN FullMoonDates being a list of dates each called FullMoonDate
     EACH LegalDate
  MATCHES FullMoonDate
       OR FullMoonDate + 1
 
   RULE   5
   DEFINE FullMoonDates
 EXTERNAL url "https://www.almanac.com/astronomy/moon/full/"
#+end_src

This is enough information for a parser/interpreter to extract the following functions:

**** in Prolog

The Prolog-executable version of the rule shuffles things around a little to respect execution order:

#+begin_src prolog :noweb-ref prolog
rule(1, P, may, trade(Item))   :- rule(_,isPotato(Item)), rule(_, isLegalPotato(Item)).
rule(1, P, may, trade(Item))   :- rule(_,isPotato(Item)), hasExemption(P, from(directorOfAgriculture), that(P,may,trade(Item))).
rule(1, P, shant, trade(Item)) :- rule(_,isPotato(Item)), \+ rule(1, P, may, trade(Item)).
#+end_src

The extraction mechanism sinks the default "SHANT" to the bottom, and promotes the UNLESS exception to the top.

Rules 2 is a straightforward test of set membership.

#+begin_src prolog :noweb-ref prolog
rule(2, isPotato(Item)) :- member(Item.get(species), ["Solanum tuberosum"]).
#+end_src

Rule 3 is a similar test but implemented in a more natively-Prolog style. It needs rule 4.

#+begin_src prolog :noweb-ref prolog
rule(3, isLegalPotato(Item)) :- rule(_,isPotato(Item)), rule(_,legalDates(Item.get(wasPlanted))).
#+end_src

Rule 4 maps the externally given full-moon-dates to legal dates.

#+begin_src prolog :noweb-ref prolog
rule(4,
     legalDates(Date)) :- rule(_, fullMoonDates(FMD)),
                          ( Date = FMD ; 
                            form_time(FMD,datetime(J0,_)), J1 #= J0+1, form_time(Date,datetime(J1,0)) ).
#+end_src

Rule 5 retrieves the list of full-moon-dates from an external URL, [[https://www.swi-prolog.org/pldoc/man?section=http-clients][the details of which]] we will not go into here; we simulate that retrieval by directly inserting some dates into the store.

#+begin_src prolog :noweb-ref prolog
rule(5, fullMoonDates(2020-1-10)).
rule(5, fullMoonDates(2020-2-8)).
rule(5, fullMoonDates(2020-3-9)).
rule(5, fullMoonDates(2020-4-7)).
rule(5, fullMoonDates(2020-5-6)).
rule(5, fullMoonDates(2020-6-5)).
rule(5, fullMoonDates(2020-7-4)).
rule(5, fullMoonDates(2020-8-2)).
rule(5, fullMoonDates(2020-9-1)).
rule(5, fullMoonDates(2020-10-1)).
rule(5, fullMoonDates(2020-10-30)).
rule(5, fullMoonDates(2020-11-29)).
rule(5, fullMoonDates(2020-12-29)).
#+end_src

Now we can test the rule:

#+begin_src prolog :noweb-ref prolog
potato1(item{species:"Solanum tuberosum", wasPlanted:2020-1-10}).
potato2(item{species:"Solanum tuberosum", wasPlanted:2020-1-11}).
potato3(item{species:"Solanum tuberosum", wasPlanted:2020-1-12}).
hasExemption(nobody, from(no-one), that(nothing)).
#+end_src

And the output is as expected:

#+begin_example

?- potato1(I), rule(1, meng, Deontic, trade(I)).
I = item{species:"Solanum tuberosum", wasPlanted:2020-1-10},
Deontic = may .

?- potato2(I), rule(1, meng, Deontic, trade(I)).
I = item{species:"Solanum tuberosum", wasPlanted:2020-1-11},
Deontic = may .

?- potato3(I), rule(1, meng, Deontic, trade(I)).
I = item{species:"Solanum tuberosum", wasPlanted:2020-1-12},
Deontic = shant.

#+end_example

**** in Haskell

left as an exercise for the reader, ha ha.

**** in DMN

We assume the table of full-moon-dates is populated at compile time.

#+NAME: fullMoons
|  F | wasPlanted | legalDate1 |
|----+------------+------------|
|  1 | 2020-01-10 | True       |
|  2 | 2020-02-08 | True       |
|  3 | 2020-03-09 | True       |
|  4 | 2020-04-07 | True       |
|  5 | 2020-05-06 | True       |
|  6 | 2020-06-05 | True       |
|  7 | 2020-07-04 | True       |
|  8 | 2020-08-02 | True       |
|  9 | 2020-09-01 | True       |
| 10 | 2020-10-01 | True       |
| 11 | 2020-10-30 | True       |
| 12 | 2020-11-29 | True       |
| 13 | 2020-12-29 | True       |
| 14 |          - | False      |

The adjacent day can be derived by adding a duration of 1 day.

#+NAME: adjacentDay
| F | wasPlanted                         | legalDate2 |
|---+------------------------------------+------------|
| 1 | in (fullMoons.wasPlanted + P1DT0H) | True       |
| 2 | -                                  | False      |

Okay, we have to find a native FEEL way of saying the above. And we have to overload ~+~ to be an ~fmap +~ when applied to lists. We can deal with that later.

The item's legalDate attribute is true if either 1 or 2 is true.

#+NAME: legalDate
| F | item                     | legalDate |
|---+--------------------------+-----------|
| 1 | legalDate1 or legalDate2 | True      |
| 2 | -                        | False     |

Now we have enough information to answer the question: May we trade this item?

#+NAME: mayTrade
| F | species           | legalDate | exemptionGranted | mayTrade |
|---+-------------------+-----------+------------------+----------|
| 1 | Solanum tuberosum | True      | -                | True     |
| 2 | Solanum tuberosum | False     | False            | False    |
| 3 | Solanum tuberosum | False     | True             | True     |
| 4 | -                 | -         | -                | NULL     |

Oh dear, we return a NULL because that's the closest we can get to having a ~Maybe Deontic~. This is on DMN, which explicitly subscribes to ternary logic, see 10.3.2.4.

The question is: may we trade? When we are dealing with potatoes, we
can give a ~Just True~ or ~Just False~ answer. But if the input
information is not about potatoes but about, say, a Hyrule Bass
instead, the answer is Nothing.

When Haskell looks up a key in a map, if the key isn't in the map at all, you get back Nothing. http://hackage.haskell.org/package/containers-0.6.3.1/docs/Data-Map-Strict.html#g:9

So if you think of ~Maybe Bool~ as ternary logic, you've got the right intuition.

**** in Typescript

we'll pretend we got back fullMoonDates from some URL.
#+begin_src typescript :tangle potato.ts
  function getDatesFromURL(_:string) : Date[] {
  return ([ "2020-01-10",
            "2020-02-08",
            "2020-03-09",
            "2020-04-07",
            "2020-05-06",
            "2020-06-05",
            "2020-07-04",
            "2020-08-02",
            "2020-09-01",
            "2020-10-01",
            "2020-10-30",
            "2020-11-29",
            "2020-12-29" ].map(x=>new Date(x)))
  }
#+end_src

So we can call `nextAvailableDates`:

#+begin_src typescript :tangle potato.ts
console.log("the next available dates are: " + JSON.stringify(nextAvailableDates(new Date("2020-08-06"), new Date("2020-08-06"), 4)));
#+end_src

Let's convert the remaining rules. First we set up a type for the generic deontic rule:

#+begin_src typescript :tangle potato.ts :noweb-ref clause_ts
  interface Clause {
    "conditions": Condition[];
    "party": Party[];
    "deontic": Deontic;
    "action": Action;
    "actionSpec": ActionSpec[];
    "temporal": Temporal;
  }

  type Condition  = string;
  type Party      = string;
  enum Deontic { must="MUST", may="MAY", shant="SHANT" };
  type Action     = string;
  type ActionSpec = Farmed;
  type Temporal   = string;
  interface World { "legalDates" : Date[] }
  interface Exemption { "from": string }

  interface Farmed { "species": string; "wasPlanted": Date }
#+end_src

Then we represent rules 1, 2, and 3:
#+begin_src typescript :tangle potato.ts :noweb-ref clause_ts
  function rule1(world : World, party : Party, action: Action, actionSpec: ActionSpec, exemption?: Exemption) : Deontic | undefined {
    if (action === "trade" && isPotato(actionSpec)) {
      if (isLegalPotato(actionSpec, world.legalDates) ||
        (exemption != undefined && exemption.from == "DirectorOfAgriculture")) {
        return Deontic.may
      }
      return Deontic.shant
    }
  }
  // functional-style method-at-large
  function isPotato(item : Farmed) : boolean { // rule 2
    return item.hasOwnProperty("species") && item.species === "Solanum tuberosum"
  }

  function isLegalPotato(item : Farmed, legalDates : Date[]) : boolean { // rule 3
    return (isPotato(item) && item.hasOwnProperty("wasPlanted") && legalDates.map(x=>x.valueOf()).includes(item.wasPlanted.valueOf()))
  }
#+end_src

Now we can ask another question:

**** in GF

Here's an abstract syntax that is very faithful to the structure of L4. I think the final version shouldn't necessarily be that, but as a first step, a straightforward GF representation is probably easier to understand.

These are my abstract syntax categories. _Rule_ is the start category, others are intermediate categories that contain useful constituents on our way to a complete rule.

#+begin_src gf :noweb-ref gfPotato
flags startcat = Rule ;

cat
  Rule ;        -- The start category
  Party ;       -- "farmer Meng"
  Object ;      -- "a potato"
  Action ;      -- "trade a potato", "be legal"
  Modal ;       -- "may/must/shan't …"
#+end_src

In addition to categories, a GF abstract syntax has _functions_. Let's start with the most important one.

#+begin_src gf :noweb-ref gfPotato
fun
  MkRule
    : Party      -- party
    -> Modal     -- may/must/shant
    -> Action    -- what they may/must/shan't do, e.g. "trade potatoes"
    -> Rule ;    -- "Rule 1: Meng shan't trade a potato."
#+end_src

A party, a modal and an action make up a rule.

Now let us define some parties. We want any name to be a possible party, so we add a function `MkParty` that takes a string literal to a party.
In addition, we define two special parties `Nobody` and `Everybody`.

#+begin_src gf :noweb-ref gfPotato
-- Parties
  MkParty : String -> Party ;  -- Party name can be any string, e.g. "Meng"
  Nobody,                      -- Nobody and Everybody are special Parties
  Everybody
    : Party ;
#+end_src

Next let us define some modals: *may*, *must* and *shan't*. These are going to be used together with actions.

#+begin_src gf :noweb-ref gfPotato
-- Modals
  May,                      -- "may (plant a potato)"
  Must,                     -- "must (plant a potato)"
  Shant                     -- "shan't (plant a potato)"
   : Modal ;
#+end_src

Finally some actions. Verbs like *Trade* and *Plant* take an object, so their type signature is `Object -> Action`. Then we define *Potato* and *Cabbage* as objects.

#+begin_src gf :noweb-ref gfPotato
-- Actions
  Trade,                    -- "trade a potato"
  Plant                     -- "plant a potato"
   : Object -> Action ;

-- Objects
  Potato : Object ;         -- "potato"
  Cabbage : Object ;        -- "cabbage"
#+end_src

With this grammar fragment, we can generate trees like this. (There's no concrete syntax yet -- we'll do it soon!)

#+begin_src
        _ MkRule _
       /     |    \
      /      |     \
  MkParty  Shant  Plant
     |              |
     |              |
   "Meng"         Potato
#+end_src


Now we'll do the concrete syntax. I have imported modules from the Resource Grammar Library (http://www.grammaticalframework.org/lib/doc/synopsis/index.html). I don't need to do it, but I'll prefix the types and functions with a module name, such as SyntaxEng, for the sake of clarity.

#+begin_src gf :noweb-ref gfPotatoCnc
  lincat
    Rule = SyntaxEng.S ;
    Party = SyntaxEng.NP ;
    Object = SyntaxEng.NP ;
    Action = SyntaxEng.VP ;
    Modal = {
      verb : SyntaxEng.VV ;
      pol : SyntaxEng.Pol
      } ;

  lin
   -- : Party -> Modal -> Action -> Rule
   MkRule party modal action =
     let modalAction : VP = -- apply the modal to the action: [may]+[plant cabbage]
           SyntaxEng.mkVP modal.verb action ;
         clause : Cl =  -- Combine subject and predicate into a clause.
           SyntaxEng.mkCl party modalAction ; -- Still open for polarity.
      in SyntaxEng.mkS modal.pol clause ; -- Polarity comes from modal

   -- : String -> Party
   MkParty str = SymbolicEng.symb str ;

   -- : Party
   Everybody = SyntaxEng.everybody_NP ;
   Nobody = SyntaxEng.nobody_NP ;

   -- : Modal
   May = {
     verb = ExtraEng.may_VV ;
     pol = SyntaxEng.positivePol
     } ;
   Must = {
     verb = SyntaxEng.must_VV ;
     pol = SyntaxEng.positivePol
     } ;
   Shant = { -- The verb is "shall", and the whole sentence will be negated.
     verb = ExtraEng.shall_VV ;
     pol = SyntaxEng.negativePol
     } ;

   -- : Object -> Action
   Trade p = SyntaxEng.mkVP trade_V2 p ;
   Plant p = SyntaxEng.mkVP plant_V2 p ;

   -- : Object
   Potato = -- mkNP with aPl_Det makes indefinite plural
     SyntaxEng.mkNP SyntaxEng.aPl_Det potato_N ;
   Cabbage = -- just mkNP makes a mass noun
     SyntaxEng.mkNP cabbage_N ;

  oper
   trade_V2 : V2 = mkV2 "trade" ;
   plant_V2 : V2 = mkV2 "plant" ;
   potato_N : N = mkN "potato" ;
   cabbage_N : N = mkN "cabbage" ;
#+end_src

TODO:
1. Explanations about the concrete syntax
2. Haskell program that translates between "everybody shan't trade cabbage" and "nobody may trade cabbage", or makes inferences like "nobody may trade cabbage" -> may Meng trade cabbage?

** Given a past potato already planted on a given date, was that potato legal?

Running directly, the rule engine asks questions like:

#+begin_src typescript :tangle potato.ts :noweb-ref clause_ts
const potato1 = {species:"Solanum tuberosum", wasPlanted:new Date("2020-01-10")}
const potato2 = {species:"Solanum tuberosum", wasPlanted:new Date("2020-01-11")}
const potato3 = {species:"Solanum tuberosum", wasPlanted:new Date("2020-01-12")}

console.log(`potato1: ` + rule1({legalDates:legalDates(new Date("2020-08-06"))}, "_", "trade", potato1, undefined))
console.log(`potato2: ` + rule1({legalDates:legalDates(new Date("2020-08-06"))}, "_", "trade", potato2, undefined))
console.log(`potato3: ` + rule1({legalDates:legalDates(new Date("2020-08-06"))}, "_", "trade", potato3, undefined))
#+end_src

The answer:

#+begin_example
potato1: MAY
potato2: MAY
potato3: SHANT
#+end_example

In a multi-tier architecture, the app queries the rule engine over a JSON API.

First it asks what information it needs to collect from the user: "I desire to sell an item, and want to know if I may. Tell me the schema for the remaining subquery".

#+begin_src json
  // the app asks:
  { "request": { "key":  "isItemLegal"
               , "goal": "deontic"
               , "known": { }
               , "asOf": "2020-08-06"
               , "id":   "2001", "version": "1", "locale": "en_SG" } }

  // the rule engine answers: (in future this will be upgraded to real JSON Schema)
  { "response": { "id": "2001"
                , "schema": { "item": { "species":    { "type": "string", "title": "Species",       "subtitle": "What species is this item?",  "hint": "Solanum tuberosum" },
                                        "wasPlanted": { "type": "string", "title": "Planting Date", "subtitle": "When was the plant planted?", "hint": "January 1 2020"    } },
                              "action": [ "trade", "purchase", "disposal", "loan", "manufacture", "harvest" ] } } }
#+end_src

The app presents the user with a query UI. At any time, even if the user has only filled in a subset of the given information, the front-end can re-query the rules engine with the new information:

#+begin_src json
  // the app asks:
  { "request": { "key":  "isItemLegal"
               , "goal": "deontic"
               , "known": { "action": "trade" }
               , "asOf": "2020-08-06"
               , "id":   "2002", "version": "1", "locale": "en_SG" } }

  // the rule engine answers:
  { "response": { "id": "2002"
                , "schema": { "item": { "species":    { "type": "string", "title": "Species",       "subtitle": "What species is this item?",  "hint": "Solanum tuberosum" },
                                        "wasPlanted": { "type": "string", "title": "Planting Date", "subtitle": "When was the plant planted?", "hint": "January 1 2020"    } } } } }
#+end_src

The rule engine always gives the most informative response it can, given the information submitted:

#+begin_src json
  // the app asks:
  { "request": { "key":  "isItemLegal"
               , "goal": "deontic"
               , "known": { "action": "trade", "item": { "species": "Lateolabrax japonicus" } }
               , "asOf": "2020-08-06"
               , "id":   "2003", "version": "1", "locale": "en_SG" } }

  // the rule engine answers:
  { "response": { "id": "2003"
                , "answer": "undefined"
                , "explanation": "Ruleset can only give judgements about potatoes, not fish." } }
#+end_src

It patiently waits until the user has given up all the information they need to give up:

#+begin_src json
  // the app asks:
  { "request": { "key":  "isItemLegal"
               , "known": { "item": { "species": "Solanum tuberosum" }, "action": "trade" }
               , "asOf": "2020-08-06"
               , "id":   "2004", "version": "1", "locale": "en_SG" } }

  // the rule engine answers:
  { "response": { "id": "2004"
                , "schema": { "item": { "wasPlanted": { "type": "string", "title": "Planting Date", "subtitle": "When was the plant planted?", "hint": "January 1 2020" } } } }
#+end_src

Some decision paths are marked as "OR UNLIKELY", which means they are only queried if supervening branches have failed. For example, it is usually a safe assumption that an exemption is not granted by the Director of Agriculture. Most end-users will abandon the interview at this point, having received a tentative answer sufficient to their needs.

#+begin_src json
  // the app asks:
  { "request": { "key":  "isItemLegal"
               , "goal": "deontic"
               , "known": { "action": "trade", "item": { "species": "Solanum tuberosum", "wasPlanted": "2020-01-15" } }
               , "asOf": "2020-08-06"
               , "id":   "2005", "version": "1", "locale": "en_SG" } }

  // the rule engine answers:
  { "response": { "id": "2005"
                , "answer": { "deontic": "SHANT"
                            , "epistemicStatus": "tentative"
                            , "explanation": "Rule 1 states: ...." }
                , "schema": { "exemption": { "granted": { "type": "boolean", "default": "false" }
                                           , "from":    { "type": "string", "hint": "DirectorOfAgriculture" } } }
                } }
#+end_src

But some completists may insist on answering:

#+begin_src json
  // the app asks:
  { "request": { "key":  "isItemLegal"
               , "goal": "deontic"
               , "known": { "action": "trade", "item": { "species": "Solanum tuberosum", "wasPlanted": "2020-01-15" }
                          , "exemption": { "granted": "true", "from": "Director Of Agriculture" } }
               , "asOf": "2020-08-06"
               , "id":   "2006", "version": "1", "locale": "en_SG" } }

  // the rule engine answers:
  { "response": { "id": "2006"
                , "answer": { "deontic": "MAY"
                            , "epistemicStatus": "confident"
                            , "explanation": "Rule 1 states: ...." }
                } }
#+end_src

* Code Extraction / Metaprogramming

Can we write code that writes code? In the examples above, the "rule engine" functions returned by the rule base to the runtime were written by hand. But it /should/ be possible to write code that writes those functions: all the information one needs is in the L4. (If it isn't, we need to grow the L4 language.)

** The encoding/interpretive process involved the following human reasoning:

We know that the correct answer is (intensionally) "the two days before and after a full moon".

The system converts that to the desired (extensional) answer by means of three operations:
1. table lookup against externally provided list of full moon dates
2. a "world knowledge" rule that /somehow knows/ that the two days adjacent to a given night, are the day preceding that night, and the day following.
3. There is an assumption that a full moon happens at night. But a night spans two dates! Also, a full moon could happen technically during the day -- that's what our data source gives us. So we use another "world knowledge" rule that /cleverly knows/ that if a full moon happens between midnight and noon, the "other allowed day" is the day before; but if a full moon happens between noon and midnight, the "other allowed day" is the day after.

** From L4
Challenge: write a parser/interpreter for the language shown above. Automate the extraction of the Prolog and Typescript code shown above. Also add transpilation targets to DocAssemble and Python. What additional hints are needed by the compiler?

Right, let's define the language, by writing tests, types, and a parser.

#+begin_src haskell :noweb-ref test-1
  describe "L4 Types" $ do
    it "a program is a list of zero or more statements" $
      parse l4program "" `shouldSucceedOn` emptyProgram1
    it "zero statements" $
      parse l4program "" emptyProgram1 `parseSatisfies` \l4 -> l4.statements == []
    it "a statement starts with a rule number" $
      parse l4program "" `shouldSucceedOn` simpleDeem1
    it "rule number 2" $
      parse l4program "" simpleDeem1 `parseSatisfies` \l4 -> head l4.statements == Deem
        { hornHead = HHOP (MkOP (ObjectSpec $ "Item" :| []) "isPotato")
        , hornBody = MkCE Normal (CEStr "Item.species ~ [\"Solanum tuberosum\"]")
        , raw = Stm "source text" "filename" 0 (Just 2) }
#+end_src

We'll set up some raw input for the tests:

#+begin_src haskell :noweb-ref test-setup
emptyProgram1 :: String
emptyProgram1 = "\n"

simpleDeem1 :: String
simpleDeem1 = "RULE 2\nDEEM Item.isPotato\nWHEN Item.species ~ [\"Solanum tuberosum\"]"
#+end_src

The basic types for the language:

#+begin_src haskell :noweb-ref l4types
  data L4Program = L4Program
    { statements :: [Statement]
    , hints :: [L4Hint]
    } deriving (Show, Eq)

  data StmCommon = Stm { src      :: String
                       , filename :: String
                       , lineno   :: Int
                       , ruleno   :: Maybe Int
                       } deriving (Show, Eq)

  data Statement = Deem { hornHead :: HornHead
                        , hornBody :: HornBody
                        , raw :: StmCommon }
                   | Define { raw :: StmCommon }
                   | Reg { preconditions :: ConditionExpr -- a Regulative rule, as seen in Hvitved chapter 2
                         , conditions    :: ConditionExpr
                         , parties       :: NonEmpty Party
                         , deontic       :: Deontic
                         , action        :: Action
                         , actionSpec    :: ActionSpec
                         , temporal      :: Temporal
                         , raw           :: StmCommon
                         }
    deriving (Show, Eq)

  data HornHead = HHOP ObjectPredicate
    deriving (Show, Eq)

  type ObjectPredicate = ObjectAttribute

  data ObjectAttribute = MkOP ObjectSpec AttributeName deriving (Eq)
  instance Show ObjectAttribute where show (MkOP (ObjectSpec os) pa) = intercalate "." (NE.toList os ++ [pa])

  data ObjectSpec = ObjectSpec (NonEmpty String) deriving Eq
  instance Show ObjectSpec where show (ObjectSpec os) = intercalate "." (NE.toList os)

  type AttributeName = String

  type HornBody = ConditionExpr

  type Party      = String
  type Action     = String
  type ActionSpec = String
  type Temporal   = String
  data Deontic    = MUST | MAY | SHANT deriving (Show, Eq) -- "must not" do something, "may not" ... which is ... must (not x)?
  data ConditionExpr = MkCE  Probability LeafCE
                     | CEOr  ConditionExpr ConditionExpr
                     | CEAnd ConditionExpr ConditionExpr
                     deriving (Show, Eq)
  data LeafCE = CEOP    ObjectPredicate
              | CEMatch ObjectAttribute MatchOp MatchRHS
              | CEStr   String
    deriving (Show, Eq)

  data MatchOp = MatchTilde
    deriving (Show, Eq)

  data MatchRHS = MatchString String
                | MatchList [MatchRHS]
    deriving (Show, Eq)

  data Probability = Likely | Normal | Unlikely deriving (Show, Eq)

  data L4Hint = L4Hint { raw :: StmCommon }
    deriving (Show, Eq)
#+end_src

A language reference manual would be a good thing to write, right about now.

And now our job is to simply parse the DSL into the types.

#+begin_src haskell :noweb-ref l4parser
type Parser = Parsec Void String

l4program :: Parser L4Program
l4program = do
  many newline
  statements <- many l4statement
  many newline
  eof
  L4Program { statements = statements, hints = [] } <$ eof

l4statement :: Parser Statement
l4statement = do
  ruleNum <- string "RULE" >> sc *> integer
  stm <- stmDeem (Stm "source text" "filename" 0 (Just ruleNum)) -- <|> stmDefine <|> stmRegulative
  return stm

stmDeem :: StmCommon -> Parser Statement
stmDeem stmc = do
  oa <- (lexeme "DEEM" *> lexeme objectAttribute) <?> "deem line"   -- DEEM Item.isLegalPotato
  ce <- conditionExpr <?> "condition expression"                    -- WHEN Item.isPotato AND Item.species ~ ["Solanum tuberosum"]
  return $ Deem (HHOP oa) ce stmc

objectAttribute :: Parser ObjectAttribute
objectAttribute = do
  mychars <- many (alphaNumChar <|> char '.' <|> char '_')
  let mywords = splitOn "." mychars
  return $ MkOP (ObjectSpec (NE.fromList $ init mywords)) (last mywords)

conditionExpr :: Parser ConditionExpr
conditionExpr = do
  ce <- lexeme "WHEN" *> (many $ noneOf ("\n" :: String))
  return $ MkCE Normal (CEStr ce)

#+end_src

For fun, we might consider using BNFC as an alternative approach.

When we've gone a little farther we will have the app/Main print interesting things and also implement the rule engine.

#+begin_src haskell :noweb-ref exe
main = do
  print "Hello, World!"
#+end_src

*** Schema Inference

Inari asked: what's up with the .wasPlanted attribute? It's not defined or deemed anywhere! Well, that just tells us that we have to interrogate it from the user! We know its type -- thanks, Hindley-Milner -- and where it fits in the object model. So just from the rule definitions we can infer the schema aka ontology:

#+begin_src typescript :noweb-ref clause_ts
interface ItemInterface {
  isPotato      : Bool;
  isLegalPotato : Bool;
  wasPlanted    : Date;
  species       : string;
}

const LegalDates : Date[];
#+end_src

Alternatively, because we know that ~isPotato~ and ~isLegalPotato~ are defined, we could make them methods of a class:

#+begin_src typescript :noweb-ref clause_ts

    class ItemClass {
      wasPlanted    : Date;
      species       : string;

      isPotato () : boolean {
        return ["Solanum tuberosum"].includes(this.species)
      }
      isLegalPotato (legalDates : Date[]) : boolean {
        return ( this.isPotato() && 
          legalDates.map(x=>x.valueOf()).includes(this.wasPlanted.valueOf()))
      }
    }
#+end_src

The properties which aren't methods are the ones we need to get from the user.

** From DMN
Challenge: extend our DMNMD engine to support the FEEL expression ~in~. Extend our DMN implementation to overload function sections involving the mathematical operators ~+ - * /~ to fmap over lists. This is how we arrive at ~legalDate2~.

* Learning Objective

Logic programming is easier in a logic programming language.

The main rule is may be decomposed into sub-rules, or rule framgments. Each rule fragment is (borrowing LegalRuleML's terminology) either a *constitutive* rule or a *prescriptive* rule.

The /prescriptive/ rule applies to farmers and other parties who seek to trade potatoes: they MAY trade only those potatoes which are legal potatoes. Illegal potatoes SHANT be traded. Note that there is no counterparty to that prescriptive rule; it applies to all.

The /constitutive/ rule applies to the potatoes: What is a potato? When is it legal?


* Case, version 2:

Potato buyers have the right, within one week of purchase, to return purchased potatoes for a 90% refund, which the seller must issue within 3 days of the return.

** In L4

This begins to look more like a contract: the emphasis is on the regulative rules, rather than the constitutive rules. While the source of this rule lies in legislation, it could be trivially transposed into a particular contract between the potato parties.


* Case, version 3:

Government drafting offices want to accelerate service delivery.
- They are currently drafting the next edition of the regulations; they want to be able to express the potato rules in code, and then have software extract those rules to English in an automated fashion.
- In version 2 of the rules, potatoes may be legally planted on days immediately preceding and following a full moon, unless one or both of those days is a public holiday, in which case the potato legality window slides to the days before and after the holiday, at the farmer's discretion; but the number of available-planting days may not exceed 2.

Economists want to know: 
- what is a farmer?
- Will Version 2 of the rules favour small producers or large producers? Assuming public holidays are frequent, and assuming the ideal planting period (which has very little to do with the phase of the moon) is relatively short, and the ideal planting period varies by geography, then farmers will want to have discretion over whether to plant before or after the public holiday. In a Big Ag scenario, there is only one farmer, with thousands of farms; are all of those farms constrained to plant potatoes on the same two days? Or can the days slide differently for different farms?

Rule developers want to know:
- What is a farmer? If a farmer has multiple farms, and different farms see the full moon at different times, and those times fall across the decision boundary, which of those farms is to be used for the calculation of the legal days? Do different farms get to elect different days?

Maybe one conclusion from a RaC approach is that allowing farmers to have discretion about how to slide the window creates too much complexity, and the government needs to mandate the alternative days induced by the public holiday.

* Infrastructure
The following blobs of code help with the tangle/noweb auto-generation of Haskell code from this README.

#+NAME: tangleWarning
#+begin_src haskell
-- DO NOT EDIT THIS FILE!
-- direct edits will be clobbered.
-- 
-- this file is autogenerated!
-- open the parent README.org in emacs and hit   C-c C-v t   to regenerate this file.
#+end_src

** Haskell Tests! TDD FTW!

#+begin_src haskell :noweb yes :tangle test/Spec.hs
{-# LANGUAGE OverloadedStrings, DuplicateRecordFields, QuasiQuotes #-}
{-# OPTIONS_GHC -F -pgmF=record-dot-preprocessor #-}

<<tangleWarning>>

module Main where

import Test.Hspec.Megaparsec
import Test.Hspec
import Data.Maybe
import Data.Map
import Data.List.Split
import Control.Monad
import Data.Tree
import Control.Arrow
import Debug.Trace
import L4.Types
import L4.Parser
import Text.Megaparsec
import Data.List.NonEmpty (NonEmpty((:|)))

main :: IO ()
main = do
  forM_ [spec1] $ hspec
  return ()

<<test-setup>>

spec1 :: Spec
spec1 = do
  <<test-1>>
#+end_src

** Haskell Executable! Something shiny for a sense of accomplishment.

#+begin_src haskell :noweb yes :tangle app/Main.hs
{-# LANGUAGE OverloadedStrings, DuplicateRecordFields, QuasiQuotes #-}
{-# OPTIONS_GHC -F -pgmF=record-dot-preprocessor #-}

<<tangleWarning>>

module Main where

import Helloworld
import Data.Map
import Data.Tree

<<test-setup>>
<<exe>>

#+end_src

** Haskell library! Used by both the tests and the executable.

#+begin_src haskell :noweb yes :tangle src/Helloworld.hs
{-# LANGUAGE OverloadedStrings, DuplicateRecordFields, QuasiQuotes #-}
{-# OPTIONS_GHC -F -pgmF=record-dot-preprocessor #-}

<<tangleWarning>>

module Helloworld where
import Data.Map
import Data.Maybe
import Data.Tree
import Data.Time.Calendar
import Data.Time.Format.ISO8601
import L4.Types
import L4.Parser

<<basicimplementation>>
#+end_src

** Haskell L4 Libraries

*** for Types
#+begin_src haskell :noweb yes :tangle src/L4/Types.hs
{-# LANGUAGE OverloadedStrings, DuplicateRecordFields, QuasiQuotes #-}
{-# OPTIONS_GHC -F -pgmF=record-dot-preprocessor #-}

<<tangleWarning>>

module L4.Types where
import qualified Data.List.NonEmpty as NE
import Data.List.NonEmpty (NonEmpty)
import Data.Map
import Data.Time.Calendar
import Data.Time.Format.ISO8601
import Data.List (intercalate)

<<l4types>>
<<l4utils>>
#+end_src

*** for Parser

#+begin_src haskell :noweb yes :tangle src/L4/Parser.hs
{-# LANGUAGE OverloadedStrings, DuplicateRecordFields, QuasiQuotes #-}
{-# OPTIONS_GHC -F -pgmF=record-dot-preprocessor #-}

<<tangleWarning>>

module L4.Parser where
import L4.Types
import Text.Megaparsec
import Text.Megaparsec.Char
import qualified Data.List.NonEmpty as NE
import qualified Text.Megaparsec.Char.Lexer as L
import Data.Void
import Data.List.Split

<<l4parser>>

-- see https://markkarpov.com/tutorial/megaparsec.html
sc :: Parser ()
sc = L.space
  space1                         -- (2)
  (L.skipLineComment "//")       -- (3)
  (L.skipBlockComment "/*" "*/") -- (4)

lexeme :: Parser a -> Parser a
lexeme = L.lexeme sc

symbol :: String -> Parser String
symbol = L.symbol sc

integer :: Parser Int
integer = lexeme L.decimal
#+end_src

** GF

#+begin_src gf :noweb yes :tangle Potato.gf
<<tangleWarning>>
abstract Potato = {
<<gfPotato>>
}
#+end_src

#+begin_src gf :noweb yes :tangle PotatoEng.gf
<<tangleWarning>>
concrete PotatoEng of Potato = open SyntaxEng, ParadigmsEng, SymbolicEng, ExtraEng in {
<<gfPotatoCnc>>
}
#+end_src

** Prolog!

#+begin_src prolog :noweb yes :tangle potato.pl
:- use_module(library(clpfd)).
:- use_module(library(julian)).
:- use_module(library(yall)).
<<prolog>>
#+end_src

You may need to

#+begin_example
pack_install(julian).
#+end_example

** Typescript!

#+begin_src typescript :tangle potato.ts
function addDays(date : Date, days : number) {
  var result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
}

#+end_src
